Arm			pub struct Arm<'tcx> 
ArmBlocks			struct ArmBlocks 
Binding			struct Binding<'tcx> 
BindingMode			pub enum BindingMode 
Block			pub struct Block<'tcx> 
BlockAnd			pub struct BlockAnd<T>(BasicBlock, T);
BlockAndExtension			trait BlockAndExtension 
BlockAndExtension for BasicBlock			impl BlockAndExtension for BasicBlock 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			pub struct Builder<'a, 'tcx: 'a> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
Builder			impl<'a,'tcx> Builder<'a,'tcx> 
CFG			impl<'tcx> CFG<'tcx> 
CFG			struct CFG<'tcx> 
Candidate			pub struct Candidate<'pat, 'tcx:'pat> 
Category			impl Category 
Category			pub enum Category 
Cx			impl<'a,'tcx:'a> Cx<'a, 'tcx> 
Cx			impl<'a,'tcx> Cx<'a,'tcx> 
Cx			pub struct Cx<'a, 'tcx: 'a> 
Cx			impl<'cx, 'tcx> Cx<'cx, 'tcx> 
EraseRegions			impl<'a, 'tcx> EraseRegions<'a, 'tcx> 
EraseRegions			pub struct EraseRegions<'a, 'tcx: 'a> 
EvalInto			pub trait EvalInto<'tcx> 
EvalInto for Expr			impl<'tcx> EvalInto<'tcx> for Expr<'tcx> 
EvalInto for ExprRef			impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> 
Expr			pub struct Expr<'tcx> 
ExprKind			pub enum ExprKind<'tcx> 
ExprRef			pub enum ExprRef<'tcx> 
FieldExprRef			pub struct FieldExprRef<'tcx> 
FieldPattern			pub struct FieldPattern<'tcx> 
InnerDump			struct InnerDump<'a, 'm, 'tcx: 'a + 'm> 
ItemRef			pub struct ItemRef<'tcx> 
LogicalOp			pub enum LogicalOp 
LoopScope			pub struct LoopScope 
MatchPair			pub struct MatchPair<'pat, 'tcx:'pat> 
MatchPair			impl<'pat, 'tcx> MatchPair<'pat, 'tcx> 
MirPass			pub trait MirPass<'tcx> 
MirPass for EraseRegions			impl<'a, 'tcx> MirPass<'tcx> for EraseRegions<'a, 'tcx> 
MirPass for SimplifyCfg			impl<'tcx> MirPass<'tcx> for SimplifyCfg 
Mirror			impl<'tcx> Mirror<'tcx> for &'tcx hir::Block 
Mirror			impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr 
Mirror			pub trait Mirror<'tcx> 
Mirror for Block			impl<'tcx> Mirror<'tcx> for Block<'tcx> 
Mirror for Expr			impl<'tcx> Mirror<'tcx> for Expr<'tcx> 
Mirror for ExprRef			impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> 
Mirror for Stmt			impl<'tcx> Mirror<'tcx> for Stmt<'tcx> 
Mirror for StmtRef			impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> 
OuterDump			impl<'a, 'tcx> OuterDump<'a, 'tcx> 
OuterDump			struct OuterDump<'a, 'tcx: 'a> 
PassArgs			enum PassArgs 
PatCx			impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> 
PatCx			struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> 
Pattern			pub struct Pattern<'tcx> 
PatternKind			pub enum PatternKind<'tcx> 
RvalueFunc			pub enum RvalueFunc 
Scope			pub struct Scope<'tcx> 
SimplifyCfg			impl SimplifyCfg 
SimplifyCfg			pub struct SimplifyCfg;
Stmt			pub struct Stmt<'tcx> 
StmtKind			pub enum StmtKind<'tcx> 
StmtRef			pub enum StmtRef<'tcx> 
Test			pub struct Test<'tcx> 
TestKind			enum TestKind<'tcx> 
ToRef			impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>
ToRef			impl<'a,'tcx:'a,T,U> ToRef for &'tcx P<[T]>
ToRef			impl<'a,'tcx:'a,T,U> ToRef for &'tcx Vec<T>
ToRef			impl<'a,'tcx:'a> ToRef for &'tcx P<hir::Expr> 
ToRef			impl<'a,'tcx:'a> ToRef for &'tcx hir::Expr 
ToRef			pub trait ToRef 
ToRef for Expr			impl<'a,'tcx:'a> ToRef for Expr<'tcx> 
Visitor for InnerDump			impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> 
Visitor for OuterDump			impl<'a, 'tcx> Visitor<'tcx> for OuterDump<'a, 'tcx> 
add_cases_to_switch			    pub fn add_cases_to_switch<'pat>(&mut self,
all_fields			    pub fn all_fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field> 
and			    fn and<T>(self, v: T) -> BlockAnd<T> 
and			    fn and<T>(self, v: T) -> BlockAnd<T>;
args_and_body			    fn args_and_body(&mut self,
as_constant			    pub fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>
as_constant			mod as_constant;
as_lvalue			    pub fn as_lvalue<M>(&mut self,
as_lvalue			mod as_lvalue;
as_operand			    pub fn as_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>
as_operand			mod as_operand;
as_rvalue			    pub fn as_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>
as_rvalue			mod as_rvalue;
as_temp			    pub fn as_temp<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Lvalue<'tcx>>
as_temp			mod as_temp;
ast_block			    pub fn ast_block(&mut self,
bin_op			fn bin_op(op: hir::BinOp_) -> BinOp 
bind_and_guard_matched_candidate			    fn bind_and_guard_matched_candidate<'pat>(&mut self,
bind_matched_candidate			    fn bind_matched_candidate(&mut self,
block			mod block;
block			mod block;
block_data			    pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> 
block_data_mut			    pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> 
bool_ty			    pub fn bool_ty(&mut self) -> Ty<'tcx> 
break_or_continue			    fn break_or_continue<F>(&mut self,
build			pub mod build;
build_mir			fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,
build_mir_for_crate			pub fn build_mir_for_crate<'tcx>(tcx: &ty::ctxt<'tcx>) -> MirMap<'tcx> 
candidate_after_variant_switch			    fn candidate_after_variant_switch<'pat>(&mut self,
candidate_without_match_pair			    fn candidate_without_match_pair<'pat>(&mut self,
capture_freevar			fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,
category			mod category;
cfg			mod cfg;
closure_self_ty			fn closure_self_ty<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,
compare			    fn compare(&mut self,
const_eval_literal			    pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> 
construct			pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,
convert_arm			fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> 
convert_path_expr			fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> ExprKind<'tcx> 
convert_var			fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,
cx			pub mod cx;
declare_binding			    fn declare_binding(&mut self,
declare_bindings			    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: &Pattern<'tcx>) 
diverge_cleanup			    pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> 
erase_regions			pub fn erase_regions<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &mut MirMap<'tcx>) 
erase_regions			pub mod erase_regions;
erase_regions_basic_block			    fn erase_regions_basic_block(&mut self,
erase_regions_constant			    fn erase_regions_constant(&mut self, constant: &mut Constant<'tcx>) 
erase_regions_lvalue			    fn erase_regions_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>) 
erase_regions_operand			    fn erase_regions_operand(&mut self, operand: &mut Operand<'tcx>) 
erase_regions_return_ty			    fn erase_regions_return_ty(&mut self, fn_output: &mut ty::FnOutput<'tcx>) 
erase_regions_rvalue			    fn erase_regions_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) 
erase_regions_statement			    fn erase_regions_statement(&mut self,
erase_regions_terminator			    fn erase_regions_terminator(&mut self,
erase_regions_tys			    fn erase_regions_tys<'b, T>(&mut self, tys: T)
error_simplifyable			    fn error_simplifyable<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> ! 
escape			fn escape<T: Debug>(t: &T) -> String 
eval_into			    fn eval_into<'a>(self,
exit_scope			    pub fn exit_scope(&mut self,
expr			mod expr;
expr			mod expr;
expr_as_constant			    fn expr_as_constant(&mut self, expr: Expr<'tcx>) -> Constant<'tcx> 
expr_as_lvalue			    fn expr_as_lvalue(&mut self,
expr_as_operand			    fn expr_as_operand(&mut self,
expr_as_rvalue			    fn expr_as_rvalue(&mut self,
expr_as_temp			    fn expr_as_temp(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<Lvalue<'tcx>> 
expr_into_pattern			    pub fn expr_into_pattern(&mut self,
extent_of_innermost_scope			    pub fn extent_of_innermost_scope(&self) -> CodeExtent 
extent_of_outermost_scope			    pub fn extent_of_outermost_scope(&self) -> CodeExtent 
false_literal			    pub fn false_literal(&mut self) -> Literal<'tcx> 
field_match_pairs			    pub fn field_match_pairs<'pat>(&mut self,
field_refs			fn field_refs<'tcx>(variant: VariantDef<'tcx>,
final_target			        fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> 
find_loop_scope			    pub fn find_loop_scope(&mut self,
graphviz			pub mod graphviz;
hair			mod hair;
in_loop_scope			    pub fn in_loop_scope<F, R>(&mut self,
in_scope			    pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>
into			mod into;
into			    pub fn into<E>(&mut self,
into			mod into;
into_expr			    pub fn into_expr(&mut self,
irrefutable_pat			    pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> 
is_switch_ty			fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool 
item_ref_operand			    pub fn item_ref_operand(&mut self,
join_otherwise_blocks			    fn join_otherwise_blocks(&mut self,
lang_function			    fn lang_function(&mut self, lang_item: lang_items::LangItem) -> Constant<'tcx> 
literal_operand			    pub fn literal_operand(&mut self,
loop_label			fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> CodeExtent 
lvalue_into_pattern			    pub fn lvalue_into_pattern(&mut self,
make_mirror			    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Block<'tcx> 
make_mirror			    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Expr<'tcx> 
make_mirror			    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Block<'tcx> 
make_mirror			    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Expr<'tcx> 
make_mirror			    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> 
make_mirror			    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Stmt<'tcx> 
make_mirror			    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Self::Output;
make_mirror			    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Expr<'tcx> 
match_candidates			    fn match_candidates<'pat>(&mut self,
match_expr			    pub fn match_expr(&mut self,
matches			mod matches;
method_callee			fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,
mir_map			pub mod mir_map;
mirror			    pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output 
mirror_stmts			fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,
misc			mod misc;
needs_drop			    pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool 
new			    pub fn new(lvalue: Lvalue<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> 
new			    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Cx<'a, 'tcx> 
new			    fn new(cx: &'patcx mut Cx<'cx, 'tcx>,
new			    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> EraseRegions<'a, 'tcx> 
new			    pub fn new() -> SimplifyCfg 
node			fn node(block: BasicBlock) -> String 
num_variants			    pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize 
of			    pub fn of<'tcx>(ek: &ExprKind<'tcx>) -> Option<Category> 
overloaded_lvalue			fn overloaded_lvalue<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,
overloaded_operator			fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,
panic			    pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) 
panic_bounds_check			    pub fn panic_bounds_check(&mut self,
pattern			mod pattern;
perform_test			    pub fn perform_test(&mut self,
pop_scope			    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) 
prefix_suffix			    fn prefix_suffix<'pat>(&mut self,
prefix_suffix_slice			    pub fn prefix_suffix_slice<'pat>(&mut self,
pretty			pub mod pretty;
push			    pub fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) 
push_assign			    pub fn push_assign(&mut self,
push_assign_constant			    pub fn push_assign_constant(&mut self,
push_assign_unit			    pub fn push_assign_unit(&mut self,
push_drop			    pub fn push_drop(&mut self, block: BasicBlock, span: Span,
push_scope			    pub fn push_scope(&mut self, extent: CodeExtent, block: BasicBlock) 
push_usize			    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: usize) -> Lvalue<'tcx> 
refutable_pat			    pub fn refutable_pat(&mut self,
remove_dead_blocks			    fn remove_dead_blocks(&self, mir: &mut Mir) 
remove_goto_chains			    fn remove_goto_chains(&self, mir: &mut Mir) -> bool 
retain_basic_blocks			pub fn retain_basic_blocks(mir: &mut Mir, keep: &[bool]) 
run_on_mir			    fn run_on_mir(&mut self, mir: &mut Mir<'tcx>) 
run_on_mir			    fn run_on_mir(&mut self, mir: &mut Mir<'tcx>);
run_on_mir			    fn run_on_mir(&mut self, mir: &mut Mir<'tcx>) 
schedule_drop			    pub fn schedule_drop(&mut self,
scope			mod scope;
simplify			mod simplify;
simplify_branches			    fn simplify_branches(&self, mir: &mut Mir) -> bool 
simplify_candidate			    pub fn simplify_candidate<'pat>(&mut self,
simplify_cfg			pub mod simplify_cfg;
simplify_match_pair			    fn simplify_match_pair<'pat>(&mut self,
slice_or_array_pattern			    fn slice_or_array_pattern(&mut self,
sort_candidate			    pub fn sort_candidate<'pat>(&mut self,
span_bug			    pub fn span_bug(&mut self, span: Span, message: &str) -> ! 
span_to_fileline_args			    fn span_to_fileline_args(&mut self, span: Span) -> (Constant<'tcx>, Constant<'tcx>) 
start_new_block			    pub fn start_new_block(&mut self) -> BasicBlock 
stmt			mod stmt;
stmts			    pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<'tcx>>) -> BlockAnd<()> 
str_literal			    pub fn str_literal(&mut self, value: token::InternedString) -> Literal<'tcx> 
tcx			    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> 
temp			    pub fn temp(&mut self, ty: Ty<'tcx>) -> Lvalue<'tcx> 
terminate			    pub fn terminate(&mut self,
test			mod test;
test			    pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> 
to_borrow_kind			fn to_borrow_kind(m: hir::Mutability) -> BorrowKind 
to_expr_ref			pub fn to_expr_ref<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, block: &'tcx hir::Block) -> ExprRef<'tcx> 
to_opt_pattern			    fn to_opt_pattern(&mut self, pat: &Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> 
to_pattern			    fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> 
to_patterns			    fn to_patterns(&mut self, pats: &[P<hir::Pat>]) -> Vec<Pattern<'tcx>> 
to_ref			mod to_ref;
to_ref			    fn to_ref(self) -> ExprRef<'tcx> 
to_ref			    fn to_ref(self) -> Option<U> 
to_ref			    fn to_ref(self) -> Self::Output;
to_ref			    fn to_ref(self) -> Vec<U> 
transform			pub mod transform;
true_literal			    pub fn true_literal(&mut self) -> Literal<'tcx> 
try_const_eval_literal			    pub fn try_const_eval_literal(&mut self, e: &hir::Expr) -> Option<Literal<'tcx>> 
unit			    fn unit(self) -> BlockAnd<()> 
unit			    fn unit(self) -> BlockAnd<()>;
update_basic_block_ids			pub fn update_basic_block_ids(mir: &mut Mir, replacements: &[BasicBlock]) 
usize_literal			    pub fn usize_literal(&mut self, value: usize) -> Literal<'tcx> 
usize_ty			    pub fn usize_ty(&mut self) -> Ty<'tcx> 
util			mod util;
util			mod util;
variant_or_leaf			    fn variant_or_leaf(&mut self,
visit_fn			    fn visit_fn(&mut self,
visit_impl_item			    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) 
visit_impl_item			    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) 
visit_item			    fn visit_item(&mut self, item: &'tcx hir::Item) 
visit_mir			    fn visit_mir<OP>(&mut self, attributes: &'a [ast::Attribute], mut walk_op: OP)
visit_trait_item			    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) 
visit_trait_item			    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) 
write_basic_block			fn write_basic_block<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> 
write_edges			fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> 
write_graph_label			fn write_graph_label<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> 
write_mir_graphviz			pub fn write_mir_graphviz<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> 
write_mir_intro			fn write_mir_intro<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> 
write_mir_pretty			pub fn write_mir_pretty<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> 
write_node			fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> 
