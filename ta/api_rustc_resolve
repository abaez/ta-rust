::std::ops::Deref for ImportResolver			impl<'a, 'b: 'a> ::std::ops::Deref for ImportResolver<'a, 'b> 
::std::ops::DerefMut for ImportResolver			impl<'a, 'b: 'a> ::std::ops::DerefMut for ImportResolver<'a, 'b> 
::std::ops::Index for PerNS			impl<T> ::std::ops::Index<Namespace> for PerNS<T> 
::std::ops::IndexMut for PerNS			impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> 
AmbiguityError			struct AmbiguityError<'a> 
AssocSuggestion			enum AssocSuggestion 
Bar			    pub mod Bar { }
Bar			impl Bar 
Bar			struct Bar; \/\/ error: duplicate definition of value `Bar`
Bar			struct Bar;
Bar2			struct Bar2; \/\/ ok!
Baz			trait Baz : Foo + Foo2 
Baz			trait Baz : Foo 
BindingError			struct BindingError 
BindingInfo			struct BindingInfo 
BuildReducedGraphVisitor			impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> 
BuildReducedGraphVisitor			pub struct BuildReducedGraphVisitor<'a, 'b: 'a> 
Default for SingleImports			impl<'a> Default for SingleImports<'a> 
Deref for UnusedImportCheckVisitor			impl<'a, 'b> Deref for UnusedImportCheckVisitor<'a, 'b> 
DerefMut for UnusedImportCheckVisitor			impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> 
EliminateCrateVar			        struct EliminateCrateVar<'b, 'a: 'b>(&'b mut Resolver<'a>, Span);
Folder for EliminateCrateVar			        impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> 
Foo			    pub struct Foo;
Foo			    struct Foo 
Foo			    struct Foo<T: Copy> 
Foo			fn Foo() -> u32 { 0 }
Foo			impl Foo 
Foo			impl<T> Foo<T> 
Foo			struct Foo { a: bool };
Foo			struct Foo;
Foo			struct Foo<T=U, U=()> 
Foo			struct Foo<U=(), T=U> 
Foo			trait Foo 
Foo			trait Foo {}
Foo for Bar			impl Foo for Bar { \/\/ ok!
Foo for Bar			impl Foo for Bar 
Foo for Bar			impl Foo for Bar {} \/\/ error: `Foo` is not a trait
Foo for i32			impl Foo for i32 
Foo for i32			impl Foo for i32 {}
Foo2			trait Foo2 
ImportDirective			impl<'a> ImportDirective<'a> 
ImportDirective			pub struct ImportDirective<'a> 
ImportDirectiveSubclass			pub enum ImportDirectiveSubclass<'a> 
ImportResolver			impl<'a, 'b:'a> ImportResolver<'a, 'b> 
ImportResolver			pub struct ImportResolver<'a, 'b: 'a> 
ImportSuggestion			struct ImportSuggestion 
InvocationData			impl<'a> InvocationData<'a> 
InvocationData			pub struct InvocationData<'a> 
LegacyBinding			pub struct LegacyBinding<'a> 
LegacyMacroImports			struct LegacyMacroImports 
LegacyScope			pub enum LegacyScope<'a> 
LexicalScopeBinding			enum LexicalScopeBinding<'a> 
LexicalScopeBinding			impl<'a> LexicalScopeBinding<'a> 
MacroBinding			impl<'a> MacroBinding<'a> 
MacroBinding			pub enum MacroBinding<'a> 
MakeGlobMap			pub enum MakeGlobMap 
ModuleData			impl<'a> ModuleData<'a> 
ModuleData			pub struct ModuleData<'a> 
ModuleKind			enum ModuleKind 
MyTrait			    pub trait MyTrait 
NameBinding			impl<'a> NameBinding<'a> 
NameBinding			pub struct NameBinding<'a> 
NameBindingKind			enum NameBindingKind<'a> 
NameResolution			impl<'a> NameResolution<'a> 
NameResolution			pub struct NameResolution<'a> 
Namespace			pub enum Namespace 
Ord for BindingError			impl Ord for BindingError 
PartialEq for BindingError			impl PartialEq for BindingError 
PartialOrd for BindingError			impl PartialOrd for BindingError 
PathResult			enum PathResult<'a> 
PathSource			enum PathSource<'a> 
PathSource			impl<'a> PathSource<'a> 
PatternSource			enum PatternSource 
PatternSource			impl PatternSource 
PerNS			pub struct PerNS<T> 
PrimitiveTypeTable			impl PrimitiveTypeTable 
PrimitiveTypeTable			struct PrimitiveTypeTable 
PrivacyError			struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);
ResolutionError			enum ResolutionError<'a> 
Resolver			impl<'a> Resolver<'a> 
Resolver			impl<'a> Resolver<'a> 
Resolver			pub struct Resolver<'a> 
Resolver			impl<'a> Resolver<'a> 
Resolver			impl<'a> Resolver<'a> 
ResolverArenas			impl<'a> ResolverArenas<'a> 
ResolverArenas			pub struct ResolverArenas<'a> 
Rib			impl<'a> Rib<'a> 
Rib			struct Rib<'a> 
RibKind			enum RibKind<'a> 
SingleImports			enum SingleImports<'a> 
SingleImports			impl<'a> SingleImports<'a> 
SomeModule			mod SomeModule 
SomeTrait			trait SomeTrait 
SomeTrait for Foo			impl SomeTrait for Foo { \/\/ ok!
SomeTrait for Foo			impl SomeTrait for Foo {} \/\/ error: trait `SomeTrait` is not in scope
Something			impl Something {} \/\/ error: type name `Something` is not in scope
Something			impl Something {} \/\/ ok!
Something			struct Something;
State			enum State 
ToNameBinding			impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) 
ToNameBinding			impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) 
ToNameBinding			impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> 
ToNameBinding			pub trait ToNameBinding<'a> 
TypeParameters			enum TypeParameters<'a, 'b> 
UnusedImportCheckVisitor			impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> 
UnusedImportCheckVisitor			struct UnusedImportCheckVisitor<'a, 'b: 'a> 
Visitor for BuildReducedGraphVisitor			impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> 
Visitor for Resolver			impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> 
Visitor for UnusedImportCheckVisitor			impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> 
a			    fn a() {}
a			    fn a();
abc			struct abc;
add_builtin			    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) 
add_directive			    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) 
add_import_directive			    pub fn add_import_directive(&mut self,
add_to_glob_map			    fn add_to_glob_map(&mut self, id: NodeId, ident: Ident) 
adjust_local_def			    fn adjust_local_def(&mut self,
alloc_import_directive			    fn alloc_import_directive(&'a self, import_directive: ImportDirective<'a>)
alloc_invocation_data			    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)
alloc_legacy_binding			    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> 
alloc_module			    fn alloc_module(&'a self, module: ModuleData<'a>) -> Module<'a> 
alloc_name_binding			    fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> 
alloc_name_resolution			    fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> 
ambiguity			    pub fn ambiguity(&self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)
arenas			    pub fn arenas() -> ResolverArenas<'a> 
b			    fn b() {} \/\/ error: method `b` is not a member of trait `Foo`
b			    fn b() {} \/\/ ok!
b			    fn b() {}
b			    fn b();
bar			    fn bar(&self, y: T) 
bar			    fn bar() -> <Self as Foo>::Bar; \/\/ ok!
bar			    fn bar() -> Self::Bar; \/\/ like this
bar			    fn bar() -> Self::Bar;
bar			    fn bar() -> u32 
bar			    fn bar() 
bar			    fn bar(N); \/\/ error: type name `N` is not in scope
bar			    fn bar(_: Self::N); \/\/ ok!
bar			    fn bar(self) {}
bar			    fn bar(y: T) { \/\/ T is defined in the "outer" function
bar			    fn bar<T: Copy>(y: T) 
bar			    fn bar<T>(y: T) 
bar			mod bar 
base::Resolver for Resolver			impl<'a> base::Resolver for Resolver<'a> 
baz			    pub mod baz {}
baz			    pub struct baz;
binding			    pub fn binding(self) -> &'a NameBinding<'a> 
binding			    fn binding(&self) -> Option<&'a NameBinding<'a>> 
binding_mode_map			    fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap 
block_needs_anonymous_module			    fn block_needs_anonymous_module(&mut self, block: &Block) -> bool 
build_reduced_graph			mod build_reduced_graph;
build_reduced_graph_for_block			    fn build_reduced_graph_for_block(&mut self, block: &Block, expansion: Mark) 
build_reduced_graph_for_external_crate_def			    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'a>, child: Export) 
build_reduced_graph_for_foreign_item			    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) 
build_reduced_graph_for_item			    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) 
build_reduced_graph_for_variant			    fn build_reduced_graph_for_variant(&mut self,
check_consistent_bindings			    fn check_consistent_bindings(&mut self, arm: &Arm) 
check_crate			pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) 
check_import			    fn check_import(&mut self, item_id: ast::NodeId, id: ast::NodeId, span: Span) 
check_proc_macro_attrs			    fn check_proc_macro_attrs(&mut self, attrs: &[ast::Attribute]) 
check_trait_item			    fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)
check_unused			mod check_unused;
check_unused_macros			    fn check_unused_macros(&self) 
cmp			    fn cmp(&self, other: &BindingError) -> cmp::Ordering 
collect_def_ids			    fn collect_def_ids(&mut self,
collect_mod			    fn collect_mod(names: &mut Vec<Ident>, module: Module) 
contains_macro_use			    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool 
core			    pub trait core 
core			struct core;
def			    fn def(&self) -> Def 
def			    fn def(&self) -> Option<Def> 
def			    fn def(self) -> Def 
def_id			    fn def_id(&self) -> Option<DefId> 
def_ignoring_ambiguity			    fn def_ignoring_ambiguity(&self) -> Def 
default			    fn default() -> Self 
defer_to_typeck			    fn defer_to_typeck(self) -> bool 
define			    pub fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)
define_macro			    pub fn define_macro(&mut self,
definitions			    fn definitions(&mut self) -> &mut Definitions 
deref			    fn deref<'c>(&'c self) -> &'c Resolver<'b> 
deref			    fn deref(&self) -> &Resolver<'b> 
deref_mut			    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> 
deref_mut			    fn deref_mut(&mut self) -> &mut Resolver<'b> 
descr			    fn descr(&self) -> &'static str 
descr			    fn descr(self) -> &'static str 
descr_expected			    fn descr_expected(self) -> &'static str 
diagnostics			mod diagnostics;
directive_failed			    fn directive_failed(&mut self) 
do_something			        fn do_something();
eliminate_crate_var			    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> 
eq			    fn eq(&self, other: &BindingError) -> bool 
err_if_macro_use_proc_macro			    fn err_if_macro_use_proc_macro(&mut self, name: Name, use_span: Span,
err_path_resolution			fn err_path_resolution() -> PathResolution 
error_code			    fn error_code(self, has_unexpected_resolution: bool) -> &'static str 
extract_node_id			        fn extract_node_id(t: &Ty) -> Option<NodeId> 
f			fn f() 
finalize_current_module_macro_resolutions			    pub fn finalize_current_module_macro_resolutions(&mut self) 
finalize_import			    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<String> 
finalize_imports			    pub fn finalize_imports(&mut self) 
finalize_resolutions_in			    fn finalize_resolutions_in(&mut self, module: Module<'b>) 
find_legacy_attr_invoc			    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for ModuleData			impl<'a> fmt::Debug for ModuleData<'a> 
fold_mac			            fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac 
fold_path			            fn fold_path(&mut self, mut path: ast::Path) -> ast::Path 
foo			     pub fn foo() {}
foo			    fn foo() 
foo			    fn foo(f: File) {}
foo			    fn foo(self) 
foo			    pub fn foo(&self, x: T) 
foo			fn foo() 
foo			fn foo() {}
foo			fn foo(f: i32, f: i32) {} \/\/ error: identifier `f` is bound more than
foo			fn foo(f: i32, g: i32) {} \/\/ ok!
foo			fn foo(x: T) {} \/\/ type name `T` is not in scope
foo			fn foo<T, T>(s: T, u: T) {} \/\/ error: the name `T` is already used for a type
foo			fn foo<T, Y>(s: T, u: Y) {} \/\/ ok!
foo			fn foo<T: Copy>(x: T) 
foo			fn foo<T>(x: T) 
foo			fn foo<T>(x: T) {} \/\/ ok!
foo			mod foo 
foo			pub mod foo 
for_each_child			    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) 
fresh_binding			    fn fresh_binding(&mut self,
gate_legacy_custom_derive			    fn gate_legacy_custom_derive(&mut self, name: Symbol, span: Span) 
get_macro			    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> 
get_macro			    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Rc<SyntaxExtension> 
get_module			    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> 
get_module_scope			    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark 
get_resolution			    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> 
get_traits_containing_item			    fn get_traits_containing_item(&mut self, mut ident: Ident, ns: Namespace)
get_traits_in_module_containing_item			    fn get_traits_in_module_containing_item(&mut self,
global_by_default			    fn global_by_default(self) -> bool 
hir::lowering::Resolver for Resolver			impl<'a> hir::lowering::Resolver for Resolver<'a> 
hygienic_lexical_parent			    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, ctxt: &mut SyntaxContext)
import			    pub fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)
import_candidate_to_paths			fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, String) 
import_directive_subclass_to_string			fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> String 
import_dummy_binding			    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) 
import_path_to_string			fn import_path_to_string(names: &[Ident], subclass: &ImportDirectiveSubclass) -> String 
index			    fn index(&self, ns: Namespace) -> &T 
index_mut			    fn index_mut(&mut self, ns: Namespace) -> &mut T 
insert_field_names			    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) 
intern			    fn intern(&mut self, string: &str, primitive_type: PrimTy) 
is_accessible			    fn is_accessible(&self, vis: ty::Visibility) -> bool 
is_accessible_from			    fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool 
is_expected			    fn is_expected(self, def: Def) -> bool 
is_extern_crate			    fn is_extern_crate(&self) -> bool 
is_glob			    pub fn is_glob(&self) -> bool 
is_glob_import			    fn is_glob_import(&self) -> bool 
is_import			    fn is_import(&self) -> bool 
is_importable			    fn is_importable(&self) -> bool 
is_local			    fn is_local(&self) -> bool 
is_macro_def			    fn is_macro_def(&self) -> bool 
is_normal			    fn is_normal(&self) -> bool 
is_refutable			    fn is_refutable(self) -> bool 
is_self_type			fn is_self_type(path: &[Ident], namespace: Namespace) -> bool 
is_self_value			fn is_self_value(path: &[Ident], namespace: Namespace) -> bool 
is_struct_like			fn is_struct_like(def: Def) -> bool 
is_trait			    fn is_trait(&self) -> bool 
is_variant			    fn is_variant(&self) -> bool 
is_whitelisted_legacy_custom_derive			    fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool 
item			    fn item(self) -> Option<&'a NameBinding<'a>> 
legacy_import_macro			    fn legacy_import_macro(&mut self,
legacy_macro_imports			    fn legacy_macro_imports(&mut self, attrs: &[ast::Attribute]) -> LegacyMacroImports 
local_modules			    fn local_modules(&'a self) -> ::std::cell::Ref<'a, Vec<Module<'a>>> 
lookup_assoc_candidate			    fn lookup_assoc_candidate<FilterFn>(&mut self,
lookup_import_candidates			    fn lookup_import_candidates<FilterFn>(&mut self,
lookup_typo_candidate			    fn lookup_typo_candidate<FilterFn>(&mut self,
macro_def_scope			    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> 
macros			mod macros;
main			fn main () 
main			fn main() 
main			fn main() {}
module			    fn module(&self) -> Option<Module<'a>> 
module_to_string			fn module_to_string(module: Module) -> String 
names_to_string			fn names_to_string(idents: &[Ident]) -> String 
namespace			    fn namespace(self) -> Namespace 
nearest_item_scope			    fn nearest_item_scope(&'a self) -> Module<'a> 
new			    fn new() -> PrimitiveTypeTable 
new			    fn new(kind: RibKind<'a>) -> Rib<'a> 
new			    fn new(parent: Option<Module<'a>>,
new			    pub fn new(session: &'a Session,
new_module			    fn new_module(
next_node_id			    fn next_node_id(&mut self) -> ast::NodeId 
parent			    fn parent(self, id: DefId) -> Option<DefId> 
parent			    fn parent(self, id: DefId) -> Option<DefId> 
partial_cmp			    fn partial_cmp(&self, other: &BindingError) -> Option<cmp::Ordering> 
path_names_to_string			fn path_names_to_string(path: &Path) -> String 
per_ns			    fn per_ns<T, F: FnMut(&mut Self, Namespace) -> T>(&mut self, mut f: F) -> PerNS<T> 
populate_module_if_necessary			    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) 
print_on_failure			fn print_on_failure(state: &State) 
process_legacy_macro_imports			    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>, expansion: Mark)
pseudo_vis			    fn pseudo_vis(&self) -> ty::Visibility 
record_candidate_traits_for_expr_if_necessary			    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) 
record_def			    fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) 
record_use			    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)
report_conflict			    fn report_conflict(&mut self,
report_errors			    fn report_errors(&mut self) 
report_shadowing_errors			    fn report_shadowing_errors(&mut self) 
resolution			    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)
resolve_arm			    fn resolve_arm(&mut self, arm: &Arm) 
resolve_block			    fn resolve_block(&mut self, block: &Block) 
resolve_crate			    pub fn resolve_crate(&mut self, krate: &Crate) 
resolve_crate_root			    fn resolve_crate_root(&mut self, mut ctxt: SyntaxContext) -> Module<'a> 
resolve_error			fn resolve_error<'sess, 'a>(resolver: &'sess Resolver,
resolve_expr			    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) 
resolve_glob_import			    fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) 
resolve_hir_path			    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) 
resolve_ident_in_lexical_scope			    fn resolve_ident_in_lexical_scope(&mut self,
resolve_ident_in_module			    fn resolve_ident_in_module(&mut self,
resolve_ident_in_module_unadjusted			    pub fn resolve_ident_in_module_unadjusted(&mut self,
resolve_implementation			    fn resolve_implementation(&mut self,
resolve_import			    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool 
resolve_imports			mod resolve_imports;
resolve_imports			    fn resolve_imports(&mut self) 
resolve_imports			    pub fn resolve_imports(&mut self) 
resolve_invoc			    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)
resolve_invoc_to_def			    fn resolve_invoc_to_def(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)
resolve_item			    fn resolve_item(&mut self, item: &Item) 
resolve_labeled_block			    fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) 
resolve_legacy_scope			    pub fn resolve_legacy_scope(&mut self,
resolve_lexical_macro_path_segment			    pub fn resolve_lexical_macro_path_segment(&mut self,
resolve_local			    fn resolve_local(&mut self, local: &Local) 
resolve_macro			    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)
resolve_macro_to_def			    fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)
resolve_path			    fn resolve_path(&mut self,
resolve_pattern			    fn resolve_pattern(&mut self,
resolve_qpath			    fn resolve_qpath(&mut self,
resolve_qpath_anywhere			    fn resolve_qpath_anywhere(&mut self,
resolve_self			    fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> 
resolve_struct_error			fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,
resolve_visibility			    fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility 
root			    pub fn root(graph_root: Module<'a>) -> Self 
run_macro			    fn run_macro() { debug_assert!(true); }
search_label			    fn search_label(&self, mut ident: Ident) -> Option<Def> 
self_type_is_available			    fn self_type_is_available(&mut self, span: Span) -> bool 
self_value_is_available			    fn self_value_is_available(&mut self, ctxt: SyntaxContext, span: Span) -> bool 
show_candidates			fn show_candidates(err: &mut DiagnosticBuilder,
smart_resolve_path			    fn smart_resolve_path(&mut self,
smart_resolve_path_fragment			    fn smart_resolve_path_fragment(&mut self,
some_function			    fn some_function(f: File) {}
something			mod something 
something_that_does_exist			enum something_that_does_exist 
something_that_does_exist			mod something_that_does_exist 
span			    pub fn span(self) -> Span 
suggest_macro_name			    fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,
to_name_binding			    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> 
to_name_binding			    fn to_name_binding(self, _: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> 
to_name_binding			    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a>;
try_define			    pub fn try_define(&mut self,
ty			impl<'a, 'b: 'a> ty::DefIdTree for &'a Resolver<'b> 
ty			impl<'a, 'b: 'a> ty::DefIdTree for &'a ImportResolver<'a, 'b> 
update_resolution			    fn update_resolution<T, F>(&mut self, module: Module<'a>, ident: Ident, ns: Namespace, f: F)
visit_arm			    fn visit_arm(&mut self, arm: &'tcx Arm) 
visit_block			    fn visit_block(&mut self, block: &'a Block) 
visit_block			    fn visit_block(&mut self, block: &'tcx Block) 
visit_expansion			    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]) 
visit_expr			    fn visit_expr(&mut self, expr: &'tcx Expr) 
visit_fn			    fn visit_fn(&mut self,
visit_foreign_item			    fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) 
visit_foreign_item			    fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) 
visit_generics			    fn visit_generics(&mut self, generics: &'tcx Generics) 
visit_invoc			    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> 
visit_item			    fn visit_item(&mut self, item: &'a Item) 
visit_item			    fn visit_item(&mut self, item: &'a ast::Item) 
visit_item			    fn visit_item(&mut self, item: &'tcx Item) 
visit_local			    fn visit_local(&mut self, local: &'tcx Local) 
visit_poly_trait_ref			    fn visit_poly_trait_ref(&mut self,
visit_stmt			    fn visit_stmt(&mut self, stmt: &'a ast::Stmt) 
visit_trait_item			    fn visit_trait_item(&mut self, item: &'a TraitItem) 
visit_ty			    fn visit_ty(&mut self, ty: &'tcx Ty) 
visit_variant			    fn visit_variant(&mut self,
warn_legacy_self_import			    fn warn_legacy_self_import(&self, directive: &'a ImportDirective<'a>) 
with_constant_rib			    fn with_constant_rib<F>(&mut self, f: F)
with_current_self_type			    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T
with_empty_ribs			    fn with_empty_ribs<T, F>(&mut self, f: F) -> T
with_item_rib			    fn with_item_rib<F>(&mut self, f: F)
with_label_rib			    fn with_label_rib<F>(&mut self, f: F)
with_module_lexical_scope			    pub fn with_module_lexical_scope<T, F>(&mut self, module: Module<'a>, f: F) -> T
with_optional_trait_ref			    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T
with_resolved_label			    fn with_resolved_label<F>(&mut self, label: Option<SpannedIdent>, id: NodeId, f: F)
with_scope			    fn with_scope<F>(&mut self, id: NodeId, f: F)
with_self_rib			    fn with_self_rib<F>(&mut self, self_def: Def, f: F)
with_type_parameter_rib			    fn with_type_parameter_rib<'b, F>(&'b mut self, type_parameters: TypeParameters<'a, 'b>, f: F)
xyz			struct xyz;
