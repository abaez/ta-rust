Add for Foo			impl Add for Foo 
AdjustBorrowKind			impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> 
AdjustBorrowKind			struct AdjustBorrowKind<'a,'tcx:'a> 
AdtField			struct AdtField<'tcx> 
AdtVariant			struct AdtVariant<'tcx> 
AllTraits			pub struct AllTraits<'a> 
AstConv			pub trait AstConv<'tcx> 
AstConv for FnCtxt			impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> 
AstConv for ItemCtxt			impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> 
AstConvRequest			enum AstConvRequest 
B			enum B 
B			enum B {}
B			impl B 
Bad			enum Bad 
Bad			struct Bad(String); \/\/ This will cause an error
Bad			struct Bad(u16, u32, u32); \/\/ This will cause an error
Bad			struct Bad; \/\/ This will cause an error
Bad			struct Bad<T>(T, T, T); \/\/ This will cause an error
Bar			enum Bar { A(u8), B(&bool), }        \/\/ error
Bar			enum Bar { A, B, C }
Bar			enum Bar<'a> { A(u8), B(&'a bool), } \/\/ correct
Bar			impl Bar for *mut Foo 
Bar			struct Bar { x: Foo }
Bar			struct Bar 
Bar			struct Bar;
Bar			struct Bar<'a> 
Bar			struct Bar<S, T> { x: Foo<S, T> }
Bar			trait Bar : Foo 
Bar			trait Bar { }
Bar			trait Bar 
Bar			trait Bar {}
Bar			trait Bar: Foo { }
Bar			unsafe trait Bar { }
Bar for Baz			impl Bar for Baz { } \/\/ error, `Baz` implements `Bar` by definition
Bar for Foo			impl Bar for Foo { }
Bar for Foo			unsafe impl Bar for Foo { }
Bar for u32			impl Bar for u32 
Baz			struct Baz<'a> 
Baz			trait Baz 
Baz			trait Baz: Bar { }
Baz for Bar			impl Baz for Bar { } \/\/ Note: This is OK
Baz for Baz			impl Baz for Baz { } \/\/ error, `Baz` (trivially) implements `Baz`
Baz for Foo			impl Baz for Foo 
BinOpCategory			enum BinOpCategory 
BinOpCategory			impl BinOpCategory 
BindingRscope			impl BindingRscope 
BindingRscope			pub struct BindingRscope 
Bounds			impl<'tcx> Bounds<'tcx> 
Bounds			pub struct Bounds<'tcx> 
Bytes			impl Bytes { ... } \/\/ error, same as above
CallResolution			struct CallResolution<'tcx> 
CallStep			enum CallStep<'tcx> 
Candidate			impl<'tcx> Candidate<'tcx> 
Candidate			struct Candidate<'tcx> 
CandidateKind			enum CandidateKind<'tcx> 
CandidateSource			pub enum CandidateSource 
CandidateStep			struct CandidateStep<'tcx> 
CastCheck			impl<'tcx> CastCheck<'tcx> 
CastCheck			pub struct CastCheck<'tcx> 
CastError			enum CastError 
CheckItemBodiesVisitor			struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }
CheckItemTypesVisitor			struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }
CheckTypeWellFormedVisitor			impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> 
CheckTypeWellFormedVisitor			pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> 
Coerce			impl<'f, 'tcx> Coerce<'f, 'tcx> 
Coerce			struct Coerce<'a, 'tcx: 'a> 
CoherenceCheckVisitor			struct CoherenceCheckVisitor<'a, 'tcx: 'a> 
CoherenceChecker			impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> 
CoherenceChecker			struct CoherenceChecker<'a, 'tcx: 'a> 
CollectItemTypesVisitor			struct CollectItemTypesVisitor<'a, 'tcx: 'a> 
ConfirmContext			impl<'a,'tcx> ConfirmContext<'a,'tcx> 
ConfirmContext			struct ConfirmContext<'a, 'tcx:'a> 
Constraint			struct Constraint<'a> 
ConstraintContext			impl<'a, 'tcx> ConstraintContext<'a, 'tcx> 
ConstraintContext			struct ConstraintContext<'a, 'tcx: 'a> 
ConvertedBinding			struct ConvertedBinding<'tcx> 
Copy			impl Copy for &'static Bar { } \/\/ error
Copy for Foo			impl Copy for Foo { } \/\/ error
Copy for Foo			impl Copy for Foo { }
CrateCtxt			impl<'a,'tcx> CrateCtxt<'a,'tcx> 
CrateCtxt			struct CrateCtxt<'a,'tcx:'a> 
CrateCtxt			pub struct CrateCtxt<'a, 'tcx: 'a> 
DeferredCallResolution			trait DeferredCallResolution<'tcx> 
DeferredCallResolution for CallResolution			impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> 
Dog			struct Dog 
Drop for Bar			impl Drop for Bar 
Drop for Foo			impl Drop for Foo { \/\/ and you can implement the trait on it!
Drop for Foo			impl Drop for Foo 
Drop for Foo			impl Drop for Foo<u32> 
Drop for MyStruct			impl<T: Foo> Drop for MyStruct<T> 
Drop for MyStructWrapper			impl <T: Foo> Drop for MyStructWrapper<T> 
Drop for MyTrait			impl Drop for MyTrait 
Drop for MyWrapper			impl <'a> Drop for MyWrapper<'a> 
Drop for MyWrapper			impl <T: MyTrait> Drop for MyWrapper<T> 
Drop for u32			impl Drop for u32 {}
DropckContext			struct DropckContext<'a, 'b: 'a, 'tcx: 'b> 
ElidableRscope			impl ElidableRscope 
ElidableRscope			pub struct ElidableRscope 
ElisionFailureInfo			pub struct ElisionFailureInfo 
Empty			enum Empty {}
Enum			enum Enum 
Eq for TraitInfo			impl Eq for TraitInfo {}
Error			enum Error<'tcx> 
Expectation			impl<'tcx> Expectation<'tcx> 
Expectation			pub enum Expectation<'tcx> 
ExplicitRscope			pub struct ExplicitRscope;
FirstTrait			trait FirstTrait : SecondTrait 
FnCtxt			impl<'a, 'tcx> FnCtxt<'a, 'tcx> 
FnCtxt			pub struct FnCtxt<'a, 'tcx: 'a> 
Foo			enum Foo { B(u32) }
Foo			enum Foo { B{ i: u32 } }
Foo			enum Foo { FirstValue(i32) };
Foo			enum Foo { Q }
Foo			enum Foo 
Foo			enum Foo<'a> 
Foo			enum Foo<T> 
Foo			impl Foo { }
Foo			impl Foo 
Foo			pub struct Foo; \/\/ you define your type in your crate
Foo			pub struct Foo<T=U, U=()> 
Foo			pub struct Foo<U=(), T=U> 
Foo			struct Foo { x: &bool }        \/\/ error
Foo			struct Foo { x: Box<Foo> } \/\/ error
Foo			struct Foo { x: Option<Box<Foo>> }
Foo			struct Foo { x: bool }
Foo			struct Foo 
Foo			struct Foo(u32);
Foo			struct Foo(u8);
Foo			struct Foo;
Foo			struct Foo<'a, T: 'a> 
Foo			struct Foo<'a, T> 
Foo			struct Foo<'a> { x: &'a bool } \/\/ correct
Foo			struct Foo<'a> 
Foo			struct Foo<'a>(&'a str);
Foo			struct Foo<T> { x: T }
Foo			struct Foo<T> 
Foo			trait Foo { fn foo(&self) { } }
Foo			trait Foo 
Foo			trait Foo {}
Foo			trait Foo<T> 
Foo			trait Foo{}
Foo			unsafe impl Foo { }
Foo for Bar			impl Foo for Bar 
Foo for Bar			impl Foo for Bar {}
Foo for Baz			impl Foo for Baz { } \/\/ error, `Baz` implements `Bar` which implements `Foo`
Foo for MyStruct			impl Foo for MyStruct 
Foo for Wrapper			impl <T> Foo for Wrapper<T> where Wrapper<T>: Clone 
Foo for Wrapper			impl Foo for Wrapper<u32> where Wrapper<u32>: Clone 
ForeignTrait for MyType			impl<T> ForeignTrait for MyType<T> { ... } \/\/ Ok
ForeignTrait for T			impl<T> ForeignTrait for T { ... } \/\/ error
ForeignTrait for T0			impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }
ForeignTrait2			impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { ... } \/\/ Ok
ForeignTrait2			impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { ... } \/\/ error
From for i32			impl From<Foo> for i32 { \/\/ or you use a type from your crate as
Fruit			enum Fruit 
GatherLocalsVisitor			impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> 
GatherLocalsVisitor			struct GatherLocalsVisitor<'a, 'tcx: 'a> 
GetTypeParameterBounds			impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)
GetTypeParameterBounds			impl<'tcx> GetTypeParameterBounds<'tcx> for () 
GetTypeParameterBounds			trait GetTypeParameterBounds<'tcx> 
GetTypeParameterBounds for hir			impl<'tcx> GetTypeParameterBounds<'tcx> for hir::Generics 
GetTypeParameterBounds for ty			impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> 
Good			struct Good(u32); \/\/ This will not
Good			struct Good(u32, u32, u32); \/\/ This will not
InferredIndex			struct InferredIndex(usize);
InferredInfo			struct InferredInfo<'a> 
Inherited			impl<'a, 'tcx> Inherited<'a, 'tcx> 
Inherited			pub struct Inherited<'a, 'tcx: 'a> 
InstantiatedMethodSig			struct InstantiatedMethodSig<'tcx> 
IsAssign			enum IsAssign 
ItemCtxt			impl<'a,'tcx> ItemCtxt<'a,'tcx> 
ItemCtxt			struct ItemCtxt<'a,'tcx:'a> 
Iterator for AllTraits			impl<'a> Iterator for AllTraits<'a> 
ListNode			struct ListNode 
M			    fn M() {} \/\/ ok!
M			    fn M();
MethodError			pub enum MethodError<'tcx> 
Mode			pub enum Mode 
MyMod			mod MyMod 
MyStruct			struct MyStruct;
MyStruct			struct MyStruct<T> 
MyStructWrapper			struct MyStructWrapper<T: Foo> 
MySubMod			    mod MySubMod { }
MyTrait			trait MyTrait 
MyTrait			trait MyTrait {type X; }
MyTrait			trait MyTrait {}
MyTrait for Foo			impl MyTrait for Foo { \/\/ error: conflicting implementations of trait
MyTrait for Foo			impl MyTrait for Foo 
MyTrait for Foo			impl<T> MyTrait for Foo 
MyTrait for MyStruct			impl MyTrait for MyStruct 
MyTrait for T			impl<T> MyTrait for T 
MyType			struct MyType<T>(T);
MyType2			struct MyType2;
MyWrapper			struct MyWrapper<'a> { foo: &'a MyTrait }
MyWrapper			struct MyWrapper<T: MyTrait> { foo: T }
N			    fn N() {}
NineString			impl NineString 
NoMatchData			impl<'tcx> NoMatchData<'tcx> 
NoMatchData			pub struct NoMatchData<'tcx> 
Number			enum Number 
ObjectLifetimeDefaultRscope			impl<'r> ObjectLifetimeDefaultRscope<'r> 
ObjectLifetimeDefaultRscope			pub struct ObjectLifetimeDefaultRscope<'r> 
Ord for TraitInfo			impl Ord for TraitInfo 
OrphanChecker			impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> 
OrphanChecker			struct OrphanChecker<'cx, 'tcx:'cx> 
OverlapChecker			impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> 
OverlapChecker			struct OverlapChecker<'cx, 'tcx:'cx> 
ParamKind			enum ParamKind 
Parameter			pub enum Parameter 
PartialEq for TraitInfo			impl PartialEq for TraitInfo 
PartialOrd for TraitInfo			impl PartialOrd for TraitInfo 
PartitionedBounds			pub struct PartitionedBounds<'a> 
PathParamMode			pub enum PathParamMode 
Pick			pub struct Pick<'tcx> 
PickKind			pub enum PickKind<'tcx> 
ProbeContext			impl<'a,'tcx> ProbeContext<'a,'tcx> 
ProbeContext			struct ProbeContext<'a, 'tcx:'a> 
Quux			trait Quux { }
Quux for Foo			impl Quux for Foo { } \/\/ error: expected 1, found 0
Rcx			impl<'a, 'tcx> Rcx<'a, 'tcx> 
Rcx			pub struct Rcx<'a, 'tcx: 'a> 
RegionScope			pub trait RegionScope 
RegionScope for BindingRscope			impl RegionScope for BindingRscope 
RegionScope for ElidableRscope			impl RegionScope for ElidableRscope 
RegionScope for ExplicitRscope			impl RegionScope for ExplicitRscope 
RegionScope for FnCtxt			impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> 
RegionScope for ObjectLifetimeDefaultRscope			impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> 
RegionScope for ShiftedRscope			impl<'r> RegionScope for ShiftedRscope<'r> 
RegionScope for UnelidableRscope			impl RegionScope for UnelidableRscope 
RepeatingScope			pub struct RepeatingScope(ast::NodeId);
ResolveReason			enum ResolveReason 
ResolveReason			impl ResolveReason 
Resolver			impl<'cx, 'tcx> Resolver<'cx, 'tcx> 
Resolver			struct Resolver<'cx, 'tcx: 'cx> 
SecondTrait			trait SecondTrait : FirstTrait 
SeedBorrowKind			impl<'a,'tcx> SeedBorrowKind<'a,'tcx> 
SeedBorrowKind			struct SeedBorrowKind<'a,'tcx:'a> 
SelfInfo			struct SelfInfo<'a, 'tcx> 
Send			unsafe impl Send for &'static Foo 
ShiftedRscope			impl<'r> ShiftedRscope<'r> 
ShiftedRscope			pub struct ShiftedRscope<'r> 
SizedByDefault			enum SizedByDefault { Yes, No, }
SolveContext			impl<'a, 'tcx> SolveContext<'a, 'tcx> 
SolveContext			struct SolveContext<'a, 'tcx: 'a> 
SomeStruct			struct SomeStruct 
SomeTypeThatDoesntExist			impl SomeTypeThatDoesntExist {  }
SubjectNode			pub enum SubjectNode { Subject(ast::NodeId), None }
T1			trait T1 {}
T2			trait T2 {}
TermsContext			impl<'a, 'tcx> TermsContext<'a, 'tcx> 
TermsContext			struct TermsContext<'a, 'tcx: 'a> 
Test			impl Test 
Test			struct Test;
Thing			enum Thing 
Thing			struct Thing 
Trait			trait Trait 
Trait for Foo			impl Trait for Foo 
Trait1			trait Trait1 
Trait1 for Test			impl Trait1 for Test { fn foo() {} }
Trait2			trait Trait2 
Trait2 for Test			impl Trait2 for Test { fn foo() {} }
TraitInfo			impl TraitInfo 
TraitInfo			pub struct TraitInfo 
TupleArgumentsFlag			enum TupleArgumentsFlag 
TypeAndSubsts			pub struct TypeAndSubsts<'tcx> 
TypeContext			enum TypeContext 
TypeFolder for Resolver			impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> 
UnelidableRscope			impl UnelidableRscope 
UnelidableRscope			pub struct UnelidableRscope(Option<Vec<ElisionFailureInfo>>);
UnresolvedTypeAction			pub enum UnresolvedTypeAction 
UnsafetyChecker			impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> 
UnsafetyChecker			struct UnsafetyChecker<'cx, 'tcx:'cx> 
UnsafetyState			impl UnsafetyState 
UnsafetyState			pub struct UnsafetyState 
UnsizeKind			enum UnsizeKind<'tcx> 
VarianceTerm			enum VarianceTerm<'a> 
Vec			impl Vec<u8> { ... } \/\/ error
Visitor			        struct Visitor<'a, 'tcx:'a> 
Visitor for AdjustBorrowKind			impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> 
Visitor for CheckItemBodiesVisitor			impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> 
Visitor for CheckItemTypesVisitor			impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> 
Visitor for CheckTypeWellFormedVisitor			impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> 
Visitor for ConstraintContext			impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> 
Visitor for GatherLocalsVisitor			impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> 
Visitor for Rcx			impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> 
Visitor for SeedBorrowKind			impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> 
Visitor for TermsContext			impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> 
Visitor for WritebackCx			impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> 
Wrapper			struct Wrapper<T> 
WritebackCx			impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> 
WritebackCx			struct WritebackCx<'cx, 'tcx: 'cx> 
Xform			trait Xform 
Xform for ty			impl Xform for ty::Variance 
_match			pub mod _match;
add			    fn add(self, rhs: Foo) -> Foo 
add_constraint			    fn add_constraint(&mut self,
add_constraints_from_crate			fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,
add_constraints_from_mt			    fn add_constraints_from_mt(&mut self,
add_constraints_from_region			    fn add_constraints_from_region(&mut self,
add_constraints_from_sig			    fn add_constraints_from_sig(&mut self,
add_constraints_from_substs			    fn add_constraints_from_substs(&mut self,
add_constraints_from_trait_ref			    fn add_constraints_from_trait_ref(&mut self,
add_constraints_from_ty			    fn add_constraints_from_ty(&mut self,
add_inferred			    fn add_inferred(&mut self,
add_inferreds_for_item			    fn add_inferreds_for_item(&mut self,
add_inherent_impl			    fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) 
add_obligations			    fn add_obligations(&mut self,
add_obligations_for_parameters			    pub fn add_obligations_for_parameters(&self,
add_trait_impl			    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) 
add_unsized_bound			fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx>,
add_wf_bounds			    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)
adjust_closure_kind			    fn adjust_closure_kind(&self,
adjust_expr_ty			    pub fn adjust_expr_ty(&self,
adjust_for_branches			    fn adjust_for_branches<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> 
adjust_region_parameters			    fn adjust_region_parameters(
adjust_self_ty			    fn adjust_self_ty(&mut self,
adjust_type_parameters			    fn adjust_type_parameters<'a, 'tcx>(
adjust_upvar_borrow_kind			    fn adjust_upvar_borrow_kind(&self,
adjust_upvar_borrow_kind_for_consume			    fn adjust_upvar_borrow_kind_for_consume(&self,
adjust_upvar_borrow_kind_for_mut			    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: mc::cmt<'tcx>) 
adjust_upvar_borrow_kind_for_unique			    fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) 
all_traits			pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> 
analyze_closure			    fn analyze_closure(&mut self,
anon_regions			    fn anon_regions(&self, span: Span, count: usize)
anon_regions			    fn anon_regions(&self,
assemble_closure_candidates			    fn assemble_closure_candidates(&mut self,
assemble_extension_candidates_for_all_traits			    fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> 
assemble_extension_candidates_for_trait			    fn assemble_extension_candidates_for_trait(&mut self,
assemble_extension_candidates_for_trait_impls			    fn assemble_extension_candidates_for_trait_impls(&mut self,
assemble_extension_candidates_for_traits_in_scope			    fn assemble_extension_candidates_for_traits_in_scope(&mut self,
assemble_inherent_candidates			    fn assemble_inherent_candidates(&mut self) 
assemble_inherent_candidates_from_object			    fn assemble_inherent_candidates_from_object(&mut self,
assemble_inherent_candidates_from_param			    fn assemble_inherent_candidates_from_param(&mut self,
assemble_inherent_impl_candidates_for_type			    fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) 
assemble_inherent_impl_for_primitive			    fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) 
assemble_inherent_impl_probe			    fn assemble_inherent_impl_probe(&mut self, impl_def_id: DefId) 
assemble_probe			    fn assemble_probe(&mut self, self_ty: Ty<'tcx>) 
assemble_projection_candidates			    fn assemble_projection_candidates(&mut self,
assemble_where_clause_candidates			    fn assemble_where_clause_candidates(&mut self,
assign			    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> 
assoc			mod assoc;
associated_path_def_to_ty			fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,
ast_path_substs_for_ty			pub fn ast_path_substs_for_ty<'tcx>(
ast_path_to_mono_trait_ref			fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,
ast_path_to_poly_trait_ref			fn ast_path_to_poly_trait_ref<'a,'tcx>(
ast_path_to_ty			fn ast_path_to_ty<'tcx>(
ast_region_to_region			pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)
ast_ty_arg_to_ty			pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,
ast_ty_to_trait_ref			fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,
ast_ty_to_ty			pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,
ast_type_binding_to_poly_projection_predicate			fn ast_type_binding_to_poly_projection_predicate<'tcx>(
astconv			mod astconv;
atomic_fence			    fn atomic_fence(); \/\/ ok!
atomic_foo			    fn atomic_foo(); \/\/ error: unrecognized atomic operation
autoderef			pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,
bad_struct_kind_err			fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) 
bar			    fn bar(&mut self) { }
bar			    fn bar(&self) -> bool { self.0 > 5 }
bar			    fn bar(&self) { }
bar			    fn bar(&self);
bar			    fn bar() {} \/\/ error: duplicate associated function
bar			    fn bar() {} \/\/ ok!
bar			    fn bar();
bar			    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);
bar			    fn bar<'a,'b>(x: &'a str, y: &'b str) 
bar			fn bar(foo: Foo) -> u32 
bar			fn bar(x: &str, y: &str) -> &str { ... }
base_def_to_ty			fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,
base_object_lifetime_default			    fn base_object_lifetime_default(&self, span: Span) -> ty::Region 
base_object_lifetime_default			    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region 
base_object_lifetime_default			    fn base_object_lifetime_default(&self, span: Span) -> ty::Region 
base_object_lifetime_default			    fn base_object_lifetime_default(&self, span: Span) -> ty::Region;
baz			    fn baz(&self) -> bool { self.0 > 5 }
baz			    fn baz(&self) -> bool { true }
baz			    fn baz(&self) -> bool;
baz			fn baz<'a>(x: &'a str, y: &str) -> &str { ... }
bb			    fn bb() -> i32 { 0 }
blank_fn_ctxt			pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,
borrow			    fn borrow(&mut self,
callee			mod callee;
cast			mod cast;
check			    pub fn check<'a>(mut self, fcx: &FnCtxt<'a, 'tcx>) 
check			    fn check(&self) 
check			pub fn check(tcx: &ty::ctxt) 
check			pub fn check(tcx: &ty::ctxt) 
check			pub fn check(tcx: &ty::ctxt) 
check			pub mod check;
check_addr_ptr_cast			    fn check_addr_ptr_cast<'a>(&self,
check_argument_types			fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_assoc_item_is_const			fn check_assoc_item_is_const(pcx: &pat_ctxt, def: def::Def, span: Span) -> bool 
check_bare_fn			fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
check_binop			pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_binop_assign			pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_block_no_value			pub fn check_block_no_value<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, blk: &'tcx hir::Block)  
check_block_with_expected			fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_bounds_are_used			pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
check_call			pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_casts			    fn check_casts(&self) 
check_closure			fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_closure			    fn check_closure(&mut self,
check_coherence			pub fn check_coherence(crate_context: &CrateCtxt) 
check_const			fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
check_const_in_type			fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,
check_const_with_ty			fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_crate			pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) 
check_decl_initializer			pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_decl_local			pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx hir::Local)  
check_def_id			    fn check_def_id(&self, item: &hir::Item, def_id: DefId) 
check_dereferencable			pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,
check_drop_impl			pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: DefId) -> Result<(), ()> 
check_drop_impls			pub fn check_drop_impls(ccx: &CrateCtxt) 
check_enum_variants			pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
check_expr			fn check_expr<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx hir::Expr)  
check_expr_closure			pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_expr_coercable_to_type			fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_expr_eq_type			fn check_expr_eq_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_expr_fn_block			fn check_expr_fn_block(rcx: &mut Rcx,
check_expr_has_type			pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_expr_struct			    fn check_expr_struct<'a, 'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_expr_struct_fields			    fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_expr_with_expectation			fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_expr_with_expectation_and_lvalue_pref			fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_expr_with_hint			fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &'tcx hir::Expr,
check_expr_with_lvalue_pref			fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx hir::Expr,
check_expr_with_unifier			fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,
check_field			    fn check_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_fn			fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,
check_fn_or_method			    fn check_fn_or_method<'fcx>(&mut self,
check_for_entry_fn			fn check_for_entry_fn(ccx: &CrateCtxt) 
check_for_overlapping_impls_of_trait			    fn check_for_overlapping_impls_of_trait(&mut self, trait_def_id: DefId) 
check_fptr_ptr_cast			    fn check_fptr_ptr_cast<'a>(&self,
check_if_impls_overlap			    fn check_if_impls_overlap(&self,
check_impl			    fn check_impl(&mut self,
check_impl_items_against_trait			fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
check_implementation			    fn check_implementation(&self, item: &Item) 
check_implementations_of_coerce_unsized			    fn check_implementations_of_coerce_unsized(&self) 
check_implementations_of_copy			    fn check_implementations_of_copy(&self) 
check_intrinsic_type			pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) 
check_item			    fn check_item(&self, item: &hir::Item) 
check_item_bodies			pub fn check_item_bodies(ccx: &CrateCtxt) 
check_item_body			pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) 
check_item_fn			    fn check_item_fn(&mut self,
check_item_type			pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) 
check_item_type			    fn check_item_type(&mut self,
check_item_types			pub fn check_item_types(ccx: &CrateCtxt) 
check_item_well_formed			    fn check_item_well_formed(&mut self, item: &hir::Item) 
check_legal_trait_for_method_call			pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: DefId) 
check_lit			fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_main_fn_ty			fn check_main_fn_ty(ccx: &CrateCtxt,
check_match			pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_method_argument_types			fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_method_body			fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
check_method_call			    fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_method_receiver			    fn check_method_receiver<'fcx>(&mut self,
check_overloaded_binop			fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_pat			pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,
check_pat_enum			pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,
check_pat_struct			pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx hir::Pat,
check_platform_intrinsic_type			pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,
check_primitive_impl			    fn check_primitive_impl(&self,
check_ptr_addr_cast			    fn check_ptr_addr_cast<'a>(&self,
check_ptr_ptr_cast			    fn check_ptr_ptr_cast<'a>(&self,
check_ref_cast			    fn check_ref_cast<'a>(&self,
check_region_bounds_on_impl_method			    fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,
check_representable			pub fn check_representable(tcx: &ty::ctxt,
check_safety_of_destructor_if_necessary			pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,
check_safety_of_rvalue_destructor_if_necessary			fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,
check_simd			pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) 
check_start_fn_ty			fn check_start_fn_ty(ccx: &CrateCtxt,
check_stmt			pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx hir::Stmt)  
check_struct			pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) 
check_struct_fields_on_error			    fn check_struct_fields_on_error<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_struct_pat_fields			pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,
check_then_else			    fn check_then_else<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_trait			    fn check_trait(&mut self,
check_trait_fn_not_const			fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
check_trait_on_unimplemented			fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
check_trait_or_impl_item			    fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) 
check_tup_field			    fn check_tup_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
check_type_argument_count			fn check_type_argument_count(tcx: &ty::ctxt, span: Span, supplied: usize,
check_type_defn			    fn check_type_defn<F>(&mut self, item: &hir::Item, mut lookup_fields: F) where
check_unsafety_coherence			    fn check_unsafety_coherence(&mut self, item: &'v hir::Item,
check_user_unop			pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
check_variances_for_type_defn			    fn check_variances_for_type_defn(&self,
check_wf_new			pub fn check_wf_new(ccx: &CrateCtxt) 
check_where_clauses			    fn check_where_clauses<'fcx>(&mut self,
closure			mod closure;
closure_analyze_const			pub fn closure_analyze_const(fcx: &FnCtxt,
closure_analyze_fn			pub fn closure_analyze_fn(fcx: &FnCtxt,
cmp			    fn cmp(&self, other: &TraitInfo) -> Ordering 
code_to_origin			    fn code_to_origin(&self,
coerce			    fn coerce(&self,
coerce			pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
coerce_borrowed_pointer			    fn coerce_borrowed_pointer(&self,
coerce_from_fn_item			    fn coerce_from_fn_item(&self,
coerce_from_fn_pointer			    fn coerce_from_fn_pointer(&self,
coerce_mutbls			fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,
coerce_unsafe_ptr			    fn coerce_unsafe_ptr(&self,
coerce_unsized			    fn coerce_unsized(&self,
coercion			pub mod coercion;
coherence			pub mod coherence;
collapse_candidates_to_trait_pick			    fn collapse_candidates_to_trait_pick(&self,
collect			pub mod collect;
collect_item_types			pub fn collect_item_types(tcx: &ty::ctxt) 
compare_const_impl			pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,
compare_impl_method			pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,
compare_method			mod compare_method;
components_must_outlive			fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
compute_bounds			fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,
compute_object_lifetime_bound			fn compute_object_lifetime_bound<'tcx>(
compute_object_lifetime_default			fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
compute_type_scheme_of_foreign_fn_decl			fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(
compute_type_scheme_of_foreign_item			fn compute_type_scheme_of_foreign_item<'a, 'tcx>(
compute_type_scheme_of_item			fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
confirm			    fn confirm(&mut self,
confirm			pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
confirm			mod confirm;
confirm_builtin_call			fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
confirm_deferred_closure_call			fn confirm_deferred_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
confirm_overloaded_call			fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,
consider_candidates			    fn consider_candidates(&self,
consider_probe			    fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>,
constant_term			    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'a> 
constrain_autoderefs			fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,
constrain_bindings_in_pat			fn constrain_bindings_in_pat(pat: &hir::Pat, rcx: &mut Rcx) 
constrain_call			fn constrain_call<'a, I: Iterator<Item=&'a hir::Expr>>(rcx: &mut Rcx,
constrain_callee			fn constrain_callee(rcx: &mut Rcx,
constrain_cast			fn constrain_cast(rcx: &mut Rcx,
constrain_index			fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,
constrained_type_params			mod constrained_type_params;
consume			    fn consume(&mut self,
consume_pat			    fn consume_pat(&mut self,
contravariant			    fn contravariant(&mut self,
conv_existential_bounds			fn conv_existential_bounds<'tcx>(
conv_existential_bounds_from_partitioned_bounds			pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(
conv_param_bounds			fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,
conv_poly_trait_ref			fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx>,
conv_ty_poly_trait_ref			fn conv_ty_poly_trait_ref<'tcx>(
convert_angle_bracketed_parameters			fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,
convert_associated_const			fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_associated_type			fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_default_type_parameter			fn convert_default_type_parameter<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_enum_def			fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,
convert_enum_variant			    fn convert_enum_variant<'tcx>(tcx: &ty::ctxt<'tcx>,
convert_enum_variant_types			fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_field			fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_foreign_item			fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_item			fn convert_item(ccx: &CrateCtxt, it: &hir::Item) 
convert_method			fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_parenthesized_parameters			fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,
convert_struct_def			fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,
convert_struct_variant			fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,
convert_trait_predicates			fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) 
convert_ty_with_lifetime_elision			fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,
convert_typed_item			fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
convert_variant_ctor			fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,
count_modifiers			    fn count_modifiers(ty: Ty) -> usize 
create_impl_from_item			    fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> 
create_region_substs			fn create_region_substs<'tcx>(
create_steps			fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
create_substs_for_ast_path			fn create_substs_for_ast_path<'tcx>(
create_substs_for_ast_trait_ref			fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,
cycle_check			    fn cycle_check<F,R>(&self,
decl_without_init			    fn decl_without_init(&mut self,
declaration			trait declaration. Ensure lifetime declarations match exactly in both trait
declared_generic_bounds_from_env			fn declared_generic_bounds_from_env<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
declared_projection_bounds_from_trait			fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,
declared_variance			    fn declared_variance(&self,
deduce_expectations_from_expected_type			fn deduce_expectations_from_expected_type<'a,'tcx>(
deduce_expectations_from_obligations			fn deduce_expectations_from_obligations<'a,'tcx>(
deduce_sig_from_projection			fn deduce_sig_from_projection<'a,'tcx>(
def_struct_variant			    pub fn def_struct_variant(&self,
default_type_parameter			    fn default_type_parameter<'tcx>(p: &ty::TypeParameterDef<'tcx>, self_ty: Option<Ty<'tcx>>)
default_type_parameters			    fn default_type_parameters(&self) 
defined			trait defined in another crate) where
demand			pub mod demand;
demo			fn demo(devil: fn () -> !) 
determine_parameters_to_be_inferred			fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,
determine_self_type			fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx>,
diagnostics			pub mod diagnostics;
disr_in_range			    fn disr_in_range(ccx: &CrateCtxt,
do_check			    fn do_check<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> 
do_check			    fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
do_something			    fn do_something(&self) -> T;
do_something			    fn do_something() 
do_something			fn do_something() 
do_something			fn do_something(x: Foo::Bar) { }
do_something			fn do_something(x: MyMod::MySubMod) { }
do_something_else			    fn do_something_else<T: Clone>(&self, bar: T);
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) {}
dropck			pub mod dropck;
early_bound_lifetimes_from_generics			fn early_bound_lifetimes_from_generics(space: ParamSpace,
elaborate_bounds			    fn elaborate_bounds<F>(
enforce_builtin_binop_types			fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
enforce_illegal_method_limitations			    fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) 
enforce_impl_lifetimes_are_constrained			fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,
enforce_impl_params_are_constrained			fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,
enforce_trait_manually_implementable			fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id: DefId) 
ensure_drop_params_and_item_params_correspond			fn ensure_drop_params_and_item_params_correspond<'tcx>(
ensure_drop_predicates_are_implied_by_item_defn			fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(
ensure_no_ty_param_bounds			fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,
ensure_super_predicates			    fn ensure_super_predicates(&self, span: Span, id: DefId)
ensure_super_predicates			    fn ensure_super_predicates(&self, _: Span, _: DefId) -> Result<(), ErrorReported> 
ensure_super_predicates			    fn ensure_super_predicates(&self, span: Span, trait_def_id: DefId)
ensure_super_predicates			    fn ensure_super_predicates(&self,
ensure_super_predicates_step			fn ensure_super_predicates_step(ccx: &CrateCtxt,
enum_variants			fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
eq			    fn eq(&self, other: &TraitInfo) -> bool 
eqtype			pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,
equate_intrinsic_type			fn equate_intrinsic_type<'a, 'tcx>(tcx: &ty::ctxt<'tcx>, it: &hir::ForeignItem,
erase_late_bound_regions			    fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T
err_args			fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: usize) -> Vec<Ty<'tcx>> 
err_count_since_creation			    pub fn err_count_since_creation(&self) -> usize 
error_192			pub fn error_192<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) 
error_194			pub fn error_194<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, name: ast::Name) 
error_380			pub fn error_380<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) 
error_392			pub fn error_392<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, param_name: ast::Name)
euv::Delegate for AdjustBorrowKind			impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> 
evaluate			    fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance 
evaluate_disr_expr			    fn evaluate_disr_expr<'tcx>(tcx: &ty::ctxt<'tcx>,
exists			pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
expected_types_for_fn_args			fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
expr_ty			    pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> 
extract_trait_ref			    fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where
f			fn f() {}
f			fn f(a: u16, b: &str) {}
f64x2			struct f64x2(f64, f64);
field_ty			    pub fn field_ty(&self,
final_upvar_tys			    fn final_upvar_tys(&mut self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> 
find_binding_for_lifetime			    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId 
find_bound_for_assoc_item			fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,
find_conflicting_default			    fn find_conflicting_default(&self,
find_implied_output_region			fn find_implied_output_region<'tcx>(tcx: &ty::ctxt<'tcx>,
finish_resolving_def_to_ty			pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,
fix_scalar_binary_expr			    fn fix_scalar_binary_expr(&mut self, e: &hir::Expr) 
fixup_derefs_on_method_receiver_if_necessary			    fn fixup_derefs_on_method_receiver_if_necessary(&self,
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for VarianceTerm			impl<'a> fmt::Debug for VarianceTerm<'a> 
fold_region			    fn fold_region(&mut self, r: ty::Region) -> ty::Region 
fold_ty			    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> 
foo			    fn foo (x: u8, ...);
foo			    fn foo(&self) -> bool { true }
foo			    fn foo(&self) {}
foo			    fn foo(&self);
foo			    fn foo(&self, x: u8) -> bool;
foo			    fn foo((a, b): (u32, u32)); \/\/ error: patterns aren't allowed in foreign
foo			    fn foo() {} \/\/ ok!
foo			    fn foo() {}
foo			    fn foo(); \/\/ error: unrecognized intrinsic function: `foo`
foo			    fn foo();
foo			    fn foo(a: (u32, u32)); \/\/ ok!
foo			    fn foo(s: SomeStruct); \/\/ ok!
foo			    fn foo(x: bool) -> Self { Bar }
foo			    fn foo(x: i16) { }
foo			    fn foo(x: u16);
foo			    fn foo<T: Default>(x: T) -> Self;
foo			extern "C" fn foo (x: u8, ...);
foo			fn foo() -> ! { return; } \/\/ error
foo			fn foo() -> &str { ... }
foo			fn foo() -> _ { 5 } \/\/ error, explicitly write out the return type instead
foo			fn foo() -> u8 
foo			fn foo() -> usize { 12 }
foo			fn foo(bar: i32) {}
foo			fn foo(bar: i32+std::fmt::Display) {}
foo			fn foo(x: u8, ...) {}
foo			fn foo<F: Fn()>(f: F) 
foo			fn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }
foo			fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }
foo			fn foo<T, U>() {}
foo			fn foo<T, U>(x: T) {}
foo			fn foo<T>() {}
fresh_receiver_substs			    fn fresh_receiver_substs(&mut self,
from			    fn from(op: hir::BinOp) -> BinOpCategory 
from			    fn from(i: Foo) -> i32 
from_bounds			    fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
from_infcx			    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx, 'tcx>,
from_predicates			    fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
function			    pub fn function(unsafety: hir::Unsafety, def: ast::NodeId) -> UnsafetyState 
get			    fn get(&self) -> usize { 0 }
get			    fn get(&self) -> usize { self.value }
get			    fn get(&self) -> usize 
get			    fn get(&self) -> usize;
get_bar_bad			fn get_bar_bad<F: Foo>(t: F) -> f64 
get_bar_good			fn get_bar_good() -> f64 
get_base_type_def_id			fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,
get_free_substs			    fn get_free_substs(&self) -> Option<&Substs<'tcx>> 
get_free_substs			    fn get_free_substs(&self) -> Option<&Substs<'tcx>> 
get_item_type_scheme			    fn get_item_type_scheme(&self, span: Span, id: DefId)
get_item_type_scheme			    fn get_item_type_scheme(&self, _: Span, id: DefId)
get_item_type_scheme			    fn get_item_type_scheme(&self, span: Span, id: DefId)
get_or_create_type_parameter_def			fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
get_str			    fn get_str(&self) -> &'static str 
get_trait_def			    fn get_trait_def(&self, span: Span, id: DefId)
get_trait_def			    fn get_trait_def(&self, _: Span, id: DefId)
get_trait_def			    fn get_trait_def(&self, span: Span, id: DefId)
get_trait_def			    fn get_trait_def(&self, trait_id: DefId)
get_type_parameter_bounds			    fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)
get_type_parameter_bounds			    fn get_type_parameter_bounds(&self,
get_type_parameter_bounds			    fn get_type_parameter_bounds(&self,
get_type_substs_for_defs			fn get_type_substs_for_defs<'tcx>(this: &AstConv<'tcx>,
get_value			    fn get_value<'a>(&'a self) -> &'a str { &self.value }
glb			fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance 
handle_external_def			        fn handle_external_def(traits: &mut AllTraitsVec,
has_applicable_self			    fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool 
has_dtor_of_interest			fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,
i16x8			struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);
i32x4			struct i32x4(i32, i32, i32, i32);
i64x2			struct i64x2(i64, i64);
i64x8			struct i64x8(i64, i64, i64, i64, i64, i64, i64, i64);
i8x16			struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8,
icx			    fn icx(&'a self, param_bounds: &'a GetTypeParameterBounds<'tcx>) -> ItemCtxt<'a,'tcx> 
identify_constrained_type_params			pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,
impl_can_possibly_match			    fn impl_can_possibly_match(&self, impl_def_id: DefId) -> bool 
impl_implied_bounds			fn impl_implied_bounds<'fcx,'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,
impl_item			fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,
impl_item			fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,
impl_self_ty			pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
impl_ty_and_substs			    fn impl_ty_and_substs(&self,
infcx			    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> 
infcx			    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> 
infcx			    pub fn infcx(&self) -> &infer::InferCtxt<'a,'tcx> 
infcx			    pub fn infcx(&self) -> &InferCtxt<'a,'tcx> 
infcx			    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> 
infer_variance			pub fn infer_variance(tcx: &ty::ctxt) 
inferred_index			    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex 
instantiate_bounds			    fn instantiate_bounds(&self,
instantiate_method_sig			    fn instantiate_method_sig(&mut self,
instantiate_method_substs			    fn instantiate_method_substs(&mut self,
instantiate_mono_trait_ref			pub fn instantiate_mono_trait_ref<'tcx>(
instantiate_path			pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
instantiate_poly_trait_ref			pub fn instantiate_poly_trait_ref<'tcx>(
instantiate_type			    pub fn instantiate_type(&self,
instantiate_type_scheme			    fn instantiate_type_scheme<T>(&self,
int_in_range			        fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool 
intravisit::Visitor for CoherenceCheckVisitor			impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> 
intravisit::Visitor for CollectItemTypesVisitor			impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> 
intravisit::Visitor for OrphanChecker			impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> 
intravisit::Visitor for OverlapChecker			impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> 
intravisit::Visitor for UnsafetyChecker			impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> 
intravisit::Visitor for Visitor			        impl<'v, 'a, 'tcx> intravisit::Visitor<'v> for Visitor<'a, 'tcx> 
intrinsic			mod intrinsic;
invariant			    fn invariant(&mut self,
is_builtin_binop			fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>,
is_lifetime			fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool 
is_local			    fn is_local(ty: Ty) -> bool 
is_param			fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,
is_to_be_inferred			    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool 
item_substs			    pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> 
items			trait items like associated types or constants. Example:
iterate_over_potentially_unsafe_regions_in_type			fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(
lang_items			fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> 
link_addr_of			fn link_addr_of(rcx: &mut Rcx, expr: &hir::Expr,
link_autoref			fn link_autoref(rcx: &Rcx,
link_by_ref			fn link_by_ref(rcx: &Rcx,
link_fn_args			fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[hir::Arg]) 
link_local			fn link_local(rcx: &Rcx, local: &hir::Local) 
link_match			fn link_match(rcx: &Rcx, discr: &hir::Expr, arms: &[hir::Arm]) 
link_pattern			fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
link_reborrowed_region			fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
link_region			fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
link_region_from_node_type			fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
local_ty			    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> 
lookup			pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
lookup_full_def			fn lookup_full_def(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def 
lookup_in_trait			pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
lookup_in_trait_adjusted			pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
lookup_indexing			fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
lookup_op_method			fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,
main			fn main() -> i32 { 0 }
main			fn main() 
main			fn main();
main			fn main()
main			fn main<T>() { \/\/ error: main function is not allowed to have type parameters
make_object_type			fn make_object_type<'tcx>(this: &AstConv<'tcx>,
make_overloaded_lvalue_return_type			fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
make_sub_ty			    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> 
match_intrinsic_type_to_type			fn match_intrinsic_type_to_type<'tcx, 'a>(
matched_pat			    fn matched_pat(&mut self,
may_break			pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &hir::Block) -> bool 
method			pub mod method;
method			    fn method(&self) {}
method			    fn method<T>(&self, v: &[T]) -> usize 
mk_assignty			pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
mk_eqty			    pub fn mk_eqty(&self,
mk_item_substs			fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
mk_subr			    pub fn mk_subr(&self,
mk_subregion_due_to_dereference			pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,
mk_subty			    pub fn mk_subty(&self,
mk_trait_substs			    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
mutate			    fn mutate(&mut self,
name_and_trait_def_id			fn name_and_trait_def_id(fcx: &FnCtxt,
new			    pub fn new(expr: hir::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)
new			    fn new(fcx: &'a FnCtxt<'a, 'tcx>,
new			    pub fn new(static_candidates: Vec<CandidateSource>,
new			    fn new(fcx: &'a FnCtxt<'a,'tcx>,
new			    fn new(def_id: DefId) -> TraitInfo 
new			    fn new(tcx: &'a ty::ctxt<'tcx>,
new			    pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,
new			    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> SeedBorrowKind<'a,'tcx> 
new			    fn new(fcx: &'a FnCtxt<'a,'tcx>,
new			    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>)
new			    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>) -> WritebackCx<'cx, 'tcx> 
new			    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>,
new			    pub fn new() -> BindingRscope 
new			    pub fn new(base_scope: &'r (RegionScope+'r)) -> ShiftedRscope<'r> 
new			    pub fn new(base_scope: &'r (RegionScope+'r),
new			    pub fn new(r: ty::Region) -> ElidableRscope 
new			    pub fn new(v: Option<Vec<ElisionFailureInfo>>) -> UnelidableRscope 
new_select_all_obligations_and_apply_defaults			    fn new_select_all_obligations_and_apply_defaults(&self) 
next			    fn next(&mut self) -> Option<TraitInfo> 
next_disr			    fn next_disr(tcx: &ty::ctxt,
next_region			    fn next_region(&self) -> ty::Region 
node_ty			    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> 
normalize_associated_type			    fn normalize_associated_type(&self,
normalize_associated_types_in			pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,
normalize_associated_types_in			    fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T
normalize_associated_types_in			    fn normalize_associated_types_in<T>(&self,
num_inferred			    fn num_inferred(&self) -> usize 
object_lifetime_default			    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> 
object_lifetime_default			    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> 
object_lifetime_default			    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;
object_path_to_poly_trait_ref			fn object_path_to_poly_trait_ref<'a,'tcx>(
oh_no			fn oh_no() -> ! { panic!("the devil is in the details") }
old_select_all_obligations_and_apply_defaults			    fn old_select_all_obligations_and_apply_defaults(&self) 
one_bound_for_assoc_type			fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,
only_has_type			    fn only_has_type<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> 
op			mod op;
opt_ast_region_to_region			pub fn opt_ast_region_to_region<'tcx>(
opt_node_ty_substs			    pub fn opt_node_ty_substs<F>(&self,
order_impls			    fn order_impls(&self, impl1_def_id: DefId, impl2_def_id: DefId)
orphan			mod orphan;
overlap			mod overlap;
param			    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> 
param_bound			fn param_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, param_ty: ty::ParamTy) -> VerifyBound 
param_env			    pub fn param_env(&self) -> &ty::ParameterEnvironment<'a,'tcx> 
param_ty			    fn param_ty(&self,
param_ty_must_outlive			fn param_ty_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
parameters_for_region			fn parameters_for_region(region: &ty::Region) -> Option<Parameter> 
parameters_for_regions_in_substs			fn parameters_for_regions_in_substs(substs: &subst::Substs) -> Vec<Parameter> 
parameters_for_trait_ref			pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>,
parameters_for_type			pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>,
parameters_for_type_shallow			fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> 
partial_cmp			    fn partial_cmp(&self, other: &TraitInfo) -> Option<Ordering> { Some(self.cmp(other)) }
partition_bounds			pub fn partition_bounds<'a>(tcx: &ty::ctxt,
pat_ctxt			pub struct pat_ctxt<'a, 'tcx: 'a> 
pick			    fn pick(mut self) -> PickResult<'tcx> 
pick_autorefd_method			    fn pick_autorefd_method(&mut self,
pick_by_value_method			    fn pick_by_value_method(&mut self,
pick_core			    fn pick_core(&mut self) -> Option<PickResult<'tcx>> 
pick_initial_variance			    fn pick_initial_variance(&self,
pick_method			    fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> 
pick_most_restrictive_closure_kind			fn pick_most_restrictive_closure_kind(best: Option<ty::ClosureKind>,
pick_step			    fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> 
populate_destructors			    fn populate_destructors(&self) 
predicates			    pub fn predicates(&self,
predicates_for_associated_types			    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
predicates_from_bound			fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx>,
printf			    fn printf(_: *const c_char, ...) -> c_int;
probe			mod probe;
probe			pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
prohibit_projections			fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,
project_item_susbts			        fn project_item_susbts<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)
projected_ty			    fn projected_ty(&self,
projected_ty			    fn projected_ty(&self,
projected_ty			    fn projected_ty(&self,
projected_ty_from_poly_trait_ref			    fn projected_ty_from_poly_trait_ref(&self,
projected_ty_from_poly_trait_ref			    fn projected_ty_from_poly_trait_ref(&self,
projection_bound			fn projection_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
projection_declared_bounds			fn projection_declared_bounds<'a, 'tcx>(rcx: &Rcx<'a,'tcx>,
projection_must_outlive			fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
push_explicit_angle_bracketed_parameters_from_segment_to_substs			    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs<'a, 'tcx>(
push_explicit_parameters_from_segment_to_substs			    fn push_explicit_parameters_from_segment_to_substs<'a, 'tcx>(
push_explicit_parenthesized_parameters_from_segment_to_substs			    fn push_explicit_parenthesized_parameters_from_segment_to_substs<'a, 'tcx>(
qpath_to_ty			fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,
record_deferred_call_resolution			    fn record_deferred_call_resolution(&self,
record_static_candidate			    fn record_static_candidate(&mut self, source: CandidateSource) 
recurse			    pub fn recurse(&mut self, blk: &hir::Block) -> UnsafetyState 
recursive_type_bound			fn recursive_type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
regionck			pub mod regionck;
regionck_expr			pub fn regionck_expr(fcx: &FnCtxt, e: &hir::Expr) 
regionck_fn			pub fn regionck_fn(fcx: &FnCtxt,
regionck_item			pub fn regionck_item<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,
register_builtin_bound			    pub fn register_builtin_bound(&self,
register_old_wf_obligation			    pub fn register_old_wf_obligation(&self,
register_predicate			    pub fn register_predicate(&self,
register_region_obligation			    pub fn register_region_obligation(&self,
register_wf_obligation			    pub fn register_wf_obligation(&self,
reject_shadowing_type_parameters			fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,
relate_free_regions			    fn relate_free_regions(&mut self,
remove_deferred_call_resolutions			    fn remove_deferred_call_resolutions(&self,
replace_late_bound_regions_with_fresh_var			    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T
report_ambiguous_associated_type			fn report_ambiguous_associated_type(tcx: &ty::ctxt,
report_bivariance			    fn report_bivariance(&self,
report_candidates			    fn report_candidates(fcx: &FnCtxt,
report_cast_error			    fn report_cast_error<'a>(&self, fcx: &FnCtxt<'a, 'tcx>,
report_cast_to_unsized_type			fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
report_cycle			    fn report_cycle(&self,
report_discrim_overflow			    fn report_discrim_overflow(tcx: &ty::ctxt,
report_elision_failure			fn report_elision_failure(
report_error			pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
report_error			    fn report_error(&self, e: infer::FixupError) 
report_lifetime_number_error			fn report_lifetime_number_error(tcx: &ty::ctxt, span: Span, number: usize, expected: usize) 
report_mismatched_types			    pub fn report_mismatched_types(&self,
report_overlap_error			    fn report_overlap_error(&self,
report_unknown_field			    fn report_unknown_field<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
report_unused_parameter			fn report_unused_parameter(tcx: &ty::ctxt,
require_c_abi_if_variadic			fn require_c_abi_if_variadic(tcx: &ty::ctxt,
require_expr_have_sized_type			    pub fn require_expr_have_sized_type(&self,
require_same_types			fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,
require_type_is_sized			    pub fn require_type_is_sized(&self,
require_type_meets			    pub fn require_type_meets(&self,
reset			    fn reset(&mut self) 
resolve			    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) 
resolve			    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>);
resolve			    fn resolve<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> 
resolve			    fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T 
resolve_expr_type_adjusted			    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr) -> Ty<'tcx> 
resolve_method_type			    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> 
resolve_node_type			    fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> 
resolve_regions_and_report_errors			    fn resolve_regions_and_report_errors(&self) 
resolve_ty_and_def_ufcs			pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,
resolve_type			    pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> 
resolve_type_vars_if_possible			    fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> 
resolve_type_vars_in_expr			pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &hir::Expr) 
resolve_type_vars_in_fn			pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,
resolve_ufcs			pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
rscope			mod rscope;
rvalue_hint			    fn rvalue_hint(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> 
select_all_obligations_and_apply_defaults			    fn select_all_obligations_and_apply_defaults(&self) 
select_all_obligations_or_error			    fn select_all_obligations_or_error(&self) 
select_new_obligations			    fn select_new_obligations(&self) 
select_obligations_where_possible			    fn select_obligations_where_possible(&self) 
self_type_matches_expected_vid			fn self_type_matches_expected_vid<'a,'tcx>(
sess			    pub fn sess(&self) -> &Session 
set_body_id			    fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId 
set_call_site_scope			    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>) -> Option<CodeExtent> 
set_repeating_scope			    fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId 
setup_constraining_predicates			pub fn setup_constraining_predicates<'tcx>(_tcx: &ty::ctxt<'tcx>,
simd_shuffle			    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;
simd_shuffle8			    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;
size_of			    fn size_of<T, U>() -> usize; \/\/ error: intrinsic has wrong number
size_of			    fn size_of<T>() -> usize; \/\/ ok!
size_of			    fn size_of<T>(); \/\/ error: intrinsic has wrong type
solve			    fn solve(&mut self) 
solve_constraints			fn solve_constraints(constraints_cx: ConstraintContext) 
some_func			fn some_func(i: &mut i32) 
some_func			fn some_func(x: &mut i32) 
some_func			fn some_func(x: &u32) 
some_function			fn some_function() 
some_other_func			fn some_other_func() {}
span			    fn span(&self, tcx: &ty::ctxt) -> Span 
span_of_impl			    fn span_of_impl(&self, impl_did: DefId) -> Span 
static_inherited_fields			fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,
struct_variant			fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
structurally_resolve_type_or_else			fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,
structurally_resolved_type			pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
substs_wf_in_scope			pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,
subtype			    fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> 
suggest			mod suggest;
suggest_field_names			    fn suggest_field_names<'tcx>(err: &mut DiagnosticBuilder,
suggest_traits_to_import			fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
suptype			pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,
suptype_with_fn			pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,
t			    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { \/\/ ok!
t			    fn t<'a,'b:'a>(x: &'a str, y: &'b str);
tag			    pub fn tag(&self) -> String 
tcx			    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;
tcx			    fn tcx(&self) -> &ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &'a ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &'a ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }
tcx			    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &'a ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &'cx ty::ctxt<'tcx> 
tcx			    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> 
tcx			    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }
tcx			    fn tcx(&self) -> &'a ty::ctxt<'tcx> 
to_option			    fn to_option<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> 
to_source			    fn to_source(&self) -> CandidateSource 
to_ty			    pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> 
to_ty			    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &hir::Ty) -> Ty<'tcx> 
to_unadjusted_pick			    fn to_unadjusted_pick(&self) -> Pick<'tcx> 
trait			               impl trait, self type, or predicates",
trait_def_id			fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &hir::TraitRef) -> DefId 
trait_def_of_item			fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
trait_defines_associated_type_named			    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, name: ast::Name)
trait_defines_associated_type_named			    fn trait_defines_associated_type_named(&self,
trait_defines_associated_type_named			    fn trait_defines_associated_type_named(&self,
trait_defines_associated_type_named			fn trait_defines_associated_type_named(ccx: &CrateCtxt,
trait_item			fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,
trait_item			fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,
trait_ref_to_object_type			fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,
trivial_cast_lint			    fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) 
try_adjust_upvar_deref			    fn try_adjust_upvar_deref(&self,
try_coercion_cast			    fn try_coercion_cast<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool 
try_index_step			fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
try_overloaded_call_step			fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
try_overloaded_call_traits			fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,
try_overloaded_deref			fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
ty_generic_predicates			fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
ty_generic_predicates_for_fn			fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
ty_generic_predicates_for_type_or_impl			fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
ty_generics			fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
ty_generics_for_fn			fn ty_generics_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
ty_generics_for_trait			fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
ty_generics_for_type_or_impl			fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,
ty_infer			        fn ty_infer(&self,
ty_infer			    fn ty_infer(&self,
ty_infer			        fn ty_infer(&self,
ty_of_arg			pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,
ty_of_bare_fn			pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx>, unsafety: hir::Unsafety, abi: abi::Abi,
ty_of_closure			pub fn ty_of_closure<'tcx>(
ty_of_method			pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,
ty_of_method_or_bare_fn			fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,
ty_param_span			    fn ty_param_span(&self,
type			struct type when the variant isn't a struct type:
type_bound			fn type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, span: Span, ty: Ty<'tcx>) -> VerifyBound 
type_derefs_to_local			fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
type_error_message			    pub fn type_error_message<M>(&self,
type_error_struct			    pub fn type_error_struct<M>(&self,
type_is_known_to_be_sized			    pub fn type_is_known_to_be_sized(&self,
type_must_outlive			pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,
type_of_node_must_outlive			fn type_of_node_must_outlive<'a, 'tcx>(
type_scheme_and_predicates_for_def			fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
type_scheme_of_def_id			fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
type_scheme_of_foreign_item			fn type_scheme_of_foreign_item<'a, 'tcx>(
type_scheme_of_item			fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,
uint_in_range			        fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool 
unify_receivers			    fn unify_receivers(&mut self,
unpack_actual_value			    fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where
unsafety			mod unsafety;
unsize_kind			fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,
upcast			    fn upcast(&mut self,
upvar			mod upvar;
values			enum values because there are no zero-variant enum values. There is no way to
variance			pub mod variance;
variant			enum variant, one of the fields was not provided. Erroneous code example:
variant			enum variant, one of the fields was specified more than once. Erroneous code
visit_adjustments			    fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) 
visit_arm			    fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }
visit_arm			fn visit_arm(rcx: &mut Rcx, arm: &hir::Arm) 
visit_block			    fn visit_block(&mut self, b: &'tcx hir::Block) 
visit_block			    fn visit_block(&mut self, b: &hir::Block) { visit_block(self, b); }
visit_block			fn visit_block(rcx: &mut Rcx, b: &hir::Block) 
visit_block			    fn visit_block(&mut self, b: &hir::Block) 
visit_closures			    fn visit_closures(&self) 
visit_expr			    fn visit_expr(&mut self, ex: &hir::Expr) { visit_expr(self, ex); }
visit_expr			fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) 
visit_expr			    fn visit_expr(&mut self, expr: &hir::Expr) 
visit_expr			    fn visit_expr(&mut self, e: &hir::Expr) 
visit_fn			    fn visit_fn(&mut self, _: intravisit::FnKind<'tcx>, _: &'tcx hir::FnDecl,
visit_fn			    fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,
visit_fn			    fn visit_fn(&mut self,
visit_fn_body			    fn visit_fn_body(&mut self,
visit_impl_item			    fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) 
visit_item			            fn visit_item(&mut self, i: &'v hir::Item) 
visit_item			    fn visit_item(&mut self, i: &'tcx hir::Item) 
visit_item			    fn visit_item(&mut self, i: &hir::Item) 
visit_item			    fn visit_item(&mut self, item: &Item) 
visit_item			    fn visit_item(&mut self, item: &hir::Item) 
visit_item			    fn visit_item(&mut self, item: &'v hir::Item) 
visit_item			    fn visit_item(&mut self, item: &'v hir::Item) 
visit_item			    fn visit_item(&mut self, item: &hir::Item) 
visit_item			    fn visit_item(&mut self, item: &hir::Item) 
visit_liberated_fn_sigs			    fn visit_liberated_fn_sigs(&self) 
visit_local			    fn visit_local(&mut self, local: &'tcx hir::Local) 
visit_local			    fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }
visit_local			fn visit_local(rcx: &mut Rcx, l: &hir::Local) 
visit_local			    fn visit_local(&mut self, l: &hir::Local) 
visit_method_map_entry			    fn visit_method_map_entry(&self,
visit_node_id			    fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) 
visit_old_school_wf			    fn visit_old_school_wf(&mut self,
visit_pat			    fn visit_pat(&mut self, p: &'tcx hir::Pat) 
visit_pat			    fn visit_pat(&mut self, p: &hir::Pat) 
visit_region_obligations			    fn visit_region_obligations(&mut self, node_id: ast::NodeId)
visit_stmt			    fn visit_stmt(&mut self, s: &hir::Stmt) 
visit_trait_item			    fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) 
visit_ty			    fn visit_ty(&mut self, t: &'tcx hir::Ty) 
visit_ty			    fn visit_ty(&mut self, t: &hir::Ty) 
visit_upvar_borrow_map			    fn visit_upvar_borrow_map(&self) 
walk_cast			    fn walk_cast<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,
wfcheck			mod wfcheck;
with_fcx			    fn with_fcx<F>(&mut self, id: ast::NodeId, span: Span, mut f: F) where
with_item_fcx			    fn with_item_fcx<F>(&mut self, item: &hir::Item, f: F) where
without_lifetime			    fn without_lifetime(&self) -> &str { &self.value }
write			    fn write(&self) 
write_adjustment			    pub fn write_adjustment(&self,
write_autoderef_adjustment			    pub fn write_autoderef_adjustment(&self,
write_call			fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,
write_error			    pub fn write_error(&self, node_id: ast::NodeId) 
write_nil			    pub fn write_nil(&self, node_id: ast::NodeId) 
write_overloaded_call_method_map			fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,
write_substs			    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) 
write_substs_to_tcx			fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,
write_ty			    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) 
write_ty_to_tcx			fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) 
writeback			pub mod writeback;
x			    fn x(self: Box<Foo>) {} \/\/ ok!
x			    fn x(self: Rc<Foo>) {}
x86_mm_adds_ep16			    fn x86_mm_adds_ep16(x: i16x8, y: i16x8) -> i16x8;
x86_mm_adds_epi16			    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i16x8; \/\/ ok!
x86_mm_adds_epi16			    fn x86_mm_adds_epi16(x: i16x8, y: i16x8) -> i64x8;
x86_mm_adds_epi16			    fn x86_mm_adds_epi16(x: i8x16, y: i32x4) -> i64x2;
x86_mm_movemask_pd			    fn x86_mm_movemask_pd(x: f64x2) -> i32; \/\/ ok!
x86_mm_movemask_pd			    fn x86_mm_movemask_pd(x: f64x2) -> i32;
x86_mm_movemask_pd			    fn x86_mm_movemask_pd(x: f64x2, y: f64x2, z: f64x2) -> i32;
x86_mm_movemask_pd			    fn x86_mm_movemask_pd<T>(x: f64x2) -> i32;
xform			    fn xform(&mut self,
xform			    fn xform(self, v: Self) -> Self;
xform			    fn xform(self, v: ty::Variance) -> ty::Variance 
xform_method_self_ty			    fn xform_method_self_ty(&self,
xform_self_ty			    fn xform_self_ty(&self,
