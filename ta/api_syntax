::std::fmt::Debug for AttributeGate			impl ::std::fmt::Debug for AttributeGate 
::std::hash::Hash for LazyTokenStream			impl ::std::hash::Hash for LazyTokenStream 
::std::ops::Deref for ThinVec			impl<T> ::std::ops::Deref for ThinVec<T> 
::visit::Visitor for PatIdentVisitor			        impl<'a> ::visit::Visitor<'a> for PatIdentVisitor 
Abi			impl Abi 
Abi			pub enum Abi 
AbiData			pub struct AbiData 
Add for LockstepIterSize			impl Add for LockstepIterSize 
AngleBracketedParameterData			pub struct AngleBracketedParameterData 
AnnNode			pub enum AnnNode<'a> 
Annotatable			impl Annotatable 
Annotatable			pub enum Annotatable 
Arg			impl Arg 
Arg			pub struct Arg 
Arm			pub struct Arm 
AsmDialect			pub enum AsmDialect 
AssocOp			impl AssocOp 
AssocOp			pub enum AssocOp 
AstBuilder			pub trait AstBuilder 
AstBuilder for ExtCtxt			impl<'a> AstBuilder for ExtCtxt<'a> 
AttrError			enum AttrError 
AttrId			pub struct AttrId(pub usize);
AttrProcMacro			pub trait AttrProcMacro 
AttrProcMacro for F			impl<F> AttrProcMacro for F
AttrStyle			pub enum AttrStyle 
Attribute			pub struct Attribute 
Attribute			impl Attribute 
AttributeGate			impl AttributeGate 
AttributeGate			pub enum AttributeGate 
AttributeType			pub enum AttributeType 
AvoidInterpolatedIdents			        struct AvoidInterpolatedIdents;
Bar			struct Bar<'a> 
BareFnTy			pub struct BareFnTy 
BeginToken			pub struct BeginToken 
BinOpKind			impl BinOpKind 
BinOpKind			pub enum BinOpKind 
BinOpToken			pub enum BinOpToken 
BindingMode			pub enum BindingMode 
Block			pub struct Block 
BlockCheckMode			pub enum BlockCheckMode 
BlockMode			pub enum BlockMode 
BreakToken			pub struct BreakToken 
Breaks			pub enum Breaks 
BufEntry			struct BufEntry 
CaptureBy			pub enum CaptureBy 
Clone for LazyTokenStream			impl Clone for LazyTokenStream 
Clone for P			impl<T: 'static + Clone> Clone for P<T> 
Clone for P			impl<T: Clone> Clone for P<[T]> 
CodeMap			impl CodeMap 
CodeMap			pub struct CodeMap 
CodeMapExtension			    trait CodeMapExtension 
CodeMapExtension for CodeMap			    impl CodeMapExtension for CodeMap 
CodeMapper for CodeMap			impl CodeMapper for CodeMap 
Comment			pub struct Comment 
CommentStyle			pub enum CommentStyle 
Constness			pub enum Constness 
Context			impl<'a> Context<'a> 
Context			struct Context<'a> 
Crate			pub struct Crate 
Cursor			impl Cursor 
Cursor			pub struct Cursor(CursorKind);
CursorKind			enum CursorKind 
Debug for P			impl<T: ?Sized + Debug> Debug for P<T> 
Decodable for LazyTokenStream			impl Decodable for LazyTokenStream 
Decodable for P			impl<T: 'static + Decodable> Decodable for P<T> 
Decodable for P			impl<T: Decodable> Decodable for P<[T]> 
Decodable for ThinTokenStream			impl Decodable for ThinTokenStream 
Decodable for TokenStream			impl Decodable for TokenStream 
Default for Generics			impl Default for Generics 
Default for P			impl<T> Default for P<[T]> 
Default for TokenAndSpan			impl Default for TokenAndSpan 
Defaultness			pub enum Defaultness 
DelimToken			impl DelimToken 
DelimToken			pub enum DelimToken 
Delimited			impl Delimited 
Delimited			pub struct Delimited 
Delimited			impl Delimited 
Delimited			pub struct Delimited 
Deprecation			pub struct Deprecation 
Deref for P			impl<T: ?Sized> Deref for P<T> 
Deref for RcSlice			impl<T> Deref for RcSlice<T> 
Determinacy			pub enum Determinacy 
Diagnostic			impl Diagnostic 
Diagnostic			struct Diagnostic 
DiagnosticCode			impl DiagnosticCode 
DiagnosticCode			struct DiagnosticCode 
DiagnosticSpan			impl DiagnosticSpan 
DiagnosticSpan			struct DiagnosticSpan 
DiagnosticSpanLine			impl DiagnosticSpanLine 
DiagnosticSpanLine			struct DiagnosticSpanLine 
DiagnosticSpanMacroExpansion			struct DiagnosticSpanMacroExpansion 
Directory			pub struct Directory 
DirectoryOwnership			pub enum DirectoryOwnership 
Display for P			impl<T: Display> Display for P<T> 
DummyResolver			pub struct DummyResolver;
DummyResult			impl DummyResult 
DummyResult			pub struct DummyResult 
Emitter for JsonEmitter			impl Emitter for JsonEmitter 
Encodable for LazyTokenStream			impl Encodable for LazyTokenStream 
Encodable for P			impl<T: Encodable> Encodable for P<T> 
Encodable for P			impl<T: Encodable> Encodable for P<[T]> 
Encodable for ThinTokenStream			impl Encodable for ThinTokenStream 
Encodable for TokenStream			impl Encodable for TokenStream 
EntryPointCleaner			struct EntryPointCleaner 
EntryPointType			pub enum EntryPointType 
EnumDef			pub struct EnumDef 
Eq for ThinTokenStream			impl Eq for ThinTokenStream {}
Eq for TokenStream			impl Eq for TokenStream {}
Error			impl Error 
Error			pub enum Error 
ErrorInfo			pub struct ErrorInfo 
ErrorLocation			impl ErrorLocation 
ErrorLocation			pub struct ErrorLocation 
ErrorMetadata			pub struct ErrorMetadata 
ExpandResult			    struct ExpandResult<'a> 
Expansion			        impl Expansion 
Expansion			        pub enum Expansion { OptExpr(Option<P<ast::Expr>>), 
ExpansionConfig			impl<'feat> ExpansionConfig<'feat> 
ExpansionConfig			pub struct ExpansionConfig<'feat> 
ExpansionData			pub struct ExpansionData 
ExpansionKind			        impl ExpansionKind 
ExpansionKind			        pub enum ExpansionKind { OptExpr, 
ExpansionKind			impl ExpansionKind 
Expr			pub struct Expr 
ExprKind			pub enum ExprKind 
ExtCtxt			impl<'a> ExtCtxt<'a> 
ExtCtxt			pub struct ExtCtxt<'a> 
ExtParseUtils			    pub trait ExtParseUtils 
ExtParseUtils for ExtCtxt			    impl<'a> ExtParseUtils for ExtCtxt<'a> 
Extend for ThinVec			impl<T> Extend<T> for ThinVec<T> 
Features			        impl Features 
Features			        pub struct Features 
Field			pub struct Field 
FieldPat			pub struct FieldPat 
FileLoader			pub trait FileLoader 
FileLoader for RealFileLoader			impl FileLoader for RealFileLoader 
FilePathMapping			impl FilePathMapping 
FilePathMapping			pub struct FilePathMapping 
FirstSets			impl FirstSets 
FirstSets			struct FirstSets 
Fixity			pub enum Fixity 
FloatTy			impl FloatTy 
FloatTy			pub enum FloatTy 
FnDecl			impl FnDecl 
FnDecl			pub struct FnDecl 
FnKind			pub enum FnKind<'a> 
Folder			pub trait Folder : Sized 
Folder for AvoidInterpolatedIdents			        impl Folder for AvoidInterpolatedIdents 
Folder for InvocationCollector			impl<'a, 'b> Folder for InvocationCollector<'a, 'b> 
Folder for MacroExpander			        impl<'a, 'b> Folder for MacroExpander<'a, 'b> 
Folder for Marker			impl Folder for Marker 
Folder for PlaceholderExpander			impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> 
Folder for ToZzIdentFolder			    impl Folder for ToZzIdentFolder 
Foo			struct Foo;
Foo			trait Foo {}
ForeignItem			pub struct ForeignItem 
ForeignItemKind			impl ForeignItemKind 
ForeignItemKind			pub enum ForeignItemKind 
ForeignMod			pub struct ForeignMod 
Frame			enum Frame 
Frame			impl Frame 
From			impl From<Option<ThinVec<Attribute>>> for LhsExpr 
From			impl From<P<Expr>> for LhsExpr 
From			impl<T> From<Vec<T>> for P<[T]> 
From			impl<T> From<Vec<T>> for ThinVec<T> 
From for ThinTokenStream			impl From<TokenStream> for ThinTokenStream 
From for TokenStream			impl From<ThinTokenStream> for TokenStream 
From for TokenStream			impl From<Token> for TokenStream 
From for TokenStream			impl From<TokenTree> for TokenStream 
FromIterator for P			impl<T> FromIterator<T> for P<[T]> 
FromStr for Mode			impl FromStr for Mode 
FunctionRetTy			impl FunctionRetTy 
FunctionRetTy			pub enum FunctionRetTy 
GateIssue			pub enum GateIssue 
GatedCfg			impl GatedCfg 
GatedCfg			pub struct GatedCfg 
Generics			impl Generics 
Generics			pub struct Generics 
GlobalAsm			pub struct GlobalAsm 
HasAttrs			        impl HasAttrs for 
HasAttrs			pub trait HasAttrs: Sized 
HasAttrs for Annotatable			impl HasAttrs for Annotatable 
HasAttrs for P			impl<T: HasAttrs + 'static> HasAttrs for P<T> 
HasAttrs for Spanned			impl<T: HasAttrs> HasAttrs for Spanned<T> 
HasAttrs for Stmt			impl HasAttrs for Stmt 
HasAttrs for StmtKind			impl HasAttrs for StmtKind 
HasAttrs for ThinVec			impl HasAttrs for ThinVec<Attribute> 
HasAttrs for Vec			impl HasAttrs for Vec<Attribute> 
HasTestSignature			enum HasTestSignature 
Hash for ThinTokenStream			impl Hash for ThinTokenStream 
Hash for TokenStream			impl Hash for TokenStream 
HashStable for P			impl<CTX, T> HashStable<CTX> for P<T>
HashStable for RcSlice			impl<CTX, T> HashStable<CTX> for RcSlice<T>
IdentMacroExpander			pub trait IdentMacroExpander 
IdentMacroExpander for F			impl<F> IdentMacroExpander for F
ImplItem			pub struct ImplItem 
ImplItemKind			pub enum ImplItemKind 
ImplPolarity			pub enum ImplPolarity 
InlineAsm			pub struct InlineAsm 
InlineAsmOutput			pub struct InlineAsmOutput 
InlineAttr			pub enum InlineAttr 
InnerAttributeParsePolicy			enum InnerAttributeParsePolicy<'a> 
IntTy			impl IntTy 
IntTy			pub enum IntTy 
IntType			impl IntType 
IntType			pub enum IntType 
Into			impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData 
Into			impl Into<Vec<Annotatable>> for Annotatable 
Into			impl<T> Into<Vec<T>> for P<[T]> 
Into			impl<T> Into<Vec<T>> for ThinVec<T> 
IntoIterator			impl<'a, T> IntoIterator for &'a P<[T]> 
IntoIterator for P			impl<T> IntoIterator for P<[T]> 
Invocation			impl Invocation 
Invocation			pub struct Invocation 
InvocationCollector			impl<'a, 'b> InvocationCollector<'a, 'b> 
InvocationCollector			struct InvocationCollector<'a, 'b: 'a> 
InvocationKind			pub enum InvocationKind 
Item			pub struct Item 
ItemKind			impl ItemKind 
ItemKind			pub enum ItemKind 
Iterator for Cursor			impl Iterator for Cursor 
Iterator for Frame			impl Iterator for Frame 
JsonEmitter			impl JsonEmitter 
JsonEmitter			pub struct JsonEmitter 
KleeneOp			pub enum KleeneOp 
LazyTokenStream			impl LazyTokenStream 
LazyTokenStream			pub struct LazyTokenStream(Cell<Option<TokenStream>>);
LhsExpr			pub enum LhsExpr 
Lifetime			pub struct Lifetime 
LifetimeDef			pub struct LifetimeDef 
Lit			impl Lit 
Lit			impl Lit 
Lit			pub enum Lit 
LitIntType			pub enum LitIntType 
LitKind			impl LitKind 
LitKind			pub enum LitKind 
LitKind			impl LitKind 
Literal			pub struct Literal 
Local			pub struct Local 
LockstepIterSize			enum LockstepIterSize 
MacEager			        impl MacEager 
MacEager			        pub struct MacEager 
MacResult			pub trait MacResult 
MacResult			        impl<'a> MacResult for ::ext::tt::macro_rules::ParserAnyMacro<'a> 
MacResult for DummyResult			impl MacResult for DummyResult 
MacResult for MacEager			impl MacResult for MacEager 
MacStmtStyle			pub enum MacStmtStyle 
Mac_			impl Mac_ 
Mac_			pub struct Mac_ 
MacroDef			impl MacroDef 
MacroDef			pub struct MacroDef 
MacroExpander			impl<'a, 'b> MacroExpander<'a, 'b> 
MacroExpander			pub struct MacroExpander<'a, 'b:'a> 
MacroKind			pub enum MacroKind 
MacroRulesMacroExpander			struct MacroRulesMacroExpander 
Marker			pub struct Marker(pub Mark);
MatcherPos			impl MatcherPos 
MatcherPos			struct MatcherPos 
MatcherTtFrame			struct MatcherTtFrame 
MetaItem			pub struct MetaItem 
MetaItem			impl MetaItem 
MetaItemKind			pub enum MetaItemKind 
MetaItemKind			impl MetaItemKind 
MethodSig			pub struct MethodSig 
Mod			pub struct Mod 
Mode			enum Mode 
ModuleData			pub struct ModuleData 
ModulePath			pub struct ModulePath 
ModulePathError			pub struct ModulePathError 
ModulePathSuccess			pub struct ModulePathSuccess 
MoveMap			impl<T> MoveMap<T> for ::ptr::P<[T]> 
MoveMap			pub trait MoveMap<T>: Sized 
MoveMap for SmallVector			impl<T> MoveMap<T> for SmallVector<T> 
MoveMap for Vec			impl<T> MoveMap<T> for Vec<T> 
MultiItemDecorator			pub trait MultiItemDecorator 
MultiItemDecorator for F			impl<F> MultiItemDecorator for F
MultiItemModifier			pub trait MultiItemModifier 
MultiItemModifier for F			impl<F, T> MultiItemModifier for F
MutTy			pub struct MutTy 
Mutability			pub enum Mutability 
MutexFeatureChecker			impl MutexFeatureChecker 
MutexFeatureChecker			struct MutexFeatureChecker 
NamedMatch			pub enum NamedMatch 
NestedMetaItem			impl NestedMetaItem 
NestedMetaItemKind			pub enum NestedMetaItemKind 
NestedMetaItemKind			impl NestedMetaItemKind 
NoAnn			pub struct NoAnn;
NodeCounter			impl NodeCounter 
NodeCounter			pub struct NodeCounter 
NodeId			impl NodeId 
NodeId			pub struct NodeId(u32);
Nonterminal			pub enum Nonterminal 
ObsoleteSyntax			pub enum ObsoleteSyntax 
P			impl<T: 'static> P<T> 
P			impl<T> P<[T]> 
P			pub fn P<T: 'static>(value: T) -> P<T> 
P			pub struct P<T: ?Sized> 
ParenthesizedParameterData			pub struct ParenthesizedParameterData 
ParseResult			pub enum ParseResult<T> 
ParseSess			impl ParseSess 
ParseSess			pub struct ParseSess 
Parser			impl<'a> Parser<'a> 
Parser			impl<'a> Parser<'a> 
Parser			impl<'a> Parser<'a> 
Parser			pub struct Parser<'a> 
ParserAnyMacro			impl<'a> ParserAnyMacro<'a> 
ParserAnyMacro			pub struct ParserAnyMacro<'a> 
ParserObsoleteMethods			pub trait ParserObsoleteMethods 
ParserObsoleteMethods for parser			impl<'a> ParserObsoleteMethods for parser::Parser<'a> 
PartialEq for LazyTokenStream			impl PartialEq for LazyTokenStream 
PartialEq for Path			impl<'a> PartialEq<&'a str> for Path 
PartialEq for ThinTokenStream			impl PartialEq<ThinTokenStream> for ThinTokenStream 
PartialEq for TokenStream			impl PartialEq<TokenStream> for TokenStream 
Pat			impl Pat 
Pat			pub struct Pat 
PatIdentVisitor			        struct PatIdentVisitor 
PatKind			pub enum PatKind 
Path			impl Path 
Path			pub struct Path 
PathListItem_			pub struct PathListItem_ 
PathParameters			pub enum PathParameters 
PathSegment			impl PathSegment 
PathSegment			pub struct PathSegment 
PathStyle			pub enum PathStyle 
PlaceholderExpander			impl<'a, 'b> PlaceholderExpander<'a, 'b> 
PlaceholderExpander			pub struct PlaceholderExpander<'a, 'b: 'a> 
PolyTraitRef			impl PolyTraitRef 
PolyTraitRef			pub struct PolyTraitRef 
Position			struct Position 
PostExpansionVisitor			impl<'a> PostExpansionVisitor<'a> 
PostExpansionVisitor			struct PostExpansionVisitor<'a> 
PpAnn			pub trait PpAnn 
PpAnn for NoAnn			impl PpAnn for NoAnn {}
PrevTokenKind			enum PrevTokenKind 
PrintStackBreak			pub enum PrintStackBreak 
PrintStackElem			pub struct PrintStackElem 
PrintState			pub trait PrintState<'a> 
PrintState for State			impl<'a> PrintState<'a> for State<'a> 
Printer			impl<'a> Printer<'a> 
Printer			pub struct Printer<'a> 
ProcMacro			pub trait ProcMacro 
ProcMacro for F			impl<F> ProcMacro for F
QSelf			pub struct QSelf 
RangeEnd			pub enum RangeEnd 
RangeLimits			pub enum RangeLimits 
RcSlice			impl<T> RcSlice<T> 
RcSlice			pub struct RcSlice<T> 
RealFileLoader			pub struct RealFileLoader;
ReprAttr			pub enum ReprAttr 
Resolver			pub trait Resolver 
Resolver for DummyResolver			impl Resolver for DummyResolver 
RustcDeprecation			pub struct RustcDeprecation 
SelfKind			pub enum SelfKind 
SemiColonMode			pub enum SemiColonMode 
SeqSep			impl SeqSep 
SeqSep			pub struct SeqSep 
SequenceRepetition			pub struct SequenceRepetition 
Shared			struct Shared<T: Write> 
ShouldPanic			enum ShouldPanic 
ShowSpanVisitor			struct ShowSpanVisitor<'a> 
SpanLabel			struct SpanLabel 
Spanned			pub struct Spanned<T> 
Stability			pub struct Stability 
Stability			pub enum Stability 
StabilityLevel			impl StabilityLevel 
StabilityLevel			pub enum StabilityLevel 
State			impl<'a> State<'a> 
State			pub struct State<'a> 
Stmt			impl Stmt 
Stmt			pub struct Stmt 
StmtKind			pub enum StmtKind 
StrStyle			pub enum StrStyle 
StreamCursor			impl StreamCursor 
StreamCursor			struct StreamCursor 
StringReader			impl<'a> StringReader<'a> 
StringReader			pub struct StringReader<'a> 
StringReader			impl<'a> StringReader<'a> 
StripUnconfigured			impl<'a> StripUnconfigured<'a> 
StripUnconfigured			pub struct StripUnconfigured<'a> 
StructField			pub struct StructField 
SyntaxExtension			impl SyntaxExtension 
SyntaxExtension			pub enum SyntaxExtension 
TTMacroExpander			pub trait TTMacroExpander 
TTMacroExpander for F			impl<F> TTMacroExpander for F
TTMacroExpander for MacroRulesMacroExpander			impl TTMacroExpander for MacroRulesMacroExpander 
Test			struct Test 
TestCtxt			struct TestCtxt<'a> 
TestHarnessGenerator			struct TestHarnessGenerator<'a> 
ThinTokenStream			pub struct ThinTokenStream(Option<RcSlice<TokenStream>>);
ThinVec			impl<T> ThinVec<T> 
ThinVec			pub struct ThinVec<T>(Option<Box<Vec<T>>>);
ToTokens			            impl ToTokens for 
ToTokens			            impl ToTokens for [
ToTokens			    impl ToTokens for () 
ToTokens			    pub trait ToTokens 
ToTokens for Option			    impl<T: ToTokens> ToTokens for Option<T> 
ToTokens for P			    impl ToTokens for P<ast::Block> 
ToTokens for P			    impl ToTokens for P<ast::Expr> 
ToTokens for P			    impl ToTokens for P<ast::ImplItem> 
ToTokens for P			    impl ToTokens for P<ast::Item> 
ToTokens for P			    impl ToTokens for P<ast::Pat> 
ToTokens for Spanned			    impl<T: ToTokens> ToTokens for Spanned<T> 
ToTokens for TokenTree			    impl ToTokens for TokenTree 
ToTokens for Vec			    impl<T: ToTokens> ToTokens for Vec<T> 
ToTokens for ast			    impl ToTokens for ast::Arg 
ToTokens for ast			    impl ToTokens for ast::Arm 
ToTokens for ast			    impl ToTokens for ast::Attribute 
ToTokens for ast			    impl ToTokens for ast::Block 
ToTokens for ast			    impl ToTokens for ast::Generics 
ToTokens for ast			    impl ToTokens for ast::Ident 
ToTokens for ast			    impl ToTokens for ast::ImplItem 
ToTokens for ast			    impl ToTokens for ast::Lit 
ToTokens for ast			    impl ToTokens for ast::MetaItem 
ToTokens for ast			    impl ToTokens for ast::Path 
ToTokens for ast			    impl ToTokens for ast::Stmt 
ToTokens for ast			    impl ToTokens for ast::TraitItem 
ToTokens for ast			    impl ToTokens for ast::Ty 
ToTokens for ast			    impl ToTokens for ast::WhereClause 
ToTokens for bool			    impl ToTokens for bool 
ToTokens for char			    impl ToTokens for char 
ToTokens for str			    impl ToTokens for str 
ToZzIdentFolder			    struct ToZzIdentFolder;
Token			impl Token 
Token			pub enum Token 
Token			impl Token 
Token			pub enum Token 
TokenAndSpan			pub struct TokenAndSpan 
TokenCursor			impl TokenCursor 
TokenCursor			struct TokenCursor 
TokenCursorFrame			impl TokenCursorFrame 
TokenCursorFrame			struct TokenCursorFrame 
TokenSet			impl TokenSet 
TokenSet			struct TokenSet 
TokenStream			impl TokenStream 
TokenStream			pub struct TokenStream 
TokenStreamBuilder			impl TokenStreamBuilder 
TokenStreamBuilder			pub struct TokenStreamBuilder(Vec<TokenStream>);
TokenStreamKind			enum TokenStreamKind 
TokenTree			impl TokenTree 
TokenTree			pub enum TokenTree 
TokenTree			impl TokenTree 
TokenTree			pub enum TokenTree 
TokenTreeOrTokenTreeVec			enum TokenTreeOrTokenTreeVec 
TokenTreeOrTokenTreeVec			impl TokenTreeOrTokenTreeVec 
TokenType			impl TokenType 
TokenType			pub enum TokenType 
TraitBoundModifier			pub enum TraitBoundModifier 
TraitItem			pub struct TraitItem 
TraitItemKind			pub enum TraitItemKind 
TraitRef			pub struct TraitRef 
Ty			pub struct Ty 
TyKind			pub enum TyKind 
TyParam			pub struct TyParam 
TyParamBound			pub enum TyParamBound 
TypeBinding			pub struct TypeBinding 
UintTy			impl UintTy 
UintTy			pub enum UintTy 
UnOp			impl UnOp 
UnOp			pub enum UnOp 
UnsafeSource			pub enum UnsafeSource 
Unsafety			pub enum Unsafety 
UnstableFeatures			impl UnstableFeatures 
UnstableFeatures			pub enum UnstableFeatures 
VariantData			impl VariantData 
VariantData			pub enum VariantData 
Variant_			pub struct Variant_ 
ViewPath_			impl ViewPath_ 
ViewPath_			pub enum ViewPath_ 
Visibility			pub enum Visibility 
Visitor			pub trait Visitor<'ast>: Sized 
Visitor for NodeCounter			impl<'ast> Visitor<'ast> for NodeCounter 
Visitor for PostExpansionVisitor			impl<'a> Visitor<'a> for PostExpansionVisitor<'a> 
Visitor for ShowSpanVisitor			impl<'a> Visitor<'a> for ShowSpanVisitor<'a> 
WhereBoundPredicate			pub struct WhereBoundPredicate 
WhereClause			pub struct WhereClause 
WhereEqPredicate			pub struct WhereEqPredicate 
WherePredicate			pub enum WherePredicate 
WhereRegionPredicate			pub struct WhereRegionPredicate 
Write for Shared			impl<T: Write> Write for Shared<T> 
__test			mod __test 
abi			pub mod abi;
abort_if_errors			    pub fn abort_if_errors(&self) 
abs_path			    fn abs_path(&self, path: &Path) -> Option<PathBuf> 
abs_path			    fn abs_path(&self, path: &Path) -> Option<PathBuf>;
add			    pub fn add(&mut self, id: ast::NodeId, expansion: Expansion, derives: Vec<Mark>) 
add			    fn add(self, other: LockstepIterSize) -> LockstepIterSize 
add			    pub fn add<T: Into<TokenStream>>(mut self, stream: T) -> Self 
add_all			    fn add_all(&mut self, other: &Self) 
add_builtin			    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}
add_builtin			    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);
add_derived_markers			pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path], item: T) -> T
add_one			    fn add_one(&mut self, tok: quoted::TokenTree) 
add_one_maybe			    fn add_one_maybe(&mut self, tok: quoted::TokenTree) 
add_trailing_semicolon			    pub fn add_trailing_semicolon(mut self) -> Self 
advance_left			    pub fn advance_left(&mut self) -> io::Result<()> 
advance_right			    pub fn advance_right(&mut self) 
advance_token			    fn advance_token(&mut self) -> Result<(), ()> 
all_names			pub fn all_names() -> Vec<&'static str> 
all_whitespace			fn all_whitespace(s: &str, col: CharPos) -> Option<usize> 
and_then			    pub fn and_then<U, F>(self, f: F) -> U where
any			    pub fn any(sp: Span) -> Box<MacResult+'static> 
arg			    fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg 
arg			    fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;
arg_to_string			pub fn arg_to_string(arg: &ast::Arg) -> String 
arm			    fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm 
arm			    fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm;
arm_to_string			pub fn arm_to_string(arm: &ast::Arm) -> String 
arm_unreachable			    fn arm_unreachable(&self, span: Span) -> ast::Arm 
arm_unreachable			    fn arm_unreachable(&self, span: Span) -> ast::Arm;
as_tree			    pub fn as_tree(self) -> (TokenTree, bool \/* joint? *\/) 
as_u32			    pub fn as_u32(&self) -> u32 
as_usize			    pub fn as_usize(&self) -> usize 
assert_encodable			        fn assert_encodable<T: serialize::Encodable>() {}
ast			pub mod ast;
attr			pub mod attr;
attr			pub mod attr;
attr_to_string			pub fn attr_to_string(attr: &ast::Attribute) -> String 
attribute			    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute 
attribute			    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute;
attribute_to_string			pub fn attribute_to_string(attr: &ast::Attribute) -> String 
attrs			            fn attrs(&self) -> &[Attribute] 
attrs			    fn attrs(&self) -> &[Attribute] 
attrs			    fn attrs(&self) -> &[ast::Attribute] { self.node.attrs() }
attrs			    fn attrs(&self) -> &[ast::Attribute];
attrs			    fn attrs(&self) -> &[Attribute] 
backtrace			    pub fn backtrace(&self) -> SyntaxContext 
base			    pub mod base;
base::MacResult for ExpandResult			    impl<'a> base::MacResult for ExpandResult<'a> 
basic			    pub fn basic() -> JsonEmitter 
bclose			    pub fn bclose(&mut self, span: syntax_pos::Span) -> io::Result<()> 
bclose_			    pub fn bclose_(&mut self, span: syntax_pos::Span,
bclose_maybe_open			    pub fn bclose_maybe_open(&mut self, span: syntax_pos::Span,
binop			    fn binop(&mut self, op: token::BinOpToken) -> token::Token 
binop_to_string			fn binop_to_string(op: BinOpToken) -> &'static str 
bit_width			    pub fn bit_width(&self) -> Option<usize> 
bit_width			    pub fn bit_width(&self) -> usize 
block			    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> 
block			    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;
block_expr			    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> 
block_expr			    fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;
block_to_string			pub fn block_to_string(blk: &ast::Block) -> String 
bopen			    pub fn bopen(&mut self) -> io::Result<()> 
bounds_to_string			pub fn bounds_to_string(bounds: &[ast::TyParamBound]) -> String 
boxes			    fn boxes(&mut self) -> &mut Vec<pp::Breaks> 
boxes			    fn boxes(&mut self) -> &mut Vec<pp::Breaks>;
break_offset			    pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> 
break_offset_if_not_bol			    pub fn break_offset_if_not_bol(&mut self, n: usize,
buf_str			fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String 
bug			    pub fn bug(&self, msg: &str) -> ! 
bug			    pub fn bug(&self, m: &str) -> ! 
build			    pub mod build;
build			    pub fn build(self) -> TokenStream 
build_recur			        fn build_recur(sets: &mut FirstSets, tts: &[TokenTree]) -> TokenSet 
bump			    pub fn bump(&mut self) 
bump			    pub fn bump(&mut self) 
bump_lit			    fn bump_lit(&mut self) -> Option<comments::Literal> 
bump_lit			    fn bump_lit(&mut self) -> Option<comments::Literal>;
bump_with			    pub fn bump_with(&mut self, next: token::Token, span: Span) 
byte_lit			pub fn byte_lit(lit: &str) -> (u8, usize) 
byte_offset			    fn byte_offset(&self, pos: BytePos) -> BytePos 
byte_str_lit			pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> 
bytepos_to_file_charpos			    pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos 
call_site			    pub fn call_site(&self) -> Span 
call_span_if_macro			    fn call_span_if_macro(&self, sp: Span) -> Span 
can_begin_expr			    pub fn can_begin_expr(&self) -> bool 
can_begin_type			    pub fn can_begin_type(&self) -> bool 
cancel			    fn cancel(&self, err: &mut DiagnosticBuilder) 
cbox			    pub fn cbox(&mut self, indent: usize) -> io::Result<()> 
cbox			    pub fn cbox(&mut self, u: usize) -> io::Result<()> 
cfg			    pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }
cfg_matches			pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool 
ch_is			    pub fn ch_is(&self, c: char) -> bool 
char_at			pub fn char_at(s: &str, byte: usize) -> char 
char_lit			pub fn char_lit(lit: &str) -> (char, isize) 
character_a			    fn character_a() 
character_escaped			    fn character_escaped() 
character_space			    fn character_space() 
check			    fn check(self, handler: &Handler) 
check			    pub fn check(&mut self, tok: &token::Token) -> bool 
check_abi			    fn check_abi(&self, abi: Abi, span: Span) 
check_and_emit			    pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) 
check_asts_encodable			    fn check_asts_encodable() 
check_attribute			    fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) 
check_attribute			pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) 
check_attributes			    fn check_attributes(&mut self, attrs: &[ast::Attribute]) 
check_crate			pub fn check_crate(krate: &ast::Crate,
check_expr_bin_needs_paren			    pub fn check_expr_bin_needs_paren(&mut self, sub_expr: &ast::Expr,
check_float_base			    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: usize) 
check_for_substitution			pub fn check_for_substitution<'a>(reader: &StringReader<'a>,
check_ident			    fn check_ident(&mut self) -> bool 
check_keyword			    pub fn check_keyword(&mut self, kw: keywords::Keyword) -> bool 
check_lhs_no_empty_seq			fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool 
check_lhs_nt_follows			fn check_lhs_nt_follows(sess: &ParseSess,
check_lifetime			    fn check_lifetime(&mut self) -> bool 
check_matcher			fn check_matcher(sess: &ParseSess,
check_matcher_core			fn check_matcher_core(sess: &ParseSess,
check_name			    pub fn check_name(&self, name: &str) -> bool 
check_no_chained_comparison			    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) 
check_path			    fn check_path(&mut self) -> bool 
check_rhs			fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool 
check_stack			    pub fn check_stack(&mut self, k: isize) 
check_stream			    pub fn check_stream(&mut self) -> io::Result<()> 
check_tokenization			    fn check_tokenization(mut string_reader: StringReader, expected: Vec<token::Token>) 
check_type			    fn check_type(&mut self) -> bool 
check_unused_macros			    fn check_unused_macros(&self) {}
check_unused_macros			    fn check_unused_macros(&self);
check_unused_macros			    pub fn check_unused_macros(&self) 
check_zero_tts			pub fn check_zero_tts(cx: &ExtCtxt,
classify			pub mod classify;
classify_item			    fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)
clone			    fn clone(&self) -> Self 
clone			    fn clone(&self) -> P<T> 
clone			    fn clone(&self) -> P<[T]> 
close_token			    pub fn close_token(&self) -> token::Token 
close_token			    pub fn close_token(&self) -> token::Token 
close_tt			    pub fn close_tt(&self, span: Span) -> TokenTree 
close_tt			    pub fn close_tt(&self, span: Span) -> TokenTree 
cmp::Eq for LazyTokenStream			impl cmp::Eq for LazyTokenStream {}
codemap			    pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }
codemap			pub mod codemap;
codemap			    pub fn codemap(&self) -> &CodeMap 
collect			    fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion 
collect			    fn collect(&mut self, features: &Features, span: Span) 
collect_attr			    fn collect_attr(&mut self,
collect_bang			    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: ExpansionKind) -> Expansion 
collect_derives			pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> 
collect_invocations			    fn collect_invocations(&mut self, expansion: Expansion, derives: &[Mark])
commasep			    fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()>
commasep_cmnt			    pub fn commasep_cmnt<T, F, G>(&mut self,
commasep_exprs			    pub fn commasep_exprs(&mut self, b: Breaks,
comments			pub mod comments;
comments			    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>> 
comments			    fn comments(&mut self) -> &mut Option<Vec<comments::Comment>>;
common			pub mod common;
compile			pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item) -> SyntaxExtension 
complain_if_pub_macro			    fn complain_if_pub_macro(&mut self, vis: &Visibility, sp: Span) 
complain_if_pub_macro_diag			    fn complain_if_pub_macro_diag(&mut self, vis: &Visibility, sp: Span) -> PResult<'a, ()> 
concat			    pub fn concat(mut streams: Vec<TokenStream>) -> TokenStream 
concat_rc_slice			    fn concat_rc_slice(streams: RcSlice<TokenStream>) -> TokenStream 
config			pub mod config;
configure			    pub fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> 
configure			    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> 
configure_expr			    pub fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> 
configure_expr_kind			    pub fn configure_expr_kind(&mut self, expr_kind: ast::ExprKind) -> ast::ExprKind 
configure_foreign_mod			    pub fn configure_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod 
configure_item_kind			    pub fn configure_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind 
configure_pat			    pub fn configure_pat(&mut self, pattern: P<ast::Pat>) -> P<ast::Pat> 
configure_stmt			    pub fn configure_stmt(&mut self, stmt: ast::Stmt) -> Option<ast::Stmt> 
configure_struct_expr_field			    pub fn configure_struct_expr_field(&mut self, field: ast::Field) -> Option<ast::Field> 
configure_variant_data			    fn configure_variant_data(&mut self, vdata: ast::VariantData) -> ast::VariantData 
consume_comment			fn consume_comment(rdr: &mut StringReader,
consume_non_eol_whitespace			    fn consume_non_eol_whitespace(&mut self) 
consume_whitespace			    fn consume_whitespace(&mut self) 
consume_whitespace_counting_blank_lines			fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader, comments: &mut Vec<Comment>) 
contains_extern_indicator			pub fn contains_extern_indicator(diag: &Handler, attrs: &[Attribute]) -> bool 
contains_name			pub fn contains_name(attrs: &[Attribute], name: &str) -> bool 
contains_novel_literal			fn contains_novel_literal(item: &ast::MetaItem) -> bool 
count_lines			    pub fn count_lines(&self) -> usize 
count_names			pub fn count_names(ms: &[TokenTree]) -> usize 
crate_root			    pub fn crate_root(span: Span) -> Self 
create_matches			fn create_matches(len: usize) -> Vec<Rc<Vec<NamedMatch>>> 
crlf_comments			    fn crlf_comments() 
cur_cmnt			    fn cur_cmnt(&mut self) -> &mut usize 
cur_cmnt			    fn cur_cmnt(&mut self) -> &mut usize;
cur_lit			    fn cur_lit(&mut self) -> Option<&comments::Literal> 
cur_lit			    fn cur_lit(&mut self) -> Option<&comments::Literal>;
data			    pub fn data(&self) -> &'static AbiData 
dcparsing_2			    fn dcparsing_2() 
dcparsing_3			    fn dcparsing_3() 
dcparsing_4			    fn dcparsing_4() 
decode			    fn decode<D: Decoder>(_: &mut D) -> Result<LazyTokenStream, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> 
decode			    fn decode<D: Decoder>(decoder: &mut D) -> Result<ThinTokenStream, D::Error> 
decode			    fn decode<D: Decoder>(decoder: &mut D) -> Result<TokenStream, D::Error> 
def_span			    pub fn def_span(&self, sp: Span) -> Span 
default			    fn default() ->  Generics 
default			    pub fn default(crate_name: String) -> ExpansionConfig<'static> 
default			    fn default() -> Self 
default			    fn default() -> P<[T]> 
default_decode			    fn default_decode<D: Decoder>(d: &mut D) -> Result<NodeId, D::Error> 
default_encode			    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> 
default_submod_path			    pub fn default_submod_path(id: ast::Ident, dir_path: &Path, codemap: &CodeMap) -> ModulePath 
default_to_global			    pub fn default_to_global(mut self) -> Path 
deprecated_attributes			pub fn deprecated_attributes() -> Vec<&'static (&'static str, AttributeType, AttributeGate)> 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &[T] 
deref			    fn deref(&self) -> &[T] 
derive			    pub mod derive;
descriptive_variant			    pub fn descriptive_variant(&self) -> &str 
diagnostic			    pub fn diagnostic(&self) -> &'a errors::Handler 
diagnostic_list			pub mod diagnostic_list;
diagnostics			pub mod diagnostics 
different_overlap			fn different_overlap() 
doc_comment_style			pub fn doc_comment_style(comment: &str) -> ast::AttrStyle 
doublecolonparsing			    fn doublecolonparsing() 
dummy			    fn dummy(self, span: Span) -> Expansion 
dummy_arg			fn dummy_arg(span: Span) -> Arg 
dummy_spanned			pub fn dummy_spanned<T>(t: T) -> Spanned<T> 
eat			    fn eat<'a>(it: &mut iter::Peekable<str::CharIndices<'a>>) 
eat			    fn eat<I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<I>) 
eat			    pub fn eat(&mut self, tok: &token::Token) -> bool 
eat_defaultness			    fn eat_defaultness(&mut self) -> bool 
eat_keyword			    pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool 
eat_keyword_noexpect			    pub fn eat_keyword_noexpect(&mut self, kw: keywords::Keyword) -> bool 
eat_lt			    fn eat_lt(&mut self) -> bool 
eat_macro_def			    fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)
eat_to_tokens			    pub fn eat_to_tokens(&mut self, kets: &[&token::Token]) 
eliminate_crate_var			    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }
eliminate_crate_var			    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;
emit			    fn emit(&mut self, db: &DiagnosticBuilder) 
emit_fatal_errors			    pub fn emit_fatal_errors(&mut self) 
emit_feature_err			pub fn emit_feature_err(sess: &ParseSess, feature: &str, span: Span, issue: GateIssue,
empty			    pub fn empty() -> FilePathMapping 
empty			    fn empty() -> Self { TokenSet { tokens: Vec::new(), maybe_empty: true } }
empty			    pub fn empty() -> TokenStream 
enable_allow_internal_unstable			        fn enable_allow_internal_unstable = allow_internal_unstable,
enable_asm			        fn enable_asm = asm,
enable_concat_idents			        fn enable_concat_idents = concat_idents,
enable_custom_derive			        fn enable_custom_derive = custom_derive,
enable_global_asm			        fn enable_global_asm = global_asm,
enable_log_syntax			        fn enable_log_syntax = log_syntax,
enable_quotes			        fn enable_quotes = quote,
enable_trace_macros			        fn enable_trace_macros = trace_macros,
encode			    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> 
encode			    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> 
encode			    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> 
end			    pub fn end(&mut self) -> io::Result<()> 
end			    fn end(&mut self) -> io::Result<()> 
ends_on_col0			fn ends_on_col0() 
ends_on_col2			fn ends_on_col2() 
ensure_complete_parse			    pub fn ensure_complete_parse(&mut self, macro_path: &Path, kind_name: &str, span: Span) 
ensure_filemap_source_present			    fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool 
entry			pub mod entry;
entry_point_type			pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType 
eof			    pub fn eof(&mut self) -> io::Result<()> 
eq			    fn eq(&self, string: &&'a str) -> bool 
eq			    fn eq(&self, _other: &LazyTokenStream) -> bool 
eq			    fn eq(&self, other: &ThinTokenStream) -> bool 
eq			    fn eq(&self, other: &TokenStream) -> bool 
eq_token			    pub fn eq_token(&self, t: Token) -> bool 
eq_unspanned			    pub fn eq_unspanned(&self, other: &TokenStream) -> bool 
eq_unspanned			    pub fn eq_unspanned(&self, other: &TokenTree) -> bool 
eqmodws			    fn eqmodws() 
err_span			    pub fn err_span(&self, sp: Span, m: &str) 
err_span_			    fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) 
err_span_char			    fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) 
escape_default			pub fn escape_default(s: &str) -> String 
eval_src_mod			    fn eval_src_mod(&mut self,
expand			    fn expand(&self,
expand			    fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt, span: Span, input: TokenStream)
expand			    fn expand<'cx>(&self,
expand			    fn expand(&mut self, expansion: Expansion) -> Expansion 
expand			    fn expand<'cx>(&self,
expand			    pub mod expand;
expand_attr_invoc			    fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion 
expand_bang_invoc			    fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion 
expand_build_diagnostic_array			pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,
expand_column			pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_column_gated			pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_crate			    pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate 
expand_derive_invoc			    fn expand_derive_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion 
expand_diagnostic_used			pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,
expand_file			pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_include			pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_include_bytes			pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_include_str			pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_invoc			    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion 
expand_line			pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_mod			pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_parse_call			fn expand_parse_call(cx: &ExtCtxt,
expand_quote_arg			pub fn expand_quote_arg(cx: &mut ExtCtxt,
expand_quote_arm			pub fn expand_quote_arm(cx: &mut ExtCtxt,
expand_quote_attr			pub fn expand_quote_attr(cx: &mut ExtCtxt,
expand_quote_block			pub fn expand_quote_block(cx: &mut ExtCtxt,
expand_quote_expr			pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,
expand_quote_item			pub fn expand_quote_item<'cx>(cx: &'cx mut ExtCtxt,
expand_quote_meta_item			pub fn expand_quote_meta_item(cx: &mut ExtCtxt,
expand_quote_pat			pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,
expand_quote_path			pub fn expand_quote_path(cx: &mut ExtCtxt,
expand_quote_stmt			pub fn expand_quote_stmt(cx: &mut ExtCtxt,
expand_quote_tokens			pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,
expand_quote_ty			pub fn expand_quote_ty(cx: &mut ExtCtxt,
expand_register_diagnostic			pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,
expand_stringify			pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])
expand_tts			fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[TokenTree]) -> (P<ast::Expr>, P<ast::Expr>) 
expand_wrapper			fn expand_wrapper(cx: &ExtCtxt,
expander			    pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> 
expansion_cause			    pub fn expansion_cause(&self) -> Option<Span> 
expect			    pub fn expect(&mut self, t: &token::Token) -> PResult<'a,  ()> 
expect_and			    fn expect_and(&mut self) -> PResult<'a, ()> 
expect_delimited_token_tree			    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (token::DelimToken, ThinTokenStream)> 
expect_from_annotatables			    fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion 
expect_gt			    pub fn expect_gt(&mut self) -> PResult<'a, ()> 
expect_impl_item			    pub fn expect_impl_item(self) -> ast::ImplItem 
expect_item			    pub fn expect_item(self) -> P<ast::Item> 
expect_keyword			    pub fn expect_keyword(&mut self, kw: keywords::Keyword) -> PResult<'a, ()> 
expect_lifetime			    fn expect_lifetime(&mut self) -> Lifetime 
expect_lt			    fn expect_lt(&mut self) -> PResult<'a, ()> 
expect_no_suffix			    pub fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) 
expect_one_of			    pub fn expect_one_of(&mut self,
expect_trait_item			    pub fn expect_trait_item(self) -> ast::TraitItem 
expected_item_err			    fn expected_item_err(&self, attrs: &[Attribute]) 
expr			    pub fn expr(sp: Span) -> Box<MacResult+'static> 
expr			    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> 
expr			    fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;
expr_addr_of			    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> 
expr_addr_of			    fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;
expr_binary			    fn expr_binary(&self, sp: Span, op: ast::BinOpKind,
expr_block			    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> 
expr_block			    fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr>;
expr_bool			    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> 
expr_bool			    fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;
expr_break			    fn expr_break(&self, sp: Span) -> P<ast::Expr> 
expr_break			    fn expr_break(&self, sp: Span) -> P<ast::Expr>;
expr_call			    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr> 
expr_call			    fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;
expr_call_global			    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident> ,
expr_call_global			    fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident>,
expr_call_ident			    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;
expr_call_ident			    fn expr_call_ident(&self, span: Span, id: ast::Ident,
expr_cast			    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr> 
expr_cast			    fn expr_cast(&self, sp: Span, expr: P<ast::Expr>, ty: P<ast::Ty>) -> P<ast::Expr>;
expr_deref			    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> 
expr_deref			    fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;
expr_err			    fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> 
expr_err			    fn expr_err(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;
expr_fail			    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> 
expr_fail			    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr>;
expr_field_access			    fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> 
expr_field_access			    fn expr_field_access(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;
expr_ident			    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> 
expr_ident			    fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;
expr_if			    fn expr_if(&self, span: Span, cond: P<ast::Expr>,
expr_if			    fn expr_if(&self, span: Span,
expr_is_complete			    fn expr_is_complete(&mut self, e: &Expr) -> bool 
expr_is_simple_block			pub fn expr_is_simple_block(e: &ast::Expr) -> bool 
expr_isize			    fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> 
expr_isize			    fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr>;
expr_lit			    fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr> 
expr_lit			    fn expr_lit(&self, sp: Span, lit: ast::LitKind) -> P<ast::Expr>;
expr_loop			    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> 
expr_loop			    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr>;
expr_match			    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm> ) -> P<ast::Expr>;
expr_match			    fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> 
expr_method_call			    fn expr_method_call(&self, span: Span,
expr_mk_token			fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> 
expr_mut_addr_of			    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> 
expr_mut_addr_of			    fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;
expr_none			    fn expr_none(&self, sp: Span) -> P<ast::Expr> 
expr_none			    fn expr_none(&self, sp: Span) -> P<ast::Expr>;
expr_ok			    fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> 
expr_ok			    fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;
expr_path			    fn expr_path(&self, path: ast::Path) -> P<ast::Expr> 
expr_path			    fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;
expr_qpath			    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> 
expr_qpath			    fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr>;
expr_requires_semi_to_be_stmt			pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool 
expr_self			    fn expr_self(&self, span: Span) -> P<ast::Expr> 
expr_self			    fn expr_self(&self, span: Span) -> P<ast::Expr>;
expr_some			    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> 
expr_some			    fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;
expr_str			    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> 
expr_str			    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr>;
expr_struct			    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr> 
expr_struct			    fn expr_struct(&self, span: Span, path: ast::Path, fields: Vec<ast::Field>) -> P<ast::Expr>;
expr_struct_ident			    fn expr_struct_ident(&self, span: Span, id: ast::Ident,
expr_struct_ident			    fn expr_struct_ident(&self, span: Span,
expr_to_spanned_string			pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)
expr_to_string			pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)
expr_to_string			pub fn expr_to_string(e: &ast::Expr) -> String 
expr_try			    fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> 
expr_try			    fn expr_try(&self, span: Span, head: P<ast::Expr>) -> P<ast::Expr>;
expr_tup_field_access			    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> 
expr_tup_field_access			    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>,
expr_tuple			    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> 
expr_tuple			    fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;
expr_u32			    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> 
expr_u32			    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr>;
expr_u8			    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> 
expr_u8			    fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;
expr_unary			    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> 
expr_unary			    fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;
expr_unreachable			    fn expr_unreachable(&self, span: Span) -> P<ast::Expr> 
expr_unreachable			    fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;
expr_usize			    fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> 
expr_usize			    fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr>;
expr_vec			    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> 
expr_vec			    fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;
expr_vec_ng			    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> 
expr_vec_ng			    fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;
expr_vec_slice			    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> 
expr_vec_slice			    fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;
ext			pub mod ext 
extend			    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) 
f			        fn f(features: &Features) -> bool 
f			        fn f(features: &mut Features, _: Span) 
f			        fn f(features: &mut Features, span: Span) 
fake_print_crate			    fn fake_print_crate(s: &mut pprust::State,
fatal			    fn fatal(&self, m: &str) -> FatalError 
fatal			    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> 
fatal_span			    pub fn fatal_span(&self, sp: Span, m: &str) -> FatalError 
fatal_span_			    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError 
fatal_span_char			    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> FatalError 
fatal_span_verbose			    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> FatalError 
feature_err			pub fn feature_err<'a>(sess: &'a ParseSess, feature: &str, span: Span, issue: GateIssue,
feature_gate			pub mod feature_gate;
features			pub fn features(mut krate: ast::Crate, sess: &ParseSess, should_test: bool)
field_imm			    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field 
field_imm			    fn field_imm(&self, span: Span, name: Ident, e: P<ast::Expr>) -> ast::Field;
fields			    pub fn fields(&self) -> &[StructField] 
file_exists			    fn file_exists(&self, path: &Path) -> bool 
file_exists			    fn file_exists(&self, path: &Path) -> bool;
file_exists			    pub fn file_exists(&self, path: &Path) -> bool 
file_that_doesnt_exist			mod file_that_doesnt_exist; \/\/ error: file not found for module
file_to_filemap			fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)
filemap_to_parser			pub fn filemap_to_parser(sess: & ParseSess, filemap: Rc<FileMap>, ) -> Parser 
filemap_to_stream			pub fn filemap_to_stream(sess: &ParseSess, filemap: Rc<FileMap>, override_span: Option<Span>)
files			    pub fn files(&self) -> Ref<Vec<Rc<FileMap>>> 
filtered_float_lit			fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)
find_attr_invoc			pub fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> 
find_best_match_for_name			pub fn find_best_match_for_name<'a, T>(iter_names: T,
find_crate_name			pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> 
find_deprecation			pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],
find_deprecation_generic			fn find_deprecation_generic<'a, I>(diagnostic: &Handler,
find_export_name_attr			pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symbol> 
find_inline_attr			pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr 
find_lang_feature_accepted_version			pub fn find_lang_feature_accepted_version(feature: &str) -> Option<&'static str> 
find_lang_feature_issue			fn find_lang_feature_issue(feature: &str) -> Option<u32> 
find_legacy_attr_invoc			    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }
find_legacy_attr_invoc			    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;
find_repr_attrs			pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> 
find_stability			pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],
find_stability_generic			fn find_stability_generic<'a, I>(diagnostic: &Handler,
first			    fn first(&self, tts: &[quoted::TokenTree]) -> TokenSet 
first_attr_value_str_by_name			pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> 
first_tree			    fn first_tree(&self) -> Option<TokenTree> 
fixity			    pub fn fixity(&self) -> Fixity 
float_lit			pub fn float_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)
flush			    fn flush(&mut self) -> io::Result<()> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for Expr			impl fmt::Debug for Expr 
fmt::Debug for FloatTy			impl fmt::Debug for FloatTy 
fmt::Debug for ImplPolarity			impl fmt::Debug for ImplPolarity 
fmt::Debug for IntTy			impl fmt::Debug for IntTy 
fmt::Debug for LazyTokenStream			impl fmt::Debug for LazyTokenStream 
fmt::Debug for Lifetime			impl fmt::Debug for Lifetime 
fmt::Debug for Nonterminal			impl fmt::Debug for Nonterminal 
fmt::Debug for Pat			impl fmt::Debug for Pat 
fmt::Debug for Path			impl fmt::Debug for Path 
fmt::Debug for RcSlice			impl<T: fmt::Debug> fmt::Debug for RcSlice<T> 
fmt::Debug for Stmt			impl fmt::Debug for Stmt 
fmt::Debug for Ty			impl fmt::Debug for Ty 
fmt::Debug for UintTy			impl fmt::Debug for UintTy 
fmt::Display for Abi			impl fmt::Display for Abi 
fmt::Display for FloatTy			impl fmt::Display for FloatTy 
fmt::Display for IntTy			impl fmt::Display for IntTy 
fmt::Display for NodeId			impl fmt::Display for NodeId 
fmt::Display for Path			impl fmt::Display for Path 
fmt::Display for Token			impl fmt::Display for Token 
fmt::Display for TokenStream			impl fmt::Display for TokenStream 
fmt::Display for UintTy			impl fmt::Display for UintTy 
fmt::Display for Unsafety			impl fmt::Display for Unsafety 
fmt::Pointer for P			impl<T> fmt::Pointer for P<T> 
fn_block_to_string			pub fn fn_block_to_string(p: &ast::FnDecl) -> String 
fn_decl			    fn fn_decl(&self, inputs: Vec<ast::Arg> , output: P<ast::Ty>) -> P<ast::FnDecl>;
fn_decl			    fn fn_decl(&self, inputs: Vec<ast::Arg>, output: P<ast::Ty>) -> P<ast::FnDecl> 
fold			pub mod fold;
fold::Folder for EntryPointCleaner			impl fold::Folder for EntryPointCleaner 
fold::Folder for StripUnconfigured			impl<'a> fold::Folder for StripUnconfigured<'a> 
fold::Folder for TestHarnessGenerator			impl<'a> fold::Folder for TestHarnessGenerator<'a> 
fold_angle_bracketed_parameter_data			    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)
fold_arg			    fn fold_arg(&mut self, a: Arg) -> Arg 
fold_arm			    fn fold_arm(&mut self, a: Arm) -> Arm 
fold_attribute			    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> 
fold_attrs			pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> 
fold_block			    fn fold_block(&mut self, block: P<Block>) -> P<Block> 
fold_block			    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> 
fold_block			    fn fold_block(&mut self, b: P<Block>) -> P<Block> 
fold_bounds			    fn fold_bounds(&mut self, b: TyParamBounds)
fold_crate			    fn fold_crate(&mut self, c: Crate) -> Crate 
fold_crate			    fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate 
fold_expr			    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> 
fold_expr			    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> 
fold_expr			    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> 
fold_expr			    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> 
fold_exprs			    fn fold_exprs(&mut self, es: Vec<P<Expr>>) -> Vec<P<Expr>> 
fold_field			    fn fold_field(&mut self, field: Field) -> Field 
fold_fn_decl			    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> 
fold_foreign_item			    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem 
fold_foreign_mod			    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod 
fold_foreign_mod			    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod 
fold_foreign_mod			    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod 
fold_generics			    fn fold_generics(&mut self, generics: Generics) -> Generics 
fold_global_asm			    fn fold_global_asm(&mut self, ga: P<GlobalAsm>) -> P<GlobalAsm> 
fold_ident			    fn fold_ident(&mut self, mut ident: Ident) -> Ident 
fold_ident			        fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident 
fold_ident			    fn fold_ident(&mut self, i: Ident) -> Ident 
fold_impl_item			    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> 
fold_impl_item			    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> 
fold_impl_item			    fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVector<ast::ImplItem> 
fold_impl_item			    fn fold_impl_item(&mut self, i: ImplItem) -> SmallVector<ImplItem> 
fold_interpolated			    fn fold_interpolated(&mut self, nt: token::Nonterminal) -> token::Nonterminal 
fold_item			    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> 
fold_item			    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> 
fold_item			    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> 
fold_item			    fn fold_item(&mut self, i: P<Item>) -> SmallVector<P<Item>> 
fold_item			    fn fold_item(&mut self, i: P<ast::Item>) -> SmallVector<P<ast::Item>> 
fold_item_kind			    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind 
fold_item_kind			    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind 
fold_item_kind			    fn fold_item_kind(&mut self, i: ItemKind) -> ItemKind 
fold_item_simple			    fn fold_item_simple(&mut self, i: Item) -> Item 
fold_lifetime			    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime 
fold_lifetime_def			    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef 
fold_lifetime_defs			    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> 
fold_lifetimes			    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> 
fold_local			    fn fold_local(&mut self, l: P<Local>) -> P<Local> 
fold_mac			    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac 
fold_mac			            fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac 
fold_mac			    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac 
fold_mac			    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac 
fold_mac			        fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac 
fold_mac			    fn fold_mac(&mut self, _mac: Mac) -> Mac 
fold_mac			    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }
fold_macro_def			    fn fold_macro_def(&mut self, def: MacroDef) -> MacroDef 
fold_meta_item			    fn fold_meta_item(&mut self, meta_item: MetaItem) -> MetaItem 
fold_meta_items			    fn fold_meta_items(&mut self, meta_items: Vec<MetaItem>) -> Vec<MetaItem> 
fold_meta_list_item			    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem 
fold_mod			    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod 
fold_mod			    fn fold_mod(&mut self, m: Mod) -> Mod 
fold_mt			    fn fold_mt(&mut self, mt: MutTy) -> MutTy 
fold_opt_bounds			    fn fold_opt_bounds(&mut self, b: Option<TyParamBounds>)
fold_opt_expr			    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> 
fold_opt_expr			            fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> 
fold_opt_expr			    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> 
fold_opt_expr			    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> 
fold_opt_expr			    fn fold_opt_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> 
fold_opt_lifetime			    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> 
fold_parenthesized_parameter_data			    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)
fold_pat			    fn fold_pat(&mut self, pattern: P<ast::Pat>) -> P<ast::Pat> 
fold_pat			    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> 
fold_pat			    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> 
fold_pat			    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> 
fold_path			    fn fold_path(&mut self, p: Path) -> Path 
fold_path_parameters			    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters 
fold_poly_trait_ref			    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef 
fold_range_end			    fn fold_range_end(&mut self, re: RangeEnd) -> RangeEnd 
fold_stmt			    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> 
fold_stmt			    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> 
fold_stmt			    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> 
fold_stmt			    fn fold_stmt(&mut self, s: Stmt) -> SmallVector<Stmt> 
fold_struct_field			    fn fold_struct_field(&mut self, sf: StructField) -> StructField 
fold_thin_attrs			pub fn fold_thin_attrs<T: Folder>(attrs: ThinVec<Attribute>, fld: &mut T) -> ThinVec<Attribute> 
fold_token			    fn fold_token(&mut self, t: token::Token) -> token::Token 
fold_trait_item			    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> 
fold_trait_item			    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> 
fold_trait_item			    fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> 
fold_trait_item			    fn fold_trait_item(&mut self, i: TraitItem) -> SmallVector<TraitItem> 
fold_trait_ref			    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef 
fold_tt			            fn fold_tt(&mut self, tt: tokenstream::TokenTree) -> tokenstream::TokenTree 
fold_tt			    fn fold_tt(&mut self, tt: TokenTree) -> TokenTree 
fold_tts			    fn fold_tts(&mut self, tts: TokenStream) -> TokenStream 
fold_ty			    fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> 
fold_ty			    fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> 
fold_ty			    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> 
fold_ty_binding			    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding 
fold_ty_param			    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam 
fold_ty_param_bound			    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound 
fold_ty_params			    fn fold_ty_params(&mut self, tps: Vec<TyParam>) -> Vec<TyParam> 
fold_usize			    fn fold_usize(&mut self, i: usize) -> usize 
fold_variant			    fn fold_variant(&mut self, v: Variant) -> Variant 
fold_variant_data			    fn fold_variant_data(&mut self, vdata: VariantData) -> VariantData 
fold_view_path			    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> 
fold_vis			    fn fold_vis(&mut self, vis: Visibility) -> Visibility 
fold_where_clause			    fn fold_where_clause(&mut self, where_clause: WhereClause)
fold_where_predicate			    fn fold_where_predicate(&mut self, where_predicate: WherePredicate)
fold_with			            pub fn fold_with<F: Folder>(self, folder: &mut F) -> Self 
foo			fn foo() {}
foo			fn foo() 
force			    pub fn force<F: FnOnce() -> TokenStream>(&self, f: F) -> TokenStream 
frag_can_be_followed_by_any			fn frag_can_be_followed_by_any(frag: &str) -> bool 
from			    fn from(expr: P<Expr>) -> Self 
from			    fn from(o: Option<ThinVec<Attribute>>) -> Self 
from			    fn from(v: Vec<T>) -> Self 
from			    fn from(stream: ThinTokenStream) -> TokenStream 
from			    fn from(stream: TokenStream) -> ThinTokenStream 
from			    fn from(token: Token) -> TokenStream 
from			    fn from(tt: TokenTree) -> TokenStream 
from			    fn from(vec: Vec<T>) -> Self 
from_ast_binop			    pub fn from_ast_binop(op: BinOpKind) -> Self 
from_diagnostic_builder			    fn from_diagnostic_builder(db: &DiagnosticBuilder,
from_environment			    pub fn from_environment() -> UnstableFeatures 
from_ident			    pub fn from_ident(ident: Ident, span: Span) -> Self 
from_ident			    pub fn from_ident(s: Span, identifier: Ident) -> Path 
from_iter			    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> P<[T]> 
from_iter			    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self 
from_multispan			    fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> 
from_render_span		p: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> 
from_self			    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg 
from_span			    pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation 
from_span			    fn from_span(span: Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> 
from_span_etc			    fn from_span_etc(span: Span,
from_span_full			    fn from_span_full(span: Span,
from_span_label			    fn from_span_label(span: SpanLabel,
from_str			    fn from_str(s: &str) -> Result<Mode, ()> 
from_sub_diagnostic			    fn from_sub_diagnostic(db: &SubDiagnostic, je: &JsonEmitter) -> Diagnostic 
from_suggestion			    fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)
from_token			    fn from_token(token: Token) -> Option<LitKind> 
from_token			    pub fn from_token(t: &Token) -> Option<AssocOp> 
from_tokens			    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>
from_tokens			    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItemKind>
from_tokens			    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItemKind>
from_u32			    pub fn from_u32(x: u32) -> NodeId 
from_vec			    pub fn from_vec(v: Vec<T>) -> P<[T]> 
fun_to_string			pub fn fun_to_string(decl: &ast::FnDecl,
gate			    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> 
gather_comments_and_literals			pub fn gather_comments_and_literals(sess: &ParseSess, path: String, srdr: &mut Read)
generate_test_harness			fn generate_test_harness(sess: &ParseSess,
generic			    pub fn generic(&self) -> bool 
generic_extension			fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,
generics_to_string			pub fn generics_to_string(generics: &ast::Generics) -> String 
get_exprs_from_tts			pub fn get_exprs_from_tts(cx: &mut ExtCtxt,
get_features			pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> Features 
get_filemap			    pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> 
get_label			    fn get_label(&mut self) -> ast::Ident 
get_metadata_dir			pub fn get_metadata_dir(prefix: &str) -> PathBuf 
get_metadata_path			fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf 
get_module_scope			    fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }
get_module_scope			    fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;
get_self			    pub fn get_self(&self) -> Option<ExplicitSelf> 
get_single_str_from_tts			pub fn get_single_str_from_tts(cx: &mut ExtCtxt,
get_spans_of_pat_idents			    fn get_spans_of_pat_idents(src: &str) -> Vec<Span> 
get_top			    pub fn get_top(&mut self) -> PrintStackElem 
get_tt			    fn get_tt(&self, index: usize) -> TokenTree 
get_tt			    pub fn get_tt(&self, index: usize) -> TokenTree 
glue			    pub fn glue(self, joint: Token) -> Option<Token> 
handle_errors			fn handle_errors(diag: &Handler, span: Span, error: AttrError) 
hardbreak			    pub fn hardbreak(&mut self) -> io::Result<()> 
hardbreak_if_not_bol			    fn hardbreak_if_not_bol(&mut self) -> io::Result<()> 
hardbreak_tok			    pub fn hardbreak_tok() -> Token 
hardbreak_tok_offset			    pub fn hardbreak_tok_offset(off: isize) -> Token 
has_legal_fragment_specifier			fn has_legal_fragment_specifier(sess: &ParseSess,
has_self			    pub fn has_self(&self) -> bool 
has_test_signature			    fn has_test_signature(i: &ast::Item) -> HasTestSignature 
has_test_signature			    fn has_test_signature(i: &ast::Item) -> bool 
hash			    fn hash<H: ::std::hash::Hasher>(&self, _hasher: &mut H) {}
hash			    fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash_stable			    fn hash_stable<W: StableHasherResult>(&self,
hash_stable			    fn hash_stable<W: StableHasherResult>(&self,
head			    pub fn head(&mut self, w: &str) -> io::Result<()> 
horizontal_trim			    fn horizontal_trim(lines: Vec<String>) -> Vec<String> 
huge_word			    pub fn huge_word(&mut self, wrd: &str) -> io::Result<()> 
ibox			    pub fn ibox(&mut self, indent: usize) -> io::Result<()> 
ibox			    fn ibox(&mut self, u: usize) -> io::Result<()> 
id			    pub fn id(&self) -> NodeId 
id_ext			fn id_ext(s: &str) -> ast::Ident 
ident			    pub fn ident(&self) -> Option<ast::Ident> 
ident_can_begin_expr			fn ident_can_begin_expr(ident: ast::Ident) -> bool 
ident_can_begin_type			fn ident_can_begin_type(ident: ast::Ident) -> bool 
ident_continue			fn ident_continue(c: Option<char>) -> bool 
ident_of			    pub fn ident_of(&self, st: &str) -> ast::Ident 
ident_start			fn ident_start(c: Option<char>) -> bool 
ident_to_string			pub fn ident_to_string(id: ast::Ident) -> String 
ids_ext			fn ids_ext(strs: Vec<String>) -> Vec<ast::Ident> 
ignored_span			fn ignored_span(sp: Span) -> Span 
ignored_span			fn ignored_span(cx: &TestCtxt, sp: Span) -> Span 
impl_item_to_string			pub fn impl_item_to_string(i: &ast::ImplItem) -> String 
in_cbox			    pub fn in_cbox(&self) -> bool 
in_cfg			    pub fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool 
in_range			fn in_range(c: Option<char>, lo: char, hi: char) -> bool 
indent			    pub fn indent(&mut self, amount: isize) 
index			    pub fn index(&self) -> usize 
index			    fn index(self) -> usize 
indexed_vec::Idx for NodeId			impl indexed_vec::Idx for NodeId 
indices_are_correct			fn indices_are_correct() 
init_code_map			    fn init_code_map() -> CodeMap 
init_code_map_mbc			    fn init_code_map_mbc() -> CodeMap 
initial_matcher_pos			fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> 
injected_crate_name			pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> 
inner_parse_loop			fn inner_parse_loop(sess: &ParseSess,
insert			    fn insert(&mut self, stream: RcSlice<TokenStream>) 
insert			    pub fn insert(&mut self, stream: TokenStream) 
int_type_of_word			fn int_type_of_word(s: &str) -> Option<IntType> 
integer_lit			pub fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler)>)
interpolated			    pub fn interpolated(nt: Nonterminal) -> Token 
interpolated_or_expr_span			    fn interpolated_or_expr_span(&self,
into			    fn into(self) -> Option<P<PathParameters>> 
into			    fn into(self) -> Vec<Annotatable> 
into			    fn into(self) -> Vec<T> 
into			    fn into(self) -> Vec<T> 
into_iter			    fn into_iter(self) -> Self::IntoIter 
into_trees			    pub fn into_trees(self) -> Cursor 
into_vec			    pub fn into_vec(self) -> Vec<T> 
is_allowed_fail			fn is_allowed_fail(i: &ast::Item) -> bool 
is_assign_like			    pub fn is_assign_like(&self) -> bool 
is_at_start_of_range_notation_rhs			    fn is_at_start_of_range_notation_rhs(&self) -> bool 
is_begin			    fn is_begin(&mut self) -> bool 
is_bench_fn			fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool 
is_block_doc_comment			pub fn is_block_doc_comment(s: &str) -> bool 
is_bol			    fn is_bol(&mut self) -> bool 
is_builtin_attr			pub fn is_builtin_attr(attr: &ast::Attribute) -> bool 
is_by_value			    pub fn is_by_value(&self) -> bool 
is_by_value			    pub fn is_by_value(u: UnOp) -> bool 
is_catch_expr			    fn is_catch_expr(&mut self) -> bool 
is_cfg			fn is_cfg(attr: &ast::Attribute) -> bool 
is_comparison			    pub fn is_comparison(&self) -> bool 
is_comparison			    pub fn is_comparison(&self) -> bool 
is_const_item			    pub fn is_const_item(&mut self) -> bool 
is_dec_digit			fn is_dec_digit(c: Option<char>) -> bool 
is_defaultness			    fn is_defaultness(&self) -> bool 
is_deprecated			    fn is_deprecated(&self) -> bool 
is_doc_comment			pub fn is_doc_comment(s: &str) -> bool 
is_doc_comment			pub fn is_doc_comment(s: &str) -> bool 
is_doc_comment			    pub fn is_doc_comment(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_end			    fn is_end(&mut self) -> bool 
is_eof			    fn is_eof(&self) -> bool 
is_eof			    pub fn is_eof(&self) -> bool 
is_global			    pub fn is_global(&self) -> bool 
is_hardbreak_tok			    pub fn is_hardbreak_tok(&self) -> bool 
is_ident			    pub fn is_ident(&self) -> bool 
is_ident_or_underscore			fn is_ident_or_underscore(t: &token::Token) -> bool 
is_ignored			fn is_ignored(i: &ast::Item) -> bool 
is_import_coupler			    fn is_import_coupler(&mut self) -> bool 
is_in_follow			fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'static str)> 
is_interpolated			    pub fn is_interpolated(&self) -> bool 
is_keyword			    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool 
is_known			pub fn is_known(attr: &Attribute) -> bool 
is_legal_fragment_specifier			fn is_legal_fragment_specifier(sess: &ParseSess,
is_lifetime			    pub fn is_lifetime(&self) -> bool 
is_like_gt			    pub fn is_like_gt(&self) -> bool 
is_lit			    pub fn is_lit(&self) -> bool 
is_literal			    pub fn is_literal(&self) -> bool 
is_lt_parameterized			    pub fn is_lt_parameterized(&self) -> bool 
is_meta_item			    pub fn is_meta_item(&self) -> bool 
is_meta_item_list			    pub fn is_meta_item_list(&self) -> bool 
is_modern			    pub fn is_modern(&self) -> bool 
is_mutability			    pub fn is_mutability(&self) -> bool 
is_named_argument			    pub fn is_named_argument(&mut self) -> bool 
is_nightly_build			    pub fn is_nightly_build(&self) -> bool 
is_op			pub fn is_op(tok: &Token) -> bool 
is_parameterized			    pub fn is_parameterized(&self) -> bool 
is_path			    pub fn is_path(&self) -> bool 
is_path_segment_keyword			    pub fn is_path_segment_keyword(&self) -> bool 
is_path_start			    pub fn is_path_start(&self) -> bool 
is_pattern_whitespace			pub fn is_pattern_whitespace(c: Option<char>) -> bool 
is_pattern_whitespace			pub fn is_pattern_whitespace(c: char) -> bool 
is_qpath_start			    pub fn is_qpath_start(&self) -> bool 
is_reserved_ident			    pub fn is_reserved_ident(&self) -> bool 
is_self			    pub fn is_self(&self) -> bool 
is_shift			    pub fn is_shift(&self) -> bool 
is_signed			    pub fn is_signed(self) -> bool 
is_special_ident			    pub fn is_special_ident(&self) -> bool 
is_stable			    pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}
is_str			    pub fn is_str(&self) -> bool 
is_struct			    pub fn is_struct(&self) -> bool 
is_suffixed			    pub fn is_suffixed(&self) -> bool 
is_test_crate			fn is_test_crate(krate: &ast::Crate) -> bool 
is_test_fn			fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool 
is_test_or_bench			pub fn is_test_or_bench(attr: &ast::Attribute) -> bool 
is_tuple			    pub fn is_tuple(&self) -> bool 
is_type_parameterized			    pub fn is_type_parameterized(&self) -> bool 
is_union_item			    fn is_union_item(&self) -> bool 
is_unit			    pub fn is_unit(&self) -> bool 
is_unstable			    pub fn is_unstable(&self) -> bool { if let Unstable {..} = *self { true } else { false }}
is_unsuffixed			    pub fn is_unsuffixed(&self) -> bool 
is_unused_keyword			    pub fn is_unused_keyword(&self) -> bool 
is_used			pub fn is_used(attr: &Attribute) -> bool 
is_used_keyword			    pub fn is_used_keyword(&self) -> bool 
is_value_str			    pub fn is_value_str(&self) -> bool 
is_whitelisted_legacy_custom_derive			    fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }
is_whitelisted_legacy_custom_derive			    fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;
is_word			    pub fn is_word(&self) -> bool 
item			    fn item(&self, span: Span, name: Ident,
item			    fn item(&self, span: Span,
item_const			    fn item_const(&self,
item_enum			    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> P<ast::Item>;
item_enum			    fn item_enum(&self, span: Span, name: Ident,
item_enum_poly			    fn item_enum_poly(&self, span: Span, name: Ident,
item_enum_poly			    fn item_enum_poly(&self,
item_extern_crate			    fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> 
item_extern_crate			    fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item>;
item_fn			    fn item_fn(&self,
item_fn_poly			    fn item_fn_poly(&self,
item_mod			    fn item_mod(&self, span: Span, inner_span: Span, name: Ident,
item_mod			    fn item_mod(&self, span: Span, inner_span: Span,
item_static			    fn item_static(&self,
item_struct			    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::VariantData) -> P<ast::Item>;
item_struct			    fn item_struct(&self, span: Span, name: Ident,
item_struct_poly			    fn item_struct_poly(&self, span: Span, name: Ident,
item_struct_poly			    fn item_struct_poly(&self,
item_to_string			pub fn item_to_string(i: &ast::Item) -> String 
item_ty			    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> 
item_ty			    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item>;
item_ty_poly			    fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,
item_ty_poly			    fn item_ty_poly(&self,
item_use			    fn item_use(&self, sp: Span,
item_use_glob			    fn item_use_glob(&self, sp: Span,
item_use_list			    fn item_use_list(&self, sp: Span, vis: ast::Visibility,
item_use_simple			    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> 
item_use_simple			    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;
item_use_simple_			    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,
joint			    pub fn joint(self) -> TokenStream 
json			pub mod json;
kind			    pub fn kind(&self) -> MacroKind 
kleene_op			    fn kleene_op(token: &token::Token) -> Option<KleeneOp> 
lambda			    fn lambda(&self, span: Span, ids: Vec<ast::Ident>, body: P<ast::Expr>) -> P<ast::Expr>;
lambda			    fn lambda(&self,
lambda0			    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr> 
lambda0			    fn lambda0(&self, span: Span, body: P<ast::Expr>) -> P<ast::Expr>;
lambda1			    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> 
lambda1			    fn lambda1(&self, span: Span, body: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;
lambda_fn_decl			    fn lambda_fn_decl(&self,
lambda_stmts			    fn lambda_stmts(&self, span: Span, ids: Vec<ast::Ident>,
lambda_stmts			    fn lambda_stmts(&self,
lambda_stmts_0			    fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> 
lambda_stmts_0			    fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr>;
lambda_stmts_1			    fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,
last_span			    fn last_span(&self) -> Option<Span> 
last_token			    pub fn last_token(&mut self) -> Token 
last_tree_if_joint			    fn last_tree_if_joint(&self) -> Option<TokenTree> 
lazy			    pub fn lazy(&self) -> bool 
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> usize 
len			    pub fn len(self) -> usize 
lev_distance			    pub mod lev_distance;
lev_distance			pub fn lev_distance(a: &str, b: &str) -> usize 
lexer			pub mod lexer;
lifetime			    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime 
lifetime			    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;
lifetime_def			    fn lifetime_def(&self,
lifetime_name			    fn lifetime_name() 
lifetime_to_string			pub fn lifetime_to_string(e: &ast::Lifetime) -> String 
line_doc_comments			    fn line_doc_comments() 
line_from_filemap			    fn line_from_filemap(fm: &syntax_pos::FileMap,
list_contains_name			pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool 
lit_to_string			pub fn lit_to_string(l: &ast::Lit) -> String 
lit_token			pub fn lit_token(lit: token::Lit, suf: Option<Symbol>, diag: Option<(Span, &Handler)>)
literal			    pub fn literal(&self) -> Option<&Lit> 
literal_suffixes			    fn literal_suffixes() 
load_file			    pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> 
lockstep_iter_size			fn lockstep_iter_size(tree: &quoted::TokenTree,
long_snippet			fn long_snippet() 
long_snippet_multiple_spans			fn long_snippet_multiple_spans() 
look_ahead			    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where
look_ahead			        fn look_ahead(streams: &[TokenStream], mut n: usize) -> Result<TokenTree, usize> 
look_ahead			    pub fn look_ahead(&self, n: usize) -> Option<TokenTree> 
look_ahead_span			    fn look_ahead_span(&self, dist: usize) -> Span 
looks_like_width_suffix			fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool 
lookup			pub fn lookup(name: &str) -> Option<Abi> 
lookup_Rust			fn lookup_Rust() 
lookup_baz			fn lookup_baz() 
lookup_byte_offset			    pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos 
lookup_cdecl			fn lookup_cdecl() 
lookup_char_pos			    fn lookup_char_pos(&self, pos: BytePos) -> Loc 
lookup_char_pos			    pub fn lookup_char_pos(&self, pos: BytePos) -> Loc 
lookup_char_pos_adj			    pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt 
lookup_cur_matched			fn lookup_cur_matched(ident: Ident,
lookup_filemap_idx			    pub fn lookup_filemap_idx(&self, pos: BytePos) -> usize 
lookup_line			    fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Rc<FileMap>> 
mac_placeholder			    fn mac_placeholder() -> ast::Mac 
mac_to_string			pub fn mac_to_string(arg: &ast::Mac) -> String 
macro_parser			        pub mod macro_parser;
macro_rules			        pub mod macro_rules;
macros			    pub mod macros;
main			fn main() 
main			fn main() {}
main			pub fn main() {}
main			  fn main() 
make			    pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion 
make_expr			    fn make_expr(self: Box<DummyResult>) -> Option<P<ast::Expr>> 
make_expr			    fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> 
make_expr			        fn make_expr(mut self: Box<ExpandResult<'a>>) -> Option<P<ast::Expr>> 
make_from			            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<Expansion> 
make_impl_items			    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVector<ast::ImplItem>> 
make_impl_items			    fn make_impl_items(self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> 
make_items			    fn make_items(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Item>>> 
make_items			    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> 
make_items			        fn make_items(mut self: Box<ExpandResult<'a>>)
make_opt_expr			            pub fn make_opt_expr(self) -> Option<P<ast::Expr>> 
make_pat			    fn make_pat(self: Box<DummyResult>) -> Option<P<ast::Pat>> 
make_pat			    fn make_pat(self: Box<Self>) -> Option<P<ast::Pat>> 
make_pos			fn make_pos(file_text: &str, pos: &Position) -> usize 
make_span			fn make_span(file_text: &str, start: &Position, end: &Position) -> Span 
make_stmts			    fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> 
make_stmts			    fn make_stmts(self: Box<Self>) -> Option<SmallVector<ast::Stmt>> 
make_trait_items			    fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVector<ast::TraitItem>> 
make_trait_items			    fn make_trait_items(self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> 
make_ty			    fn make_ty(self: Box<DummyResult>) -> Option<P<ast::Ty>> 
make_ty			    fn make_ty(self: Box<Self>) -> Option<P<ast::Ty>> 
map			    pub fn map<F>(mut self, f: F) -> P<T> where
map			    pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream 
map_attrs			            fn map_attrs<F>(mut self, f: F) -> Self
map_attrs			    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self 
map_attrs			    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self 
map_attrs			    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;
map_attrs			    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self 
map_item_or			    pub fn map_item_or<F, G>(self, mut f: F, mut or: G) -> Annotatable
map_opt_string			    fn map_opt_string(s: Option<String>, je: &JsonEmitter) -> Option<DiagnosticCode> 
map_prefix			    pub fn map_prefix(&self, path: String) -> (String, bool) 
mark_known			pub fn mark_known(attr: &Attribute) 
mark_used			pub fn mark_used(attr: &Attribute) 
matches_codepattern			pub fn matches_codepattern(a : &str, b : &str) -> bool 
may_be_ident			    fn may_be_ident(nt: &token::Nonterminal) -> bool 
may_begin_with			fn may_begin_with(name: &str, token: &Token) -> bool 
maybe_append			fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)
maybe_inject_crates_ref			pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<String>) -> ast::Crate 
maybe_parse_fixed_length_of_vec			    pub fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> 
maybe_print_comment			    fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> 
maybe_print_trailing_comment			    pub fn maybe_print_trailing_comment(&mut self, span: syntax_pos::Span,
maybe_recover_from_bad_type_plus			    fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> 
maybe_stage_features			fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,
merge_spans			    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> 
merge_spans			    pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> 
meta			    pub fn meta(&self) -> Option<MetaItem> 
meta_item			    pub fn meta_item(&self) -> Option<&MetaItem> 
meta_item_list			    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> 
meta_item_list			    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> 
meta_item_to_string			pub fn meta_item_to_string(mi: &ast::MetaItem) -> String 
meta_list			    fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)
meta_list			    fn meta_list(&self,
meta_list_item_to_string			pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String 
meta_list_item_word			    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem 
meta_list_item_word			    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem;
meta_name_value			    fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)
meta_name_value			    fn meta_name_value(&self,
meta_word			    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem 
meta_word			    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem;
metadata			    pub mod metadata;
minimum_depth			fn minimum_depth() 
missing_assoc_item_kind_err			    fn missing_assoc_item_kind_err(&mut self, item_type: &str, prev_span: Span)
mk_assign_op			    pub fn mk_assign_op(&mut self, binop: ast::BinOp,
mk_attr_id			pub fn mk_attr_id() -> AttrId 
mk_attr_inner			pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute 
mk_attr_outer			pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute 
mk_binary			    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind 
mk_binop			fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOpToken) -> P<ast::Expr> 
mk_call			    pub fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::ExprKind 
mk_delim			fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> 
mk_expr			    pub fn mk_expr(&mut self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> 
mk_field			    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind 
mk_ident			fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> 
mk_ident			    fn mk_ident(id: &str) -> token::Token 
mk_index			    pub fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::ExprKind 
mk_item			    fn mk_item(&mut self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,
mk_list_item			pub fn mk_list_item(name: Name, items: Vec<NestedMetaItem>) -> MetaItem 
mk_list_word_item			pub fn mk_list_word_item(name: Name) -> ast::NestedMetaItem 
mk_lit_u32			    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> 
mk_mac_expr			    pub fn mk_mac_expr(&mut self, span: Span, m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> 
mk_main			fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> 
mk_name			fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> 
mk_name_value_item			pub fn mk_name_value_item(name: Name, value: ast::Lit) -> MetaItem 
mk_name_value_item_str			pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem 
mk_parser_path			fn mk_parser_path(cx: &ExtCtxt, sp: Span, names: &[&str]) -> P<ast::Expr> 
mk_printer			pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> 
mk_range			    pub fn mk_range(&mut self,
mk_reexport_mod			fn mk_reexport_mod(cx: &mut TestCtxt,
mk_sess			    fn mk_sess(cm: Rc<CodeMap>) -> ParseSess 
mk_sp			    fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span 
mk_spanned_attr_inner			pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute 
mk_spanned_attr_outer			pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute 
mk_spanned_list_item			pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> MetaItem 
mk_spanned_name_value_item			pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> MetaItem 
mk_spanned_word_item			pub fn mk_spanned_word_item(sp: Span, name: Name) -> MetaItem 
mk_std			fn mk_std(cx: &TestCtxt) -> P<ast::Item> 
mk_stmts_let			fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<ast::Stmt> 
mk_substr_filename			    pub fn mk_substr_filename(&self, sp: Span) -> String 
mk_sugared_doc_attr			pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute 
mk_test_desc_and_fn_rec			fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> 
mk_test_descs			fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> 
mk_test_module			fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) 
mk_tests			fn mk_tests(cx: &TestCtxt) -> P<ast::Item> 
mk_token_path			fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> 
mk_tt_path			fn mk_tt_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> 
mk_tup_field			    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind 
mk_unary			    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::ExprKind 
mk_word_item			pub fn mk_word_item(name: Name) -> MetaItem 
modify_for_testing			pub fn modify_for_testing(sess: &ParseSess,
monotonic_expander			    pub fn monotonic_expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> 
move_flat_map			    fn move_flat_map<F, I>(mut self, mut f: F) -> Self
move_flat_map			    fn move_flat_map<F, I>(self, f: F) -> Self
move_map			    pub mod move_map;
move_map			    fn move_map<F>(self, mut f: F) -> Self where F: FnMut(T) -> T 
multiple_labels_primary_without_message			fn multiple_labels_primary_without_message() 
multiple_labels_primary_without_message_2			fn multiple_labels_primary_without_message_2() 
multiple_labels_secondary_without_message			fn multiple_labels_secondary_without_message() 
multiple_labels_secondary_without_message_2			fn multiple_labels_secondary_without_message_2() 
multiple_labels_secondary_without_message_3			fn multiple_labels_secondary_without_message_3() 
multiple_labels_with_message			fn multiple_labels_with_message() 
multiple_labels_without_message			fn multiple_labels_without_message() 
multiple_labels_without_message_2			fn multiple_labels_without_message_2() 
n_rec			    fn n_rec<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, m: &TokenTree, mut res: &mut I,
name			    pub fn name(&self) -> &'static str 
name			    pub fn name(&self) -> Name 
name			    pub fn name(&self) -> Option<Name> 
name			            pub fn name(self) -> &'static str 
name_from			    pub fn name_from(&self, start: BytePos) -> ast::Name 
name_from_to			    pub fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name 
name_of			    pub fn name_of(&self, st: &str) -> ast::Name 
name_value_literal			    pub fn name_value_literal(&self) -> Option<(Name, &Lit)> 
nameize			fn nameize<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, ms: &[TokenTree], mut res: I)
nbsp			    fn nbsp(&mut self) -> io::Result<()> { self.writer().word(" ") }
needs_parentheses			fn needs_parentheses(expr: &ast::Expr) -> bool 
nested			fn nested() 
nested_block_comments			    fn nested_block_comments() 
new			    fn new(idx: usize) -> Self 
new			    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, span: Span) -> Self 
new			    pub fn new(x: usize) -> NodeId 
new			    pub fn new(mapping: Vec<(String, String)>) -> FilePathMapping 
new			    pub fn new(path_mapping: FilePathMapping) -> CodeMap 
new			    pub fn new(parse_sess: &'a parse::ParseSess,
new			    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self 
new			    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self 
new			    fn new(tts: &[quoted::TokenTree]) -> FirstSets 
new			    fn new(tts: Vec<quoted::TokenTree>) -> Frame 
new			            pub fn new() -> Features 
new			    pub fn new(dst: Box<Write + Send>,
new			    pub fn new(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self 
new			    pub fn new(file_path_mapping: FilePathMapping) -> Self 
new			    fn new(sp: Span, delimited: &Delimited) -> Self 
new			    pub fn new(sess: &'a ParseSess,
new			    pub fn new() -> Self 
new			    pub fn new(cm: &'a CodeMap,
new			    pub fn new() -> P<[T]> 
new			    fn new(stream: RcSlice<TokenStream>) -> Self 
new			    fn new(stream: TokenStream) -> Self 
new			    pub fn new() -> TokenStreamBuilder 
new			    pub fn new() -> NodeCounter 
new			    pub fn new(vec: Vec<T>) -> Self 
new			    pub fn new() -> Self 
new_filemap			    pub fn new_filemap(&self, filename: FileName, src: String) -> Rc<FileMap> 
new_filemap_and_lines			    pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> 
new_from_input			    pub fn new_from_input(cm: &'a CodeMap,
new_id			    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId 
new_id			    fn new_id(&mut self, i: NodeId) -> NodeId 
new_imported_filemap			    pub fn new_imported_filemap(&self,
new_parser_from_file			pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a> 
new_parser_from_source_str			pub fn new_parser_from_source_str(sess: &ParseSess, name: String, source: String)
new_parser_from_tts			    pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> 
new_parser_from_tts			pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser 
new_raw			    pub fn new_raw(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self 
new_raw_internal			    fn new_raw_internal(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self 
new_span			    fn new_span(&mut self, mut span: Span) -> Span 
new_span			    fn new_span(&mut self, sp: Span) -> Span 
new_sub_parser_from_file			pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,
next			    fn next(&mut self) -> Option<quoted::TokenTree> 
next			    fn next(&mut self) -> TokenAndSpan 
next			    fn next(&mut self) -> Option<TokenTree> 
next_as_stream			    fn next_as_stream(&mut self) -> Option<TokenStream> 
next_as_stream			    pub fn next_as_stream(&mut self) -> Option<TokenStream> 
next_comment			    fn next_comment(&mut self) -> Option<comments::Comment> 
next_desugared			    fn next_desugared(&mut self) -> TokenAndSpan 
next_lit			    fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> 
next_node_id			    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }
next_node_id			    fn next_node_id(&mut self) -> ast::NodeId;
next_start_pos			    fn next_start_pos(&self) -> usize 
next_tok			    fn next_tok(&mut self) -> TokenAndSpan 
next_token			    fn next_token(&mut self) -> TokenAndSpan where Self: Sized 
next_token_inner			    fn next_token_inner(&mut self) -> Result<token::Token, ()> 
nextch			    pub fn nextch(&self) -> Option<char> 
nextch_is			    pub fn nextch_is(&self, c: char) -> bool 
nextnextch			    pub fn nextnextch(&self) -> Option<char> 
nextnextch_is			    pub fn nextnextch_is(&self, c: char) -> bool 
node_count			    pub mod node_count;
non_nested			fn non_nested() 
non_overlaping			fn non_overlaping() 
non_pattern_whitespace			    fn non_pattern_whitespace() 
none			    pub fn none() -> SeqSep 
noop_fold_angle_bracketed_parameter_data			pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,
noop_fold_arg			pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg 
noop_fold_arm			pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm 
noop_fold_attribute			pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Option<Attribute> 
noop_fold_block			pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> 
noop_fold_bounds			fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)
noop_fold_crate			pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,
noop_fold_expr			pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mut T) -> Expr 
noop_fold_exprs			pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Expr>> 
noop_fold_field			pub fn noop_fold_field<T: Folder>(f: Field, folder: &mut T) -> Field 
noop_fold_fn_decl			pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> 
noop_fold_foreign_item			pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem 
noop_fold_foreign_mod			pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,
noop_fold_generics			pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,
noop_fold_global_asm			pub fn noop_fold_global_asm<T: Folder>(ga: P<GlobalAsm>,
noop_fold_ident			pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident 
noop_fold_impl_item			pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)
noop_fold_interpolated			pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)
noop_fold_item			pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<Item>> 
noop_fold_item_kind			pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind 
noop_fold_item_simple			pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,
noop_fold_lifetime			pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime 
noop_fold_lifetime_def			pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T)
noop_fold_lifetime_defs			pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T)
noop_fold_lifetimes			pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> 
noop_fold_local			pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> 
noop_fold_mac			pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac 
noop_fold_macro_def			pub fn noop_fold_macro_def<T: Folder>(def: MacroDef, fld: &mut T) -> MacroDef 
noop_fold_meta_item			pub fn noop_fold_meta_item<T: Folder>(mi: MetaItem, fld: &mut T) -> MetaItem 
noop_fold_meta_items			pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<MetaItem>, fld: &mut T) -> Vec<MetaItem> 
noop_fold_meta_list_item			pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)
noop_fold_method_sig			pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig 
noop_fold_mod			pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod 
noop_fold_mt			pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutTy 
noop_fold_opt_bounds			pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>, folder: &mut T)
noop_fold_opt_expr			pub fn noop_fold_opt_expr<T: Folder>(e: P<Expr>, folder: &mut T) -> Option<P<Expr>> 
noop_fold_opt_lifetime			pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)
noop_fold_parenthesized_parameter_data			pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,
noop_fold_pat			pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> 
noop_fold_path			pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path 
noop_fold_path_parameters			pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)
noop_fold_poly_trait_ref			pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef 
noop_fold_range_end			pub fn noop_fold_range_end<T: Folder>(end: RangeEnd, _folder: &mut T) -> RangeEnd 
noop_fold_stmt			pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T) -> SmallVector<Stmt> 
noop_fold_stmt_kind			pub fn noop_fold_stmt_kind<T: Folder>(node: StmtKind, folder: &mut T) -> SmallVector<StmtKind> 
noop_fold_struct_field			pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField 
noop_fold_token			pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token 
noop_fold_trait_item			pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)
noop_fold_trait_ref			pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef 
noop_fold_tt			pub fn noop_fold_tt<T: Folder>(tt: TokenTree, fld: &mut T) -> TokenTree 
noop_fold_tts			pub fn noop_fold_tts<T: Folder>(tts: TokenStream, fld: &mut T) -> TokenStream 
noop_fold_ty			pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> 
noop_fold_ty_binding			pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding 
noop_fold_ty_param			pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam 
noop_fold_ty_param_bound			pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)
noop_fold_ty_params			pub fn noop_fold_ty_params<T: Folder>(tps: Vec<TyParam>, fld: &mut T) -> Vec<TyParam> 
noop_fold_usize			pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize 
noop_fold_variant			pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant 
noop_fold_variant_data			pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData 
noop_fold_view_path			pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> 
noop_fold_vis			pub fn noop_fold_vis<T: Folder>(vis: Visibility, folder: &mut T) -> Visibility 
noop_fold_where_clause			pub fn noop_fold_where_clause<T: Folder>(
noop_fold_where_predicate			pub fn noop_fold_where_predicate<T: Folder>(
nospan			fn nospan<T>(t: T) -> codemap::Spanned<T> 
obsolete			pub mod obsolete;
obsolete			    fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) 
obsolete			    fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);
open_token			    pub fn open_token(&self) -> token::Token 
open_token			    pub fn open_token(&self) -> token::Token 
open_tt			    pub fn open_tt(&self, span: Span) -> TokenTree 
open_tt			    pub fn open_tt(&self, span: Span) -> TokenTree 
original_sp			pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span 
original_stream			    pub fn original_stream(&self) -> TokenStream 
out_of_line_mod			    fn out_of_line_mod() 
output_metadata			pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorMap)
overlaping_start_and_end			fn overlaping_start_and_end() 
parse			    pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>
parse			pub fn parse(sess: &ParseSess,
parse			pub fn parse(input: tokenstream::TokenStream, expect_matchers: bool, sess: &ParseSess)
parse			pub mod parse;
parse			    pub fn parse(cx: &base::ExtCtxt, mtch: &[quoted::TokenTree], tts: TokenStream)
parse_all_token_trees			    pub fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> 
parse_all_token_trees			    pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> 
parse_arg			    pub fn parse_arg(&mut self) -> PResult<'a, Arg> 
parse_arg_general			    pub fn parse_arg_general(&mut self, require_name: bool) -> PResult<'a, Arg> 
parse_arg_panic			pub fn parse_arg_panic(parser: &mut Parser) -> Arg 
parse_arguments_to_quote			fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[TokenTree])
parse_arm			    pub fn parse_arm(&mut self) -> PResult<'a, Arm> 
parse_arm_panic			pub fn parse_arm_panic(parser: &mut Parser) -> Arm 
parse_as_ident			    fn parse_as_ident(&mut self) -> bool 
parse_assoc_expr			    pub fn parse_assoc_expr(&mut self,
parse_assoc_expr_with			    pub fn parse_assoc_expr_with(&mut self,
parse_assoc_op_cast			    fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,
parse_attribute			    pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> 
parse_attribute_panic			pub fn parse_attribute_panic(parser: &mut Parser, permit_inner: bool) -> ast::Attribute 
parse_attribute_with_inner_parse_policy			    fn parse_attribute_with_inner_parse_policy(&mut self,
parse_block			    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> 
parse_block_expr			    pub fn parse_block_expr(&mut self, lo: Span, blk_mode: BlockCheckMode,
parse_block_panic			pub fn parse_block_panic(parser: &mut Parser) -> P<Block> 
parse_block_tail			    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> 
parse_borrowed_pointee			    fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> 
parse_bottom_expr			    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> 
parse_catch_expr			    pub fn parse_catch_expr(&mut self, span_lo: Span, mut attrs: ThinVec<Attribute>)
parse_crate_attrs_from_file			pub fn parse_crate_attrs_from_file<'a>(input: &Path, sess: &'a ParseSess)
parse_crate_attrs_from_source_str			pub fn parse_crate_attrs_from_source_str(name: String, source: String, sess: &ParseSess)
parse_crate_from_file			pub fn parse_crate_from_file<'a>(input: &Path, sess: &'a ParseSess) -> PResult<'a, ast::Crate> 
parse_crate_from_source_str			pub fn parse_crate_from_source_str(name: String, source: String, sess: &ParseSess)
parse_crate_mod			    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> 
parse_defaultness			    fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> 
parse_dot_or_call_expr			    pub fn parse_dot_or_call_expr(&mut self,
parse_dot_or_call_expr_with			    pub fn parse_dot_or_call_expr_with(&mut self,
parse_dot_or_call_expr_with_			    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> 
parse_dot_suffix			    fn parse_dot_suffix(&mut self, ident: Ident, ident_span: Span, self_value: P<Expr>, lo: Span)
parse_else_expr			    pub fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> 
parse_enum_def			    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> PResult<'a, EnumDef> 
parse_expansion			    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, path: &Path, span: Span)
parse_expansion			    pub fn parse_expansion(&mut self, kind: ExpansionKind, macro_legacy_warnings: bool)
parse_expr			        fn parse_expr(&self, s: String) -> P<ast::Expr> 
parse_expr			        fn parse_expr(&self, s: String) -> P<ast::Expr>;
parse_expr			    pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> 
parse_expr_from_source_str			pub fn parse_expr_from_source_str(name: String, source: String, sess: &ParseSess)
parse_expr_panic			pub fn parse_expr_panic(parser: &mut Parser) -> P<Expr> 
parse_expr_res			    pub fn parse_expr_res(&mut self, r: Restrictions,
parse_failure_msg			pub fn parse_failure_msg(tok: Token) -> String 
parse_field			    pub fn parse_field(&mut self) -> PResult<'a, Field> 
parse_field_name			    pub fn parse_field_name(&mut self) -> PResult<'a, Ident> 
parse_fn_args			    fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)
parse_fn_block_arg			    pub fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> 
parse_fn_block_decl			    fn parse_fn_block_decl(&mut self) -> PResult<'a, P<FnDecl>> 
parse_fn_decl			    pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> PResult<'a, P<FnDecl>> 
parse_fn_decl_with_self			    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> PResult<'a, P<FnDecl>>
parse_fn_front_matter			    pub fn parse_fn_front_matter(&mut self)
parse_fn_header			    fn parse_fn_header(&mut self) -> PResult<'a, (Ident, ast::Generics)> 
parse_for_expr			    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,
parse_foreign_item			    fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> 
parse_full_stmt			    pub fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> 
parse_generic_args			    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<Lifetime>, Vec<P<Ty>>, Vec<TypeBinding>)> 
parse_generic_params			    pub fn parse_generic_params(&mut self) -> PResult<'a, (Vec<LifetimeDef>, Vec<TyParam>)> 
parse_generics			    pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> 
parse_ident			    pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> 
parse_if_expr			    pub fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> 
parse_if_let_expr			    pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)
parse_impl_item			    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> 
parse_impl_method			    fn parse_impl_method(&mut self, vis: &Visibility, at_end: &mut bool)
parse_initializer			    fn parse_initializer(&mut self) -> PResult<'a, Option<P<Expr>>> 
parse_inner_attributes			    pub fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> 
parse_inner_attrs_and_block			    fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> 
parse_item			        fn parse_item(&self, s: String) -> P<ast::Item> 
parse_item			        fn parse_item(&self, s: String) -> P<ast::Item>;
parse_item			    pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> 
parse_item_			    fn parse_item_(&mut self, attrs: Vec<Attribute>,
parse_item_const			    fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> 
parse_item_enum			    fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> 
parse_item_extern_crate			    fn parse_item_extern_crate(&mut self,
parse_item_fn			    fn parse_item_fn(&mut self,
parse_item_foreign_fn			    fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)
parse_item_foreign_mod			    fn parse_item_foreign_mod(&mut self,
parse_item_foreign_static			    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)
parse_item_from_source_str			pub fn parse_item_from_source_str(name: String, source: String, sess: &ParseSess)
parse_item_impl			    fn parse_item_impl(&mut self,
parse_item_mod			    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> 
parse_item_panic			pub fn parse_item_panic(parser: &mut Parser) -> Option<P<Item>> 
parse_item_struct			    fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> 
parse_item_trait			    fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> 
parse_item_type			    fn parse_item_type(&mut self) -> PResult<'a, ItemInfo> 
parse_item_union			    fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> 
parse_lambda_expr			    pub fn parse_lambda_expr(&mut self,
parse_late_bound_lifetime_defs			    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<LifetimeDef>> 
parse_list			    pub fn parse_list<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, Vec<T>>
parse_lit			    pub fn parse_lit(&mut self) -> PResult<'a, Lit> 
parse_lit_token			    pub fn parse_lit_token(&mut self) -> PResult<'a, LitKind> 
parse_local			    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> 
parse_loop_expr			    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,
parse_lt_param_bounds			    fn parse_lt_param_bounds(&mut self) -> Vec<Lifetime> 
parse_macro_use_or_failure			    fn parse_macro_use_or_failure(
parse_match_expr			    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> 
parse_meta			    pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> 
parse_meta_from_source_str			pub fn parse_meta_from_source_str(name: String, source: String, sess: &ParseSess)
parse_meta_item			    pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> 
parse_meta_item_inner			    fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> 
parse_meta_item_kind			    pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> 
parse_meta_item_panic			pub fn parse_meta_item_panic(parser: &mut Parser) -> ast::MetaItem 
parse_meta_seq			    fn parse_meta_seq(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> 
parse_mod_items			    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: Span) -> PResult<'a, Mod> 
parse_mutability			    fn parse_mutability(&mut self) -> Mutability 
parse_name_and_ty			    fn parse_name_and_ty(&mut self,
parse_nt			fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal 
parse_opt_abi			    fn parse_opt_abi(&mut self) -> PResult<'a, Option<abi::Abi>> 
parse_optional_str			    pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> 
parse_or_use_outer_attributes			    fn parse_or_use_outer_attributes(&mut self,
parse_outer_attributes			    pub fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> 
parse_pat			    pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> 
parse_pat_fields			    fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>>, bool)> 
parse_pat_ident			    fn parse_pat_ident(&mut self,
parse_pat_literal_maybe_minus			    pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> 
parse_pat_panic			pub fn parse_pat_panic(parser: &mut Parser) -> P<Pat> 
parse_pat_range_end			    fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> 
parse_pat_tuple_elements			    fn parse_pat_tuple_elements(&mut self, unary_needs_comma: bool)
parse_pat_vec_elements			    fn parse_pat_vec_elements(
parse_path			    pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> 
parse_path_allowing_meta			    pub fn parse_path_allowing_meta(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> 
parse_path_and_tokens			    pub fn parse_path_and_tokens(&mut self) -> PResult<'a, (ast::Path, TokenStream)> 
parse_path_common			    fn parse_path_common(&mut self, mode: PathStyle, parse_generics: bool)
parse_path_list_items			    fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> 
parse_path_panic			pub fn parse_path_panic(parser: &mut Parser, mode: PathStyle) -> ast::Path 
parse_path_segment_ident			    pub fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> 
parse_path_segments_with_colons			    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<PathSegment>> 
parse_path_segments_without_colons			    pub fn parse_path_segments_without_colons(&mut self, parse_generics: bool)
parse_path_segments_without_types			    pub fn parse_path_segments_without_types(&mut self)
parse_path_without_generics			    pub fn parse_path_without_generics(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> 
parse_pats			    fn parse_pats(&mut self) -> PResult<'a, Vec<P<Pat>>> 
parse_prefix_expr			    pub fn parse_prefix_expr(&mut self,
parse_prefix_range_expr			    fn parse_prefix_range_expr(&mut self,
parse_ptr			    pub fn parse_ptr(&mut self) -> PResult<'a, MutTy> 
parse_qualified_path			    pub fn parse_qualified_path(&mut self, mode: PathStyle)
parse_record_struct_body			    pub fn parse_record_struct_body(&mut self) -> PResult<'a, Vec<StructField>> 
parse_remaining_bounds			    fn parse_remaining_bounds(&mut self, lifetime_defs: Vec<LifetimeDef>, path: ast::Path,
parse_rename			    fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> 
parse_ret_ty			    pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> 
parse_self_arg			    fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> 
parse_sep_and_kleene_op			fn parse_sep_and_kleene_op<I>(input: &mut I, span: Span, sess: &ParseSess)
parse_seq			    pub fn parse_seq<T, F>(&mut self,
parse_seq_to_before_end			    pub fn parse_seq_to_before_end<T, F>(&mut self,
parse_seq_to_before_gt			    pub fn parse_seq_to_before_gt<T, F>(&mut self,
parse_seq_to_before_gt_or_return			    pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,
parse_seq_to_before_tokens			    fn parse_seq_to_before_tokens<T, F, Fe>(&mut self,
parse_seq_to_end			    pub fn parse_seq_to_end<T, F>(&mut self,
parse_seq_to_gt			    pub fn parse_seq_to_gt<T, F>(&mut self,
parse_seq_to_gt_or_return			    pub fn parse_seq_to_gt_or_return<T, F>(&mut self,
parse_sess			    pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }
parse_single_struct_field			    pub fn parse_single_struct_field(&mut self,
parse_stmt			        fn parse_stmt(&self, s: String) -> ast::Stmt 
parse_stmt			        fn parse_stmt(&self, s: String) -> ast::Stmt;
parse_stmt			    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> 
parse_stmt_			    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> 
parse_stmt_from_source_str			pub fn parse_stmt_from_source_str(name: String, source: String, sess: &ParseSess)
parse_stmt_panic			pub fn parse_stmt_panic(parser: &mut Parser) -> Option<Stmt> 
parse_stmt_without_recovery			    fn parse_stmt_without_recovery(&mut self,
parse_str			    pub fn parse_str(&mut self) -> PResult<'a, (Symbol, StrStyle)> 
parse_stream_from_source_str			pub fn parse_stream_from_source_str(name: String, source: String, sess: &ParseSess,
parse_struct_decl_field			    fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> 
parse_struct_expr			    fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)
parse_token_tree			    fn parse_token_tree(&mut self) -> PResult<'a, TokenTree> 
parse_token_tree			    pub fn parse_token_tree(&mut self) -> TokenTree 
parse_token_trees_until_close_delim			    fn parse_token_trees_until_close_delim(&mut self) -> TokenStream 
parse_tokens			    pub fn parse_tokens(&mut self) -> TokenStream 
parse_trait_item			    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> 
parse_tree			fn parse_tree<I>(tree: tokenstream::TokenTree,
parse_tts			        fn parse_tts(&self, s: String) -> Vec<TokenTree> 
parse_tts			        fn parse_tts(&self, s: String) -> Vec<TokenTree>;
parse_tuple_struct_body			    pub fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<StructField>> 
parse_ty			    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> 
parse_ty_bare_fn			    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<LifetimeDef>)
parse_ty_common			    fn parse_ty_common(&mut self, allow_plus: bool) -> PResult<'a, P<Ty>> 
parse_ty_no_plus			    fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> 
parse_ty_panic			pub fn parse_ty_panic(parser: &mut Parser) -> P<Ty> 
parse_ty_param			    fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> 
parse_ty_param_bounds			    fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds> 
parse_ty_param_bounds_common			    fn parse_ty_param_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, TyParamBounds> 
parse_unsafety			    pub fn parse_unsafety(&mut self) -> PResult<'a, Unsafety> 
parse_unspanned_seq			    pub fn parse_unspanned_seq<T, F>(&mut self,
parse_unsuffixed_lit			    fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> 
parse_view_path			    fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> 
parse_visibility			    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> 
parse_where_clause			    pub fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> 
parse_while_expr			    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,
parse_while_let_expr			    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,
parser			    pub mod parser;
parser			pub mod parser;
parser_done			    fn parser_done(p: Parser)
parser_testing			    pub mod parser_testing;
pat			    fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> 
pat			    fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat>;
pat_err			    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> 
pat_err			    fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;
pat_ident			    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> 
pat_ident			    fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat>;
pat_ident_binding_mode			    fn pat_ident_binding_mode(&self,
pat_lit			    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> 
pat_lit			    fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat>;
pat_none			    fn pat_none(&self, span: Span) -> P<ast::Pat> 
pat_none			    fn pat_none(&self, span: Span) -> P<ast::Pat>;
pat_ok			    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> 
pat_ok			    fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;
pat_path			    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> 
pat_path			    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat>;
pat_some			    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> 
pat_some			    fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;
pat_struct			    fn pat_struct(&self, span: Span, path: ast::Path,
pat_to_string			pub fn pat_to_string(pat: &ast::Pat) -> String 
pat_tuple			    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> 
pat_tuple			    fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;
pat_tuple_struct			    fn pat_tuple_struct(&self, span: Span, path: ast::Path,
pat_wild			    fn pat_wild(&self, span: Span) -> P<ast::Pat> 
pat_wild			    fn pat_wild(&self, span: Span) -> P<ast::Pat>;
path			    pub fn path(&self) -> &Path 
path			    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path 
path			    fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;
path_all			    fn path_all(&self, sp: Span,
path_all			    fn path_all(&self,
path_global			    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path 
path_global			    fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path;
path_ident			    fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path 
path_ident			    fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;
path_mapping			    pub fn path_mapping(&self) -> &FilePathMapping 
path_name_i			fn path_name_i(idents: &[Ident]) -> String 
path_node			fn path_node(ids: Vec<Ident>) -> ast::Path 
path_segment_to_string			pub fn path_segment_to_string(p: &ast::PathSegment) -> String 
path_to_string			pub fn path_to_string(p: &ast::Path) -> String 
pattern_whitespace			    fn pattern_whitespace() 
pclose			    fn pclose(&mut self) -> io::Result<()> { self.writer().word(")") }
peek			    pub fn peek(&self) -> TokenAndSpan 
peeking_at_comment			    fn peeking_at_comment(&self) -> bool 
placeholder			pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion 
placeholder_from_mark			    pub fn placeholder_from_mark(mark: Mark) -> Self 
placeholder_to_mark			    pub fn placeholder_to_mark(self) -> Mark 
placeholders			    pub mod placeholders;
plugin			    pub mod plugin;
poly_trait_ref			    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef 
poly_trait_ref			    fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;
popen			    fn popen(&mut self) -> io::Result<()> { self.writer().word("(") }
post			    fn post(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }
pp			    pub mod pp;
pprust			    pub mod pprust;
pre			    fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> { Ok(()) }
precedence			    pub fn precedence(&self) -> usize 
pretty_print			    pub fn pretty_print(&mut self, token: Token) -> io::Result<()> 
print			pub mod print 
print			    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> 
print_arg			    pub fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) -> io::Result<()> 
print_arm			    fn print_arm(&mut self, arm: &ast::Arm) -> io::Result<()> 
print_associated_const			    fn print_associated_const(&mut self,
print_associated_type			    fn print_associated_type(&mut self,
print_attribute			    fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> 
print_attribute_inline			    fn print_attribute_inline(&mut self, attr: &ast::Attribute,
print_block			    pub fn print_block(&mut self, blk: &ast::Block) -> io::Result<()> 
print_block_maybe_unclosed			    pub fn print_block_maybe_unclosed(&mut self,
print_block_unclosed			    pub fn print_block_unclosed(&mut self, blk: &ast::Block) -> io::Result<()> 
print_block_unclosed_indent			    pub fn print_block_unclosed_indent(&mut self, blk: &ast::Block,
print_block_unclosed_with_attrs			    pub fn print_block_unclosed_with_attrs(&mut self, blk: &ast::Block,
print_block_with_attrs			    pub fn print_block_with_attrs(&mut self,
print_bounds			    pub fn print_bounds(&mut self,
print_call_post			    fn print_call_post(&mut self, args: &[P<ast::Expr>]) -> io::Result<()> 
print_capture_clause			    pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)
print_comment			    fn print_comment(&mut self,
print_crate			pub fn print_crate<'a>(cm: &'a CodeMap,
print_defaultness			    pub fn print_defaultness(&mut self, defatulness: ast::Defaultness) -> io::Result<()> 
print_either_attributes			    fn print_either_attributes(&mut self,
print_else			    fn print_else(&mut self, els: Option<&ast::Expr>) -> io::Result<()> 
print_enum_def			    pub fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,
print_explicit_self			    fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) -> io::Result<()> 
print_expr			    pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> 
print_expr_addr_of			    fn print_expr_addr_of(&mut self,
print_expr_binary			    fn print_expr_binary(&mut self,
print_expr_call			    fn print_expr_call(&mut self,
print_expr_in_place			    fn print_expr_in_place(&mut self,
print_expr_maybe_paren			    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr) -> io::Result<()> 
print_expr_method_call			    fn print_expr_method_call(&mut self,
print_expr_outer_attr_style			    fn print_expr_outer_attr_style(&mut self,
print_expr_repeat			    fn print_expr_repeat(&mut self,
print_expr_struct			    fn print_expr_struct(&mut self,
print_expr_tup			    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>],
print_expr_unary			    fn print_expr_unary(&mut self,
print_expr_vec			    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],
print_extern_opt_abi			    pub fn print_extern_opt_abi(&mut self,
print_fn			    pub fn print_fn(&mut self,
print_fn_args_and_ret			    pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl)
print_fn_block_args			    pub fn print_fn_block_args(
print_fn_header_info			    pub fn print_fn_header_info(&mut self,
print_fn_output			    pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> io::Result<()> 
print_for_decl			    pub fn print_for_decl(&mut self, loc: &ast::Local,
print_foreign_item			    pub fn print_foreign_item(&mut self,
print_foreign_mod			    pub fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,
print_formal_lifetime_list			    fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> io::Result<()> 
print_generics			    pub fn print_generics(&mut self,
print_ident			    pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> 
print_if			    pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,
print_if_let			    pub fn print_if_let(&mut self, pat: &ast::Pat, expr: &ast::Expr, blk: &ast::Block,
print_impl_item			    pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> 
print_inner_attributes			    fn print_inner_attributes(&mut self,
print_inner_attributes_inline			    fn print_inner_attributes_inline(&mut self,
print_inner_attributes_no_trailing_hardbreak			    fn print_inner_attributes_no_trailing_hardbreak(&mut self,
print_item			    pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> 
print_lifetime			    pub fn print_lifetime(&mut self,
print_lifetime_bounds			    pub fn print_lifetime_bounds(&mut self,
print_literal			    fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> 
print_local_decl			    pub fn print_local_decl(&mut self, loc: &ast::Local) -> io::Result<()> 
print_mac			    pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)
print_meta_item			    fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> 
print_meta_list_item			    fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) -> io::Result<()> 
print_method_sig			    pub fn print_method_sig(&mut self,
print_mod			    pub fn print_mod(&mut self, _mod: &ast::Mod,
print_mt			    pub fn print_mt(&mut self, mt: &ast::MutTy) -> io::Result<()> 
print_mutability			    pub fn print_mutability(&mut self,
print_name			    pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> 
print_newline			    pub fn print_newline(&mut self, amount: isize) -> io::Result<()> 
print_opt_abi_and_extern_if_nondefault			    pub fn print_opt_abi_and_extern_if_nondefault(&mut self,
print_opt_lifetime			    pub fn print_opt_lifetime(&mut self,
print_outer_attributes			    fn print_outer_attributes(&mut self,
print_outer_attributes_inline			    fn print_outer_attributes_inline(&mut self,
print_pat			    pub fn print_pat(&mut self, pat: &ast::Pat) -> io::Result<()> 
print_path			    fn print_path(&mut self,
print_path_parameters			    fn print_path_parameters(&mut self,
print_path_segment			    fn print_path_segment(&mut self,
print_poly_trait_ref			    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> io::Result<()> 
print_qpath			    fn print_qpath(&mut self,
print_remaining_comments			    pub fn print_remaining_comments(&mut self) -> io::Result<()> 
print_stmt			    pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> 
print_str			    pub fn print_str(&mut self, s: &str) -> io::Result<()> 
print_string			    fn print_string(&mut self, st: &str,
print_struct			    pub fn print_struct(&mut self,
print_trait_item			    pub fn print_trait_item(&mut self, ti: &ast::TraitItem)
print_trait_ref			    fn print_trait_ref(&mut self, t: &ast::TraitRef) -> io::Result<()> 
print_tt			    fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> 
print_tts			    fn print_tts(&mut self, tts: tokenstream::TokenStream) -> io::Result<()> 
print_ty_fn			    pub fn print_ty_fn(&mut self,
print_ty_param			    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> io::Result<()> 
print_type			    pub fn print_type(&mut self, ty: &ast::Ty) -> io::Result<()> 
print_unsafety			    pub fn print_unsafety(&mut self, s: ast::Unsafety) -> io::Result<()> 
print_usize			    pub fn print_usize(&mut self, i: usize) -> io::Result<()> 
print_variant			    pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> 
print_variants			    pub fn print_variants(&mut self,
print_view_path			    pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> io::Result<()> 
print_visibility			    pub fn print_visibility(&mut self, vis: &ast::Visibility) -> io::Result<()> 
print_where_clause			    pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)
proc_macro_enabled			        fn proc_macro_enabled = proc_macro,
process_cfg_attr			    fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> 
process_cfg_attrs			    pub fn process_cfg_attrs<T: HasAttrs>(&mut self, node: T) -> T 
process_potential_macro_variable			    pub fn process_potential_macro_variable(&mut self) 
ptr			pub mod ptr;
push			    pub fn push<T: Into<TokenStream>>(&mut self, stream: T) 
push_all_but_first_tree			    fn push_all_but_first_tree(&mut self, stream: &TokenStream) 
push_all_but_last_tree			    fn push_all_but_last_tree(&mut self, stream: &TokenStream) 
push_blank_line_comment			fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) 
push_directory			    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) 
push_match			    fn push_match(&mut self, idx: usize, m: NamedMatch) 
qpath			    fn qpath(&self, self_type: P<ast::Ty>,
qpath			    fn qpath(&self,
qpath_all			    fn qpath_all(&self, self_type: P<ast::Ty>,
qpath_all			    fn qpath_all(&self,
quote			    pub mod quote;
quoted			        pub mod quoted;
quoted_tt_to_string			fn quoted_tt_to_string(tt: &quoted::TokenTree) -> String 
raw_expr			    pub fn raw_expr(sp: Span) -> P<ast::Expr> 
raw_pat			    pub fn raw_pat(sp: Span) -> ast::Pat 
raw_str_lit			pub fn raw_str_lit(lit: &str) -> String 
raw_string			    fn raw_string() 
raw_ty			    pub fn raw_ty(sp: Span) -> P<ast::Ty> 
rbox			    pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> 
rbox			    fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> 
rc_slice			    mod rc_slice;
read_block_comment			fn read_block_comment(rdr: &mut StringReader,
read_file			    fn read_file(&self, path: &Path) -> io::Result<String> 
read_file			    fn read_file(&self, path: &Path) -> io::Result<String>;
read_line_comments			fn read_line_comments(rdr: &mut StringReader,
read_one_line_comment			    fn read_one_line_comment(&mut self) -> String 
read_shebang_comment			fn read_shebang_comment(rdr: &mut StringReader,
read_to_eol			    fn read_to_eol(&mut self) -> String 
real_token			    pub fn real_token(&mut self) -> TokenAndSpan 
recover_stmt			    fn recover_stmt(&mut self) 
recover_stmt_			    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) 
remove			    fn remove(&mut self, id: ast::NodeId) -> Expansion 
render			    fn render(&self, suggestion: &CodeSuggestion) -> Vec<String> 
repeat			fn repeat(s: &str, n: usize) -> String { iter::repeat(s).take(n).collect() }
replace_last_token			    pub fn replace_last_token(&mut self, t: Token) 
replace_with			    fn replace_with(&mut self, tok: quoted::TokenTree) 
replace_with_irrelevant			    fn replace_with_irrelevant(&mut self) 
report			    fn report(&mut self,
requests_inline			pub fn requests_inline(attrs: &[Attribute]) -> bool 
res_rel_file			fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: &Path) -> PathBuf 
resolve_imports			    fn resolve_imports(&mut self) {}
resolve_imports			    fn resolve_imports(&mut self);
resolve_imports			    fn resolve_imports(&mut self) 
resolve_invoc			    fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)
resolve_invoc			    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)
resolve_macro			    fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,
resolve_macro			    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)
respan			pub fn respan<T>(sp: Span, t: T) -> Spanned<T> 
retokenize			    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self 
rt			pub mod rt 
run			pub fn run(span_diagnostic: &errors::Handler,
rust_printer			fn rust_printer<'a>(writer: Box<Write+'a>, ann: &'a PpAnn) -> State<'a> 
scan_block_comment			    fn scan_block_comment(&mut self) -> Option<TokenAndSpan> 
scan_byte			    fn scan_byte(&mut self) -> token::Lit 
scan_byte_escape			    fn scan_byte_escape(&mut self, delim: char, below_0x7f_only: bool) -> bool 
scan_byte_string			    fn scan_byte_string(&mut self) -> token::Lit 
scan_char_or_byte			    fn scan_char_or_byte(&mut self,
scan_comment			    fn scan_comment(&mut self) -> Option<TokenAndSpan> 
scan_digits			    fn scan_digits(&mut self, real_radix: u32, scan_radix: u32) -> usize 
scan_float_exponent			    fn scan_float_exponent(&mut self) 
scan_for_non_ws_or_end			fn scan_for_non_ws_or_end<I: Iterator<Item= char>>(iter: &mut Peekable<I>) 
scan_hex_digits			    fn scan_hex_digits(&mut self, n_digits: usize, delim: char, below_0x7f_only: bool) -> bool 
scan_number			    fn scan_number(&mut self, c: char) -> token::Lit 
scan_optional_raw_name			    fn scan_optional_raw_name(&mut self) -> Option<ast::Name> 
scan_pop			    pub fn scan_pop(&mut self) -> usize 
scan_pop_bottom			    pub fn scan_pop_bottom(&mut self) -> usize 
scan_push			    pub fn scan_push(&mut self, x: usize) 
scan_raw_byte_string			    fn scan_raw_byte_string(&mut self) -> token::Lit 
scan_top			    pub fn scan_top(&mut self) -> usize 
scan_unicode_escape			    fn scan_unicode_escape(&mut self, delim: char) -> bool 
scan_whitespace_or_comment			    fn scan_whitespace_or_comment(&mut self) -> Option<TokenAndSpan> 
serialize::UseSpecializedDecodable for NodeId			impl serialize::UseSpecializedDecodable for NodeId 
serialize::UseSpecializedEncodable for NodeId			impl serialize::UseSpecializedEncodable for NodeId 
set_trace_macros			    pub fn set_trace_macros(&mut self, x: bool) 
setup			    fn setup<'a>(cm: &CodeMap,
short_name			    pub fn short_name(&self) -> &'static str 
should_panic			fn should_panic(i: &ast::Item, cx: &TestCtxt) -> ShouldPanic 
show_span			pub mod show_span;
single_label_with_message			fn single_label_with_message() 
single_label_without_message			fn single_label_without_message() 
singleton			    fn singleton(tok: quoted::TokenTree) -> Self 
small_vector			    pub mod small_vector;
something			fn something() {}
something			pub fn something() {}
source_util			    pub mod source_util;
sp			    fn sp(a: u32, b: u32) -> Span 
sp			    fn sp(a: u32, b: u32) -> Span 
space			    pub fn space(&mut self) -> io::Result<()> 
space_if_not_bol			    fn space_if_not_bol(&mut self) -> io::Result<()> 
spaces			    fn spaces(&mut self, n: usize) -> io::Result<()> 
span			    pub fn span(&self) -> Span 
span			    fn span(&self) -> Span 
span			    pub fn span(&self) -> Span { self.span }
span			    pub fn span(&self) -> Span 
span			    pub fn span(&self) -> Span 
span			    fn span(&self) -> Span 
span			    pub fn span(&self) -> Span 
span			    pub fn span(&self) -> Span 
span_bug			    pub fn span_bug(&self, sp: Span, msg: &str) -> ! 
span_bug			    pub fn span_bug(&self, sp: Span, m: &str) -> ! 
span_err			    pub fn span_err(&self, sp: Span, msg: &str) 
span_err			    pub fn span_err(&self, sp: Span, m: &str) 
span_err			    pub fn span_err(self, sp: Span, handler: &errors::Handler) -> DiagnosticBuilder 
span_err_help			    pub fn span_err_help(&self, sp: Span, m: &str, h: &str) 
span_fatal			    pub fn span_fatal(&self, sp: Span, msg: &str) -> ! 
span_fatal			    pub fn span_fatal(&self, sp: Span, m: &str) -> DiagnosticBuilder<'a> 
span_fatal_err			    pub fn span_fatal_err(&self, sp: Span, err: Error) -> DiagnosticBuilder<'a> 
span_fatal_help			    pub fn span_fatal_help(&self, sp: Span, m: &str, help: &str) -> DiagnosticBuilder<'a> 
span_for_name			    pub fn span_for_name(&self, name: &str) -> Option<Span> 
span_from_selection			    fn span_from_selection(input: &str, selection: &str) -> Span 
span_merging_fail			    fn span_merging_fail() 
span_substr			        fn span_substr(&self,
span_to_filename			    fn span_to_filename(&self, sp: Span) -> FileName 
span_to_filename			    pub fn span_to_filename(&self, sp: Span) -> FileName 
span_to_lines			    fn span_to_lines(&self, sp: Span) -> FileLinesResult 
span_to_lines			    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult 
span_to_snippet			    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> 
span_to_snippet_and_lines_spanning_multiple_lines			    fn span_to_snippet_and_lines_spanning_multiple_lines() 
span_to_string			    fn span_to_string(&self, sp: Span) -> String 
span_to_string			    pub fn span_to_string(&self, sp: Span) -> String 
span_unimpl			    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! 
span_until_char			    pub fn span_until_char(&self, sp: Span, c: char) -> Span 
span_warn			    pub fn span_warn(&self, sp: Span, msg: &str) 
span_warn			    pub fn span_warn(&self, sp: Span, m: &str) 
statements_mk_tt			fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, quoted: bool) -> Vec<ast::Stmt> 
statements_mk_tts			fn statements_mk_tts(cx: &ExtCtxt, tts: TokenStream) -> Vec<ast::Stmt> 
std_inject			pub mod std_inject;
std_path			    pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> 
stderr			    pub fn stderr(registry: Option<Registry>,
stmt_ends_with_semi			pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool 
stmt_expr			    fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt 
stmt_expr			    fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;
stmt_item			    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt 
stmt_item			    fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;
stmt_let			    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;
stmt_let			    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,
stmt_let_type_only			    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt 
stmt_let_type_only			    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;
stmt_let_typed			    fn stmt_let_typed(&self,
stmt_semi			    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt 
stmt_semi			    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt;
stmt_to_string			pub fn stmt_to_string(stmt: &ast::Stmt) -> String 
str			pub mod str;
str2seg			    fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment 
str_lit			pub fn str_lit(lit: &str) -> String 
stream			    pub fn stream(&self) -> TokenStream 
stream			    pub fn stream(&self) -> TokenStream 
stream_to_parser			pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser 
string_to_crate			pub fn string_to_crate (source_str : String) -> ast::Crate 
string_to_expr			pub fn string_to_expr (source_str : String) -> P<ast::Expr> 
string_to_item			pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> 
string_to_parser			pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> 
string_to_pat			pub fn string_to_pat(source_str: String) -> P<ast::Pat> 
string_to_stmt			pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> 
string_to_stream			pub fn string_to_stream(source_str: String) -> TokenStream 
string_to_ts			    fn string_to_ts(string: &str) -> TokenStream 
string_to_tts_1			    fn string_to_tts_1() 
string_to_tts_macro			    fn string_to_tts_macro () 
strip_doc_comment_decoration			pub fn strip_doc_comment_decoration(comment: &str) -> String 
strs_to_idents			pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<Ident> 
struct_err_span_char			    fn struct_err_span_char(&self,
struct_fatal_span_char			    fn struct_fatal_span_char(&self,
struct_span_err			    pub fn struct_span_err(&self,
struct_span_fatal			    pub fn struct_span_fatal(&self,
struct_span_warn			    pub fn struct_span_warn(&self,
sub_slice			    pub fn sub_slice(&self, range: Range<usize>) -> Self 
submod_path			    fn submod_path(&mut self,
submod_path_from_attr			    pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> 
syntax			mod syntax 
syntax			pub mod syntax 
synth_comment			    pub fn synth_comment(&mut self, text: String) -> io::Result<()> 
t1			    fn t1 () 
t1			    fn t1() 
t2			    fn t2 () 
t3			    fn t3() 
t4			    fn t4() 
t5			    fn t5() 
t6			    fn t6() 
t7			    fn t7() 
t8			    fn t8() 
t9			    fn t9() 
test			pub mod test;
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
thin_vec			    mod thin_vec;
this_token_descr			    pub fn this_token_descr(&self) -> String 
this_token_to_string			    pub fn this_token_to_string(&self) -> String 
to_ast_binop			    pub fn to_ast_binop(&self) -> Option<BinOpKind> 
to_self			    pub fn to_self(&self) -> Option<ExplicitSelf> 
to_string			    pub fn to_string(&self) -> &'static str 
to_string			    pub fn to_string(op: UnOp) -> &'static str 
to_string			    fn to_string(&self) -> String 
to_string			pub fn to_string<F>(f: F) -> String where
to_tokens			                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> 
to_tokens			        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> 
to_tokens			        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;
to_tokens			        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> 
token			    fn token(&self) -> Token 
token			pub mod token;
token_can_be_followed_by_any			fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool 
token_is_bare_fn_keyword			    pub fn token_is_bare_fn_keyword(&mut self) -> bool 
token_name_eq			fn token_name_eq(t1 : &Token, t2 : &Token) -> bool 
token_to_string			    pub fn token_to_string(token: &token::Token) -> String 
token_to_string			pub fn token_to_string(tok: &Token) -> String 
tokens			    fn tokens(&self) -> TokenStream 
tokens			    pub fn tokens(&self, span: Span) -> TokenStream 
tokens_to_string			        fn tokens_to_string(tokens: &[TokenType]) -> String 
tokens_to_string			pub fn tokens_to_string(tokens: TokenStream) -> String 
tokenstream			pub mod tokenstream;
tokentrees			mod tokentrees;
trace_macros			    pub fn trace_macros(&self) -> bool 
trace_macros_diag			    pub fn trace_macros_diag(&self) 
trace_macros_note			fn trace_macros_note(cx: &mut ExtCtxt, sp: Span, message: String) 
trailing_allowed			    pub fn trailing_allowed(t: token::Token) -> SeqSep 
trait_item_to_string			pub fn trait_item_to_string(i: &ast::TraitItem) -> String 
trait_ref			    fn trait_ref(&self, path: ast::Path) -> ast::TraitRef 
trait_ref			    fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;
transcribe			pub fn transcribe(cx: &ExtCtxt,
transcribe			        pub mod transcribe;
translate_crlf			    fn translate_crlf<'b>(&self, start: BytePos, s: &'b str, errmsg: &'b str) -> Cow<'b, str> 
translate_crlf_			        fn translate_crlf_(rdr: &StringReader,
trees			    pub fn trees(&self) -> Cursor 
trim_whitespace_prefix_and_push_line			fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String>, s: String, col: CharPos) 
triple_overlap			fn triple_overlap() 
try_next_token			    pub fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> 
try_real_token			    fn try_real_token(&mut self) -> Result<TokenAndSpan, ()> 
tt			    pub mod tt 
tt_to_string			pub fn tt_to_string(tt: tokenstream::TokenTree) -> String 
ttdelim_span			    fn ttdelim_span() 
tts_to_string			pub fn tts_to_string(tts: &[tokenstream::TokenTree]) -> String 
ty			    fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty> 
ty			    fn ty(&self, span: Span, ty: ast::TyKind) -> P<ast::Ty>;
ty_ident			    fn ty_ident(&self, span: Span, ident: ast::Ident)
ty_ident			    fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;
ty_infer			    fn ty_infer(&self, sp: Span) -> P<ast::Ty>;
ty_infer			    fn ty_infer(&self, span: Span) -> P<ast::Ty> 
ty_mt			    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy 
ty_mt			    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;
ty_option			    fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> 
ty_option			    fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;
ty_path			    fn ty_path(&self, path: ast::Path) -> P<ast::Ty> 
ty_path			    fn ty_path(&self, path: ast::Path) -> P<ast::Ty>;
ty_ptr			    fn ty_ptr(&self, span: Span,
ty_ptr			    fn ty_ptr(&self,
ty_rptr			    fn ty_rptr(&self, span: Span,
ty_rptr			    fn ty_rptr(&self,
ty_to_string			    pub fn ty_to_string(&self) -> &'static str 
ty_to_string			pub fn ty_to_string(ty: &ast::Ty) -> String 
typaram			    fn typaram(&self,
typarambound			    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound 
typarambound			    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;
unexpected			    pub fn unexpected<T>(&mut self) -> PResult<'a, T> 
unexpected_last			    pub fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> 
unflatten			pub fn unflatten(tts: Vec<TokenTree>) -> Vec<TokenTree> 
unicode_chars			mod unicode_chars;
unwrap			    pub fn unwrap(self) -> T 
unwrap_or_abort			    fn unwrap_or_abort(&mut self, res: Result<TokenAndSpan, ()>) -> TokenAndSpan 
util			pub mod util 
val_to_string			    pub fn val_to_string(&self, val: i128) -> String 
val_to_string			    pub fn val_to_string(&self, val: u128) -> String 
value_str			    pub fn value_str(&self) -> Option<Symbol> 
variant			    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant 
variant			    fn variant(&self, span: Span, name: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant;
variant_to_string			pub fn variant_to_string(var: &ast::Variant) -> String 
vertical_trim			    fn vertical_trim(lines: Vec<String>) -> Vec<String> 
vis_to_string			pub fn vis_to_string(v: &ast::Visibility) -> String 
visibility_qualified			pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String 
visit			pub mod visit;
visit_arm			    fn visit_arm(&mut self, a: &Arm) 
visit_arm			    fn visit_arm(&mut self, a: &'ast Arm) { walk_arm(self, a) }
visit_assoc_type_binding			    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) 
visit_assoc_type_binding			    fn visit_assoc_type_binding(&mut self, type_binding: &'ast TypeBinding) 
visit_attribute			    fn visit_attribute(&mut self, attr: &ast::Attribute) 
visit_attribute			    fn visit_attribute(&mut self, _attr: &Attribute) 
visit_attribute			    fn visit_attribute(&mut self, _attr: &'ast Attribute) {}
visit_block			    fn visit_block(&mut self, b: &Block) 
visit_block			    fn visit_block(&mut self, b: &'ast Block) { walk_block(self, b) }
visit_enum_def			    fn visit_enum_def(&mut self, enum_definition: &EnumDef,
visit_enum_def			    fn visit_enum_def(&mut self, enum_definition: &'ast EnumDef,
visit_expansion			    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}
visit_expansion			    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);
visit_expr			    fn visit_expr(&mut self, e: &'a ast::Expr) 
visit_expr			    fn visit_expr(&mut self, e: &'a ast::Expr) 
visit_expr			    fn visit_expr(&mut self, ex: &Expr) 
visit_expr			    fn visit_expr(&mut self, ex: &'ast Expr) { walk_expr(self, ex) }
visit_expr_attrs			    fn visit_expr_attrs(&mut self, attrs: &[ast::Attribute]) 
visit_expr_post			    fn visit_expr_post(&mut self, _ex: &'ast Expr) { }
visit_fn			    fn visit_fn(&mut self,
visit_fn			    fn visit_fn(&mut self, fk: FnKind, fd: &FnDecl, s: Span, _: NodeId) 
visit_fn			    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl, s: Span, _: NodeId) 
visit_fn_ret_ty			    fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) 
visit_fn_ret_ty			    fn visit_fn_ret_ty(&mut self, ret_ty: &'ast FunctionRetTy) 
visit_foreign_item			    fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) 
visit_foreign_item			    fn visit_foreign_item(&mut self, i: &ForeignItem) 
visit_foreign_item			    fn visit_foreign_item(&mut self, i: &'ast ForeignItem) { walk_foreign_item(self, i) }
visit_generics			    fn visit_generics(&mut self, g: &'a ast::Generics) 
visit_generics			    fn visit_generics(&mut self, g: &Generics) 
visit_generics			    fn visit_generics(&mut self, g: &'ast Generics) { walk_generics(self, g) }
visit_global_asm			    fn visit_global_asm(&mut self, ga: &'ast GlobalAsm) { walk_global_asm(self, ga) }
visit_ident			    fn visit_ident(&mut self, span: Span, ident: Ident) 
visit_ident			    fn visit_ident(&mut self, span: Span, ident: Ident) 
visit_impl_item			    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) 
visit_impl_item			    fn visit_impl_item(&mut self, ii: &ImplItem) 
visit_impl_item			    fn visit_impl_item(&mut self, ii: &'ast ImplItem) { walk_impl_item(self, ii) }
visit_item			    fn visit_item(&mut self, i: &'a ast::Item) 
visit_item			    fn visit_item(&mut self, i: &Item) 
visit_item			    fn visit_item(&mut self, i: &'ast Item) { walk_item(self, i) }
visit_lifetime			    fn visit_lifetime(&mut self, lifetime: &Lifetime) 
visit_lifetime			    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) 
visit_lifetime_def			    fn visit_lifetime_def(&mut self, lifetime_def: &'a ast::LifetimeDef) 
visit_lifetime_def			    fn visit_lifetime_def(&mut self, lifetime: &LifetimeDef) 
visit_lifetime_def			    fn visit_lifetime_def(&mut self, lifetime: &'ast LifetimeDef) 
visit_local			    fn visit_local(&mut self, l: &Local) 
visit_local			    fn visit_local(&mut self, l: &'ast Local) { walk_local(self, l) }
visit_mac			    fn visit_mac(&mut self, mac: &'a ast::Mac) 
visit_mac			    fn visit_mac(&mut self, _mac: &Mac) 
visit_mac			    fn visit_mac(&mut self, _mac: &'ast Mac) 
visit_mac_def			    fn visit_mac_def(&mut self, _mac: &'ast MacroDef, _id: NodeId) 
visit_mod			    fn visit_mod(&mut self, m: &Mod, _s: Span, _a: &[Attribute], _n: NodeId) 
visit_mod			    fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) 
visit_name			    fn visit_name(&mut self, sp: Span, name: ast::Name) 
visit_name			    fn visit_name(&mut self, _span: Span, _name: Name) 
visit_pat			    fn visit_pat(&mut self, pattern: &'a ast::Pat) 
visit_pat			            fn visit_pat(&mut self, p: &'a ast::Pat) 
visit_pat			    fn visit_pat(&mut self, p: &'a ast::Pat) 
visit_pat			    fn visit_pat(&mut self, p: &Pat) 
visit_pat			    fn visit_pat(&mut self, p: &'ast Pat) { walk_pat(self, p) }
visit_path			    fn visit_path(&mut self, path: &Path, _id: NodeId) 
visit_path			    fn visit_path(&mut self, path: &'ast Path, _id: NodeId) 
visit_path_list_item			    fn visit_path_list_item(&mut self, prefix: &Path, item: &PathListItem) 
visit_path_list_item			    fn visit_path_list_item(&mut self, prefix: &'ast Path, item: &'ast PathListItem) 
visit_path_parameters			    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &PathParameters) 
visit_path_parameters			    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'ast PathParameters) 
visit_path_segment			    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) 
visit_poly_trait_ref			    fn visit_poly_trait_ref(&mut self, t: &PolyTraitRef, m: &TraitBoundModifier) 
visit_poly_trait_ref			    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) 
visit_stmt			    fn visit_stmt(&mut self, s: &Stmt) 
visit_stmt			    fn visit_stmt(&mut self, s: &'ast Stmt) { walk_stmt(self, s) }
visit_struct_field			    fn visit_struct_field(&mut self, s: &StructField) 
visit_struct_field			    fn visit_struct_field(&mut self, s: &'ast StructField) { walk_struct_field(self, s) }
visit_trait_item			    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) 
visit_trait_item			    fn visit_trait_item(&mut self, ti: &TraitItem) 
visit_trait_item			    fn visit_trait_item(&mut self, ti: &'ast TraitItem) { walk_trait_item(self, ti) }
visit_trait_ref			    fn visit_trait_ref(&mut self, t: &TraitRef) 
visit_trait_ref			    fn visit_trait_ref(&mut self, t: &'ast TraitRef) { walk_trait_ref(self, t) }
visit_ty			    fn visit_ty(&mut self, ty: &'a ast::Ty) 
visit_ty			    fn visit_ty(&mut self, t: &'a ast::Ty) 
visit_ty			    fn visit_ty(&mut self, t: &Ty) 
visit_ty			    fn visit_ty(&mut self, t: &'ast Ty) { walk_ty(self, t) }
visit_ty_param_bound			    fn visit_ty_param_bound(&mut self, bounds: &TyParamBound) 
visit_ty_param_bound			    fn visit_ty_param_bound(&mut self, bounds: &'ast TyParamBound) 
visit_variant			    fn visit_variant(&mut self, v: &Variant, g: &Generics, item_id: NodeId) 
visit_variant			    fn visit_variant(&mut self, v: &'ast Variant, g: &'ast Generics, item_id: NodeId) 
visit_variant_data			    fn visit_variant_data(&mut self, s: &VariantData, _: Ident,
visit_variant_data			    fn visit_variant_data(&mut self, s: &'ast VariantData, _: Ident,
visit_vis			    fn visit_vis(&mut self, vis: &'ast Visibility) 
visit_where_predicate			    fn visit_where_predicate(&mut self, p: &'ast WherePredicate) 
visit_with			            pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) 
walk			    pub fn walk<F>(&self, it: &mut F) -> bool
walk_arm			pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) 
walk_assoc_type_binding			pub fn walk_assoc_type_binding<'a, V: Visitor<'a>>(visitor: &mut V,
walk_block			pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) 
walk_crate			pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) 
walk_enum_def			pub fn walk_enum_def<'a, V: Visitor<'a>>(visitor: &mut V,
walk_expr			pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) 
walk_fn			pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl, _span: Span)
walk_fn_decl			pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) 
walk_fn_ret_ty			pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionRetTy) 
walk_foreign_item			pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a ForeignItem) 
walk_generics			pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics) 
walk_global_asm			pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) 
walk_ident			pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident) 
walk_impl_item			pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplItem) 
walk_item			pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) 
walk_lifetime			pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) 
walk_lifetime_def			pub fn walk_lifetime_def<'a, V: Visitor<'a>>(visitor: &mut V, lifetime_def: &'a LifetimeDef) 
walk_local			pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) 
walk_mac			pub fn walk_mac<'a, V: Visitor<'a>>(_: &mut V, _: &Mac) 
walk_mod			pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) 
walk_opt_ident			pub fn walk_opt_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) 
walk_opt_name			pub fn walk_opt_name<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, opt_name: Option<Name>) 
walk_opt_sp_ident			pub fn walk_opt_sp_ident<'a, V: Visitor<'a>>(visitor: &mut V,
walk_pat			pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) 
walk_path			pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) 
walk_path_list_item			pub fn walk_path_list_item<'a, V: Visitor<'a>>(visitor: &mut V,
walk_path_parameters			pub fn walk_path_parameters<'a, V>(visitor: &mut V,
walk_path_segment			pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,
walk_poly_trait_ref			pub fn walk_poly_trait_ref<'a, V>(visitor: &mut V,
walk_stmt			pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) 
walk_struct_def			pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &'a VariantData) 
walk_struct_field			pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) 
walk_trait_item			pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a TraitItem) 
walk_trait_ref			pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitRef) 
walk_ty			pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) 
walk_ty_param_bound			pub fn walk_ty_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a TyParamBound) 
walk_variant			pub fn walk_variant<'a, V>(visitor: &mut V,
walk_vis			pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) 
walk_where_predicate			pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) 
warn			    pub fn warn(&self, m: &str) 
warn_missing_semicolon			    fn warn_missing_semicolon(&self) 
wb			    fn wb() -> c_int { O_WRONLY as c_int }
wb			    fn wb() -> c_int 
where_clause_to_string			pub fn where_clause_to_string(i: &ast::WhereClause) -> String 
with_desugared_doc			    pub fn with_desugared_doc<T, F>(&self, f: F) -> T where
with_error_checking_parse			fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where
with_file_loader			    pub fn with_file_loader(file_loader: Box<FileLoader>,
with_registered_diagnostics			fn with_registered_diagnostics<T, F>(f: F) -> T where
with_res			    pub fn with_res<F, T>(&mut self, r: Restrictions, f: F) -> T
with_span_handler			    pub fn with_span_handler(handler: Handler, code_map: Rc<CodeMap>) -> ParseSess 
with_str_from			    pub fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T
with_str_from_to			    fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T
word			    pub fn word(&self) -> Option<&MetaItem> 
word			    pub fn word(&mut self, wrd: &str) -> io::Result<()> 
word_nbsp			    pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> 
word_space			    fn word_space(&mut self, w: &str) -> io::Result<()> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
writer			    fn writer(&mut self) -> &mut pp::Printer<'a> 
writer			    fn writer(&mut self) -> &mut pp::Printer<'a>;
zero_word			    pub fn zero_word(&mut self, wrd: &str) -> io::Result<()> 
zerobreak			    pub fn zerobreak(&mut self) -> io::Result<()> 
