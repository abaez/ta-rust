A			    struct A;
Bar			        struct Bar;
Bytes			struct Bytes<'a>(&'a [u8]);
CrazyIterator			    impl CrazyIterator { fn new() -> CrazyIterator { CrazyIterator(false) } }
CrazyIterator			    struct CrazyIterator(bool);
Custom			struct Custom { hash: u64 }
CustomHasher			struct CustomHasher { output: u64 }
Default for CustomHasher			impl Default for CustomHasher 
Default for MyHasher			impl Default for MyHasher 
DoubleEndedIterator for CrazyIterator			    impl DoubleEndedIterator for CrazyIterator 
Drop for HasDtor			impl Drop for HasDtor 
Drop for R			        impl Drop for R 
Foo			        struct Foo;
Foo			    trait Foo { fn dummy(&self) { } }
Foo for isize			    impl Foo for isize {}
HasDtor			struct HasDtor 
Hash for Bytes			impl<'a> Hash for Bytes<'a> 
Hash for Custom			impl Hash for Custom 
Hasher for CustomHasher			impl Hasher for CustomHasher 
Hasher for MyHasher			impl Hasher for MyHasher 
Iterator for CrazyIterator			    impl Iterator for CrazyIterator 
MyHasher			struct MyHasher 
Pair			        struct Pair 
PartialEq for SketchyNum			    impl PartialEq for SketchyNum 
R			    struct R 
SketchyNum			    struct SketchyNum 
Struct			struct Struct 
Test			struct Test;
TestableFloat			trait TestableFloat : DecodableFloat + fmt::Display 
TestableFloat for f32			impl TestableFloat for f32 
TestableFloat for f64			impl TestableFloat for f64 
Trait			trait Trait 
Trait for Struct			impl Trait for Struct 
X			    impl X 
X			    struct X(RefCell<(u32, char)>);
X			    struct X(RefCell<Result<u32, ()>>);
X			    struct X(str); struct Y(Z + 'static);
X			    struct X; struct Y(u32);
Z			    trait Z {}
accessor			        fn accessor(&self) -> Option<Ref<u32>> 
accessor			        fn accessor(&self) -> Option<RefMut<u32>> 
accessor			        fn accessor(&self) -> Ref<u32> 
accessor			        fn accessor(&self) -> RefMut<u32> 
add			    fn add(old: &mut isize, new: &usize) -> Option<f64> 
align_of_32			fn align_of_32() 
align_of_64			fn align_of_64() 
align_of_basic			fn align_of_basic() 
align_of_val_basic			fn align_of_val_basic() 
alloc_obj_with_dtor			fn alloc_obj_with_dtor(b: &mut Bencher) 
any			mod any;
any_downcast_mut			fn any_downcast_mut() 
any_downcast_ref			fn any_downcast_ref() 
any_fixed_vec			fn any_fixed_vec() 
any_owning			fn any_owning() 
any_referenced			fn any_referenced() 
any_unsized			fn any_unsized() 
array			mod array;
as_unsafe_cell			fn as_unsafe_cell() 
atomic			mod atomic;
bench_0			fn bench_0(b: &mut test::Bencher) 
bench_1e150			fn bench_1e150(b: &mut test::Bencher) 
bench_42			fn bench_42(b: &mut test::Bencher) 
bench_big_exact_12			fn bench_big_exact_12(b: &mut Bencher) 
bench_big_exact_12			fn bench_big_exact_12(b: &mut Bencher) 
bench_big_exact_3			fn bench_big_exact_3(b: &mut Bencher) 
bench_big_exact_3			fn bench_big_exact_3(b: &mut Bencher) 
bench_big_exact_inf			fn bench_big_exact_inf(b: &mut Bencher) 
bench_big_exact_inf			fn bench_big_exact_inf(b: &mut Bencher) 
bench_big_shortest			fn bench_big_shortest(b: &mut Bencher) 
bench_big_shortest			fn bench_big_shortest(b: &mut Bencher) 
bench_bytes_4			fn bench_bytes_4(b: &mut Bencher) 
bench_bytes_7			fn bench_bytes_7(b: &mut Bencher) 
bench_bytes_8			fn bench_bytes_8(b: &mut Bencher) 
bench_bytes_a_16			fn bench_bytes_a_16(b: &mut Bencher) 
bench_bytes_b_32			fn bench_bytes_b_32(b: &mut Bencher) 
bench_bytes_c_128			fn bench_bytes_c_128(b: &mut Bencher) 
bench_downcast_ref			fn bench_downcast_ref(b: &mut Bencher) 
bench_huge_int			fn bench_huge_int(b: &mut test::Bencher) 
bench_long_decimal_and_exp			fn bench_long_decimal_and_exp(b: &mut test::Bencher) 
bench_long_str			fn bench_long_str(b: &mut Bencher) 
bench_max			fn bench_max(b: &mut Bencher) 
bench_max			fn bench_max(b: &mut test::Bencher) 
bench_max_by_key			fn bench_max_by_key(b: &mut Bencher) 
bench_max_by_key2			fn bench_max_by_key2(b: &mut Bencher) 
bench_min_normal			fn bench_min_normal(b: &mut test::Bencher) 
bench_min_subnormal			fn bench_min_subnormal(b: &mut test::Bencher) 
bench_multiple_take			fn bench_multiple_take(b: &mut Bencher) 
bench_pi_long			fn bench_pi_long(b: &mut test::Bencher) 
bench_pi_short			fn bench_pi_short(b: &mut test::Bencher) 
bench_rposition			fn bench_rposition(b: &mut Bencher) 
bench_short_decimal			fn bench_short_decimal(b: &mut test::Bencher) 
bench_skip_while			fn bench_skip_while(b: &mut Bencher) 
bench_small_exact_12			fn bench_small_exact_12(b: &mut Bencher) 
bench_small_exact_12			fn bench_small_exact_12(b: &mut Bencher) 
bench_small_exact_3			fn bench_small_exact_3(b: &mut Bencher) 
bench_small_exact_3			fn bench_small_exact_3(b: &mut Bencher) 
bench_small_exact_inf			fn bench_small_exact_inf(b: &mut Bencher) 
bench_small_exact_inf			fn bench_small_exact_inf(b: &mut Bencher) 
bench_small_shortest			fn bench_small_shortest(b: &mut Bencher) 
bench_small_shortest			fn bench_small_shortest(b: &mut Bencher) 
bench_str_of_8_bytes			fn bench_str_of_8_bytes(b: &mut Bencher) 
bench_str_over_8_bytes			fn bench_str_over_8_bytes(b: &mut Bencher) 
bench_str_under_8_bytes			fn bench_str_under_8_bytes(b: &mut Bencher) 
bench_u32			fn bench_u32(b: &mut Bencher) 
bench_u32_keyed			fn bench_u32_keyed(b: &mut Bencher) 
bench_u64			fn bench_u64(b: &mut Bencher) 
bignum			mod bignum;
bool_			fn bool_() 
bool_and			fn bool_and() 
borderline_overflow			fn borderline_overflow() 
builders			mod builders;
cell			mod cell;
cell_default			fn cell_default() 
cell_has_sensible_show			fn cell_has_sensible_show() 
char			mod char;
check			    fn check(c: char) 
check			    fn check(input: char, expect: &[u16]) 
check			    fn check(input: char, expect: &[u8]) 
check			    fn check(s: &[u16], expected: &[Result<char, u16>]) 
check_exact			fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)
check_exact_one			fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)
clone			mod clone;
cmp			mod cmp;
conv			    fn conv(sig: u64) -> u64 
debug_list			mod debug_list 
debug_map			mod debug_map 
debug_set			mod debug_set 
debug_struct			mod debug_struct 
debug_tuple			mod debug_tuple 
dec2flt			mod dec2flt;
decode_finite			pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded 
default			    fn default() -> CustomHasher 
default			    fn default() -> MyHasher 
discard_doesnt_unborrow			fn discard_doesnt_unborrow() 
div_rem			    fn div_rem(n: u64, d: u64) -> (Big, Big) 
double_borrow_single_release_no_borrow_mut			fn double_borrow_single_release_no_borrow_mut() 
double_imm_borrow			fn double_imm_borrow() 
dragon			    mod dragon;
drop			    fn drop(&mut self) 
drop			       fn drop(&mut self) 
ed_iterator_specializations			fn ed_iterator_specializations() 
eq			        fn eq(&self, other: &SketchyNum) -> bool 
estimator			mod estimator;
eu_iterator_specializations			fn eu_iterator_specializations() 
exact_f32_random_equivalence_test			fn exact_f32_random_equivalence_test() 
exact_f64_random_equivalence_test			fn exact_f64_random_equivalence_test() 
exact_sanity_test			fn exact_sanity_test() 
exact_sanity_test			fn exact_sanity_test() 
f			    fn f(xy: &(isize, char)) -> bool { let (_x, y) = *xy; y == 'b' }
f32_exact_sanity_test			pub fn f32_exact_sanity_test<F>(mut f: F)
f32_exhaustive_equivalence_test			pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)
f32_random_equivalence_test			pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)
f32_shortest_sanity_test			pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) 
f64_exact_sanity_test			pub fn f64_exact_sanity_test<F>(mut f: F)
f64_random_equivalence_test			pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)
f64_shortest_sanity_test			pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) 
fast_path_correct			fn fast_path_correct() 
finish			    fn finish(&self) -> u64 { self.hash }
finish			    fn finish(&self) -> u64 { self.output }
fixed_size_array			fn fixed_size_array() 
float			mod float;
flt2dec			mod flt2dec;
fmt			            fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			mod fmt;
fmt::Debug for Bar			        impl fmt::Debug for Bar 
fmt::Debug for Foo			        impl fmt::Debug for Foo 
fp_to_float_half_to_even			fn fp_to_float_half_to_even() 
from_str			        fn from_str<T: ::std::str::FromStr>(t: &str) -> Option<T> 
from_str			    fn from_str<T: FromStr>(t: &str) -> Option<T> 
from_str_issue7588			fn from_str_issue7588() 
g			    fn g(xy: &(isize, char)) -> bool { let (_x, y) = *xy; y == 'd' }
grisu			    mod grisu;
handler			    fn handler(msg: &'static str) -> isize 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<T: Hash>(t: &T) -> u64 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			fn hash<T: Hash>(x: &T) -> u64 
hash			mod hash;
hash_bytes			fn hash_bytes(x: &[u8]) -> u64 
hash_with_keys			fn hash_with_keys<T: Hash>(k1: u64, k2: u64, x: &T) -> u64 
human_f64_roundtrip			fn human_f64_roundtrip() 
i16			mod i16;
i32			mod i32;
i64			mod i64;
i8			mod i8;
imm_release_borrow_mut			fn imm_release_borrow_mut() 
inf			fn inf() 
infinity			fn infinity() 
int_and			fn int_and() 
int_macros			mod int_macros;
int_or			fn int_or() 
int_xor			fn int_xor() 
integers_to_f64			fn integers_to_f64() 
intrinsics			mod intrinsics;
invalid_chars			fn invalid_chars() 
is_any			    fn is_any<T: Any + ?Sized>() {}
is_normalized			    fn is_normalized(sig: u64) -> bool 
iter			mod iter;
iterate			fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)
large			fn large() 
ldexpi			    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }
ldexpi			    fn ldexpi(f: i64, exp: isize) -> Self;
lonely_dot			fn lonely_dot() 
lonely_sign			fn lonely_sign() 
lower			    fn lower(c: char) -> Vec<char> 
massive_exponent			fn massive_exponent() 
match_option_some			fn match_option_some(b: &mut Bencher) 
match_vec_pattern			fn match_vec_pattern(b: &mut Bencher) 
max_index_iter			    fn max_index_iter(array: &[i32]) -> usize 
mem			mod mem;
method			    fn method(&self) -> isize 
method			    fn method(&self) -> isize;
missing_pieces			fn missing_pieces() 
more_shortest_sanity_test			pub fn more_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) 
mut_release_borrow_mut			fn mut_release_borrow_mut() 
nan			fn nan() 
next			        fn next(&mut self) -> Option<i32> 
next_back			        fn next_back(&mut self) -> Option<i32> 
next_float_inf			fn next_float_inf() 
next_float_monotonic			fn next_float_monotonic() 
next_float_subnormal			fn next_float_subnormal() 
next_float_zero			fn next_float_zero() 
next_prev_identity			fn next_prev_identity() 
no_double_borrow_mut			fn no_double_borrow_mut() 
no_imm_then_borrow_mut			fn no_imm_then_borrow_mut() 
no_mut_then_imm_borrow			fn no_mut_then_imm_borrow() 
nonzero			mod nonzero;
num			mod num;
num			mod num;
op1			fn op1() -> Result<isize, &'static str> { Ok(666) }
op2			fn op2() -> Result<isize, &'static str> { Err("sadface") }
ops			mod ops;
option			mod option;
ordinary			fn ordinary() 
parse			mod parse;
prev_float_monotonic			fn prev_float_monotonic() 
ptr			mod ptr;
r			    fn r(i: Rc<RefCell<isize>>) -> R 
rawfp			mod rawfp;
ref_and_refmut_have_sensible_show			fn ref_and_refmut_have_sensible_show() 
ref_clone_updates_flag			fn ref_clone_updates_flag() 
ref_filter_map_accessor			fn ref_filter_map_accessor() 
ref_map_accessor			fn ref_map_accessor() 
ref_map_does_not_update_flag			fn ref_map_does_not_update_flag() 
ref_mut_filter_map_accessor			fn ref_mut_filter_map_accessor() 
ref_mut_map_accessor			fn ref_mut_map_accessor() 
refcell_default			fn refcell_default() 
refcell_ref_coercion			fn refcell_ref_coercion() 
refcell_unsized			fn refcell_unsized() 
result			mod result;
rounding_overflow			fn rounding_overflow() 
scatter			fn scatter(x: i32) -> i32 { (x * 31) % 127 }
shortest_f32_exhaustive_equivalence_test			fn shortest_f32_exhaustive_equivalence_test() 
shortest_f64_hard_random_equivalence_test			fn shortest_f64_hard_random_equivalence_test() 
shortest_random_equivalence_test			fn shortest_random_equivalence_test() 
shortest_sanity_test			fn shortest_sanity_test() 
shortest_sanity_test			fn shortest_sanity_test() 
sip			mod sip;
size_of_32			fn size_of_32() 
size_of_64			fn size_of_64() 
size_of_basic			fn size_of_basic() 
size_of_val_basic			fn size_of_val_basic() 
slice			mod slice;
smoketest_cell			fn smoketest_cell() 
special_code_paths			fn special_code_paths() 
static_init			fn static_init() 
str			mod str;
strategy			mod strategy 
string			    fn string(c: char) -> String { c.escape_unicode().collect() }
string			    fn string(c: char) -> String 
subnormals			fn subnormals() 
test			fn test() 
tests			mod tests 
tests			mod tests 
to_exact_exp_str_test			pub fn to_exact_exp_str_test<F>(mut f_: F)
to_exact_fixed_str_test			pub fn to_exact_fixed_str_test<F>(mut f_: F)
to_shortest_exp_str_test			pub fn to_shortest_exp_str_test<F>(mut f_: F)
to_shortest_str_test			pub fn to_shortest_str_test<F>(mut f_: F)
to_string			    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, exp_bounds: (i16, i16), upper: bool) -> String
to_string			    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String
to_string			    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, ndigits: usize, upper: bool) -> String
to_string_with_parts			fn to_string_with_parts<F>(mut f: F) -> String
trait_static_method_call			fn trait_static_method_call(b: &mut Bencher) 
trait_vtable_method_call			fn trait_vtable_method_call(b: &mut Bencher) 
tuple			mod tuple;
u16			mod u16;
u32			mod u32;
u64			mod u64;
u8			mod u8;
uint_and			fn uint_and() 
uint_macros			mod uint_macros;
uint_or			fn uint_or() 
uint_xor			fn uint_xor() 
unsafe_cell_unsized			fn unsafe_cell_unsized() 
upper			    fn upper(c: char) -> Vec<char> 
valid			fn valid() 
whitespace			fn whitespace() 
write			    fn write(&mut self, _: &[u8]) { panic!() }
write			    fn write(&mut self, buf: &[u8]) 
write_u64			    fn write_u64(&mut self, data: u64) { self.output = data; }
zero			fn zero() 
zero_byte			    fn zero_byte(val: u32, byte: usize) -> u32 
zero_byte			    fn zero_byte(val: u64, byte: usize) -> u64 
