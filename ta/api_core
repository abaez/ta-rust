Adapter			        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);
Adapter			        struct Adapter<Iter> 
Adapter			        struct Adapter<Iter, E> 
Add			        impl Add for 
Add			pub trait Add<RHS=Self> 
Add for Wrapping			        impl Add for Wrapping<
Alignment			pub enum Alignment 
Any			impl Any 
Any			impl Any+Send 
Any			pub trait Any: Reflect + 'static 
Any for T			impl<T: Reflect + 'static> Any for T 
Argument			pub struct Argument 
ArgumentV1			impl<'a> ArgumentV1<'a> 
ArgumentV1			pub struct ArgumentV1<'a> 
Arguments			impl<'a> Arguments<'a> 
Arguments			pub struct Arguments<'a> 
AsMut			            impl<T> AsMut<[T]> for [T; 
AsMut			impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> 
AsMut			impl<T> AsMut<[T]> for [T] 
AsMut			pub trait AsMut<T: ?Sized> 
AsRef			            impl<T> AsRef<[T]> for [T; 
AsRef			impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U> 
AsRef			impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> 
AsRef			impl<T> AsRef<[T]> for [T] 
AsRef			pub trait AsRef<T: ?Sized> 
AsRef for str			impl AsRef<str> for str 
AsRef for str			impl AsRef<[u8]> for str 
AtomicBool			impl AtomicBool 
AtomicBool			pub struct AtomicBool 
AtomicIsize			impl AtomicIsize 
AtomicIsize			pub struct AtomicIsize 
AtomicPtr			impl<T> AtomicPtr<T> 
AtomicPtr			pub struct AtomicPtr<T> 
AtomicUsize			impl AtomicUsize 
AtomicUsize			pub struct AtomicUsize 
Binary			pub trait Binary 
Binary			struct Binary;
BitAnd			        impl BitAnd for 
BitAnd			pub trait BitAnd<RHS=Self> 
BitAnd for Wrapping			        impl BitAnd for Wrapping<
BitOr			        impl BitOr for 
BitOr			pub trait BitOr<RHS=Self> 
BitOr for Wrapping			        impl BitOr for Wrapping<
BitXor			        impl BitXor for 
BitXor			pub trait BitXor<RHS=Self> 
BitXor for Wrapping			        impl BitXor for Wrapping<
BorrowRef			impl<'b> BorrowRef<'b> 
BorrowRef			struct BorrowRef<'b> 
BorrowRefMut			impl<'b> BorrowRefMut<'b> 
BorrowRefMut			struct BorrowRefMut<'b> 
BorrowState			pub enum BorrowState 
Bytes			pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);
BytesDeref			struct BytesDeref;
Cell			impl<T:Copy> Cell<T> 
Cell			pub struct Cell<T> 
Chain			pub struct Chain<A, B> 
CharEq			impl<'a> CharEq for &'a [char] 
CharEq			trait CharEq 
CharEq for F			impl<F> CharEq for F where F: FnMut(char) -> bool 
CharEq for char			impl CharEq for char 
CharEqPattern			struct CharEqPattern<C: CharEq>(C);
CharEqSearcher			struct CharEqSearcher<'a, C: CharEq> 
CharExt			pub trait CharExt 
CharExt for char			impl CharExt for char 
CharIndices			pub struct CharIndices<'a> 
CharPredicateSearcher			pub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)
CharRange			pub struct CharRange 
CharSearcher			pub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);
CharSliceSearcher			pub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);
Chars			pub struct Chars<'a> 
Chunks			pub struct Chunks<'a, T:'a> 
ChunksMut			pub struct ChunksMut<'a, T:'a> 
Clone			            impl<T:Copy> Clone for [T; 
Clone			        impl Clone for 
Clone			impl<'a, T: ?Sized> Clone for &'a T 
Clone			pub trait Clone : Sized 
Clone			        impl<T:?Sized> Clone for 
Clone			impl<T: ?Sized> Clone for *const T 
Clone			impl<T: ?Sized> Clone for *mut T 
Clone			            impl<
Clone for ArgumentV1			impl<'a> Clone for ArgumentV1<'a> 
Clone for BorrowRef			impl<'b> Clone for BorrowRef<'b> 
Clone for Cell			impl<T:Copy> Clone for Cell<T> 
Clone for Chunks			impl<'a, T> Clone for Chunks<'a, T> 
Clone for Empty			impl<T> Clone for Empty<T> 
Clone for Iter			impl<'a, A> Clone for Iter<'a, A> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Peekable			impl<I: Iterator + Clone> Clone for Peekable<I> where I::Item: Clone 
Clone for RefCell			impl<T: Clone> Clone for RefCell<T> 
Clone for SipHasher			impl Clone for SipHasher 
Clone for Slice			impl<T> Clone for Slice<T> 
Clone for Split			impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool 
Clone for Windows			impl<'a, T> Clone for Windows<'a, T> 
Clone for extern			        impl<
Clone for extern			        impl<
Clone for unsafe			        impl<
Clone for unsafe			        impl<
Cloned			pub struct Cloned<I> 
CoerceUnsized			pub trait CoerceUnsized<T> 
Copy			        impl<T:?Sized> Copy for 
Copy			pub trait Copy : Clone 
Copy for Slice			impl<T> Copy for Slice<T> {}
Count			pub enum Count 
Cycle			pub struct Cycle<I> 
Debug			        impl<
Debug			    impl Debug for 
Debug			impl Debug for () 
Debug			impl<T: Debug> Debug for [T] 
Debug			impl<T> Debug for *const T 
Debug			impl<T> Debug for *mut T 
Debug			pub trait Debug 
Debug for Arguments			impl<'a> Debug for Arguments<'a> 
Debug for Cell			impl<T: Copy + Debug> Debug for Cell<T> 
Debug for PhantomData			impl<T> Debug for PhantomData<T> 
Debug for Ref			impl<'b, T: ?Sized + Debug> Debug for Ref<'b, T> 
Debug for RefCell			impl<T: ?Sized + Debug> Debug for RefCell<T> 
Debug for RefMut			impl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> 
Debug for bool			impl Debug for bool 
Debug for char			impl Debug for char 
Debug for str			impl Debug for str 
DebugInner			impl<'a, 'b: 'a> DebugInner<'a, 'b> 
DebugInner			struct DebugInner<'a, 'b: 'a> 
DebugList			impl<'a, 'b: 'a> DebugList<'a, 'b> 
DebugList			pub struct DebugList<'a, 'b: 'a> 
DebugMap			impl<'a, 'b: 'a> DebugMap<'a, 'b> 
DebugMap			pub struct DebugMap<'a, 'b: 'a> 
DebugSet			impl<'a, 'b: 'a> DebugSet<'a, 'b> 
DebugSet			pub struct DebugSet<'a, 'b: 'a> 
DebugStruct			impl<'a, 'b: 'a> DebugStruct<'a, 'b> 
DebugStruct			pub struct DebugStruct<'a, 'b: 'a> 
DebugTuple			impl<'a, 'b: 'a> DebugTuple<'a, 'b> 
DebugTuple			pub struct DebugTuple<'a, 'b: 'a> 
Decimal			struct Decimal;
DecodableFloat			pub trait DecodableFloat: Float + Copy 
DecodableFloat for f32			impl DecodableFloat for f32 
DecodableFloat for f64			impl DecodableFloat for f64 
Decoded			pub struct Decoded 
Default			        impl Default for 
Default			pub trait Default 
Default			impl<'a, T> Default for &'a [T] 
Default			impl<'a> Default for &'a str 
Default			            impl<
Default for AtomicBool			impl Default for AtomicBool 
Default for AtomicIsize			impl Default for AtomicIsize 
Default for AtomicPtr			impl<T> Default for AtomicPtr<T> 
Default for AtomicUsize			impl Default for AtomicUsize 
Default for Cell			impl<T:Default + Copy> Default for Cell<T> 
Default for Empty			impl<T> Default for Empty<T> 
Default for Option			impl<T> Default for Option<T> 
Default for RefCell			impl<T:Default> Default for RefCell<T> 
Default for SipHasher			impl Default for SipHasher 
Deref			impl<'a, T: ?Sized> Deref for &'a T 
Deref			impl<'a, T: ?Sized> Deref for &'a mut T 
Deref			pub trait Deref 
Deref for NonZero			impl<T: Zeroable> Deref for NonZero<T> 
Deref for Ref			impl<'b, T: ?Sized> Deref for Ref<'b, T> 
Deref for RefMut			impl<'b, T: ?Sized> Deref for RefMut<'b, T> 
Deref for Unique			impl<T:?Sized> Deref for Unique<T> 
DerefMut			impl<'a, T: ?Sized> DerefMut for &'a mut T 
DerefMut			pub trait DerefMut: Deref 
DerefMut for RefMut			impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> 
Display			    impl Display for 
Display			pub trait Display 
Display for Arguments			impl<'a> Display for Arguments<'a> 
Display for Error			impl Display for Error 
Display for bool			impl Display for bool 
Display for char			impl Display for char 
Display for str			impl Display for str 
Div			        impl Div for 
Div			pub trait Div<RHS=Self> 
DoubleEndedIterator			impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I 
DoubleEndedIterator			pub trait DoubleEndedIterator: Iterator 
DoubleEndedIterator			        impl<'a, T> DoubleEndedIterator for 
DoubleEndedIterator for Bytes			impl<'a> DoubleEndedIterator for Bytes<'a> 
DoubleEndedIterator for Chain			impl<A, B> DoubleEndedIterator for Chain<A, B> where
DoubleEndedIterator for CharIndices			impl<'a> DoubleEndedIterator for CharIndices<'a> 
DoubleEndedIterator for Chars			impl<'a> DoubleEndedIterator for Chars<'a> 
DoubleEndedIterator for Chunks			impl<'a, T> DoubleEndedIterator for Chunks<'a, T> 
DoubleEndedIterator for ChunksMut			impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> 
DoubleEndedIterator for Cloned			impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>
DoubleEndedIterator for Empty			impl<T> DoubleEndedIterator for Empty<T> 
DoubleEndedIterator for Enumerate			impl<I> DoubleEndedIterator for Enumerate<I> where
DoubleEndedIterator for Filter			impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>
DoubleEndedIterator for FilterMap			impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>
DoubleEndedIterator for FlatMap			impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where
DoubleEndedIterator for Fuse			impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator 
DoubleEndedIterator for Inspect			impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>
DoubleEndedIterator for IntoIter			impl<A> DoubleEndedIterator for IntoIter<A> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for Item			impl<A> DoubleEndedIterator for Item<A> 
DoubleEndedIterator for Iter			impl<'a, A> DoubleEndedIterator for Iter<'a, A> 
DoubleEndedIterator for Iter			impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
DoubleEndedIterator for IterMut			impl<'a, A> DoubleEndedIterator for IterMut<'a, A> 
DoubleEndedIterator for IterMut			impl<'a, T> DoubleEndedIterator for IterMut<'a, T> 
DoubleEndedIterator for Lines			impl<'a> DoubleEndedIterator for Lines<'a> 
DoubleEndedIterator for LinesAny			impl<'a> DoubleEndedIterator for LinesAny<'a> 
DoubleEndedIterator for Map			impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where
DoubleEndedIterator for Once			impl<T> DoubleEndedIterator for Once<T> 
DoubleEndedIterator for RangeInclusive			impl<A> DoubleEndedIterator for RangeInclusive<A> where
DoubleEndedIterator for Repeat			impl<A: Clone> DoubleEndedIterator for Repeat<A> 
DoubleEndedIterator for Rev			impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator 
DoubleEndedIterator for Split			impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool 
DoubleEndedIterator for SplitMut			impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where
DoubleEndedIterator for Windows			impl<'a, T> DoubleEndedIterator for Windows<'a, T> 
DoubleEndedIterator for Zip			impl<A, B> DoubleEndedIterator for Zip<A, B> where
DoubleEndedIterator for ops			impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where
DoubleEndedSearcher			pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}
DoubleEndedSearcher for CharEqSearcher			impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}
DoubleEndedSearcher for CharPredicateSearcher			impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F>
DoubleEndedSearcher for CharSearcher			impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}
DoubleEndedSearcher for CharSliceSearcher			impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}
Drop			pub trait Drop 
Drop for BorrowRef			impl<'b> Drop for BorrowRef<'b> 
Drop for BorrowRefMut			impl<'b> Drop for BorrowRefMut<'b> 
Empty			pub struct Empty<T>(marker::PhantomData<T>);
Enumerate			pub struct Enumerate<I> 
Eq			            impl<T:Eq> Eq for [T; 
Eq			            impl Eq for 
Eq			    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}
Eq			    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}
Eq			pub trait Eq: PartialEq<Self> 
Eq			impl<T: ?Sized> Eq for *const T {}
Eq			impl<T: ?Sized> Eq for *mut T {}
Eq			impl<T: Eq> Eq for [T] {}
Eq			            impl<
Eq for Cell			impl<T:Eq + Copy> Eq for Cell<T> {}
Eq for Ordering			impl Eq for Ordering {}
Eq for RefCell			impl<T: ?Sized + Eq> Eq for RefCell<T> {}
Eq for str			    impl Eq for str {}
Error			pub struct Error;
EscapeDefault			pub struct EscapeDefault 
EscapeDefaultState			enum EscapeDefaultState 
EscapeUnicode			pub struct EscapeUnicode 
EscapeUnicodeState			enum EscapeUnicodeState 
ExactSizeIterator			impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}
ExactSizeIterator			pub trait ExactSizeIterator: Iterator 
ExactSizeIterator for Bytes			impl<'a> ExactSizeIterator for Bytes<'a> 
ExactSizeIterator for Chunks			impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}
ExactSizeIterator for ChunksMut			impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}
ExactSizeIterator for Cloned			impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>
ExactSizeIterator for Empty			impl<T> ExactSizeIterator for Empty<T> 
ExactSizeIterator for Enumerate			impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}
ExactSizeIterator for Fuse			impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}
ExactSizeIterator for Inspect			impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F> where
ExactSizeIterator for IntoIter			impl<A> ExactSizeIterator for IntoIter<A> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for Item			impl<A> ExactSizeIterator for Item<A> {}
ExactSizeIterator for Iter			impl<'a, A> ExactSizeIterator for Iter<'a, A> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for Map			impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F> where
ExactSizeIterator for Once			impl<T> ExactSizeIterator for Once<T> 
ExactSizeIterator for Peekable			impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}
ExactSizeIterator for Rev			impl<I> ExactSizeIterator for Rev<I>
ExactSizeIterator for Skip			impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}
ExactSizeIterator for Take			impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}
ExactSizeIterator for Windows			impl<'a, T> ExactSizeIterator for Windows<'a, T> {}
ExactSizeIterator for Zip			impl<A, B> ExactSizeIterator for Zip<A, B>
ExactSizeIterator for ops			        impl ExactSizeIterator for ops::Range<
Extend			pub trait Extend<A> 
Filter			pub struct Filter<I, P> 
FilterMap			pub struct FilterMap<I, F> 
FixedSizeArray			            impl<T> FixedSizeArray<T> for [T; 
FixedSizeArray			pub trait FixedSizeArray<T> 
FlagV1			enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }
FlatMap			pub struct FlatMap<I, U: IntoIterator, F> 
Float			pub trait Float 
Float for f32			impl Float for f32 
Float for f64			impl Float for f64 
FloatErrorKind			pub enum FloatErrorKind 
Fn			    impl<'a,A,F:?Sized> Fn<A> for &'a F
Fn			pub trait Fn<Args> : FnMut<Args> 
Fn for BytesDeref			impl<'a> Fn<(&'a u8,)> for BytesDeref 
Fn for LinesAnyMap			impl<'a> Fn<(&'a str,)> for LinesAnyMap 
FnMut			    impl<'a,A,F:?Sized> FnMut<A> for &'a F
FnMut			    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F
FnMut			pub trait FnMut<Args> : FnOnce<Args> 
FnMut for BytesDeref			impl<'a> FnMut<(&'a u8,)> for BytesDeref 
FnMut for LinesAnyMap			impl<'a> FnMut<(&'a str,)> for LinesAnyMap 
FnOnce			    impl<'a,A,F:?Sized> FnOnce<A> for &'a F
FnOnce			    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F
FnOnce			pub trait FnOnce<Args> 
FnOnce for BytesDeref			impl<'a> FnOnce<(&'a u8,)> for BytesDeref 
FnOnce for LinesAnyMap			impl<'a> FnOnce<(&'a str,)> for LinesAnyMap 
FormatSpec			pub struct FormatSpec 
Formatted			impl<'a> Formatted<'a> 
Formatted			pub struct Formatted<'a> 
Formatter			impl<'a> Formatter<'a> 
Formatter			pub struct Formatter<'a> 
Fp			impl Fp 
Fp			pub struct Fp 
FpCategory			pub enum FpCategory 
From			pub trait From<T> 
From for T			impl<T> From<T> for T 
FromIterator			pub trait FromIterator<A> 
FromStr			        impl FromStr for 
FromStr			pub trait FromStr 
FromStr for bool			impl FromStr for bool 
FromStrRadixHelper			trait FromStrRadixHelper: PartialOrd + Copy 
FullDecoded			pub enum FullDecoded 
FullOps			            impl FullOps for 
FullOps			pub trait FullOps 
Fuse			impl<I> Fuse<I> 
Fuse			pub struct Fuse<I> 
GenericRadix			        impl GenericRadix for 
GenericRadix			trait GenericRadix 
GenericRadix for Radix			impl GenericRadix for Radix 
GenericSplitN			struct GenericSplitN<I> 
Hash			            impl<T: Hash> Hash for [T; 
Hash			            impl Hash for 
Hash			            impl Hash for () 
Hash			            impl<
Hash			    impl<'a, T: ?Sized + Hash> Hash for &'a T 
Hash			    impl<'a, T: ?Sized + Hash> Hash for &'a mut T 
Hash			    impl<T: Hash> Hash for [T] 
Hash			    impl<T> Hash for *const T 
Hash			    impl<T> Hash for *mut T 
Hash			pub trait Hash 
Hash			        impl<T:?Sized> Hash for 
Hash for bool			    impl Hash for bool 
Hash for char			    impl Hash for char 
Hash for str			    impl Hash for str 
Hasher			pub trait Hasher 
Hasher for SipHasher			impl Hasher for SipHasher 
Index			pub trait Index<Idx: ?Sized> 
IndexMut			pub trait IndexMut<Idx: ?Sized>: Index<Idx> 
Inspect			impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) 
Inspect			pub struct Inspect<I, F> 
Int			trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +
IntErrorKind			enum IntErrorKind 
IntSliceExt			        impl IntSliceExt<
IntSliceExt			pub trait IntSliceExt<U, S> 
Into			pub trait Into<T>: Sized 
Into for T			impl<T, U> Into<U> for T where U: From<T> 
IntoIter			pub struct IntoIter<A> { inner: Item<A> }
IntoIter			pub struct IntoIter<T> { inner: Option<T> }
IntoIterator			            impl<'a, T> IntoIterator for &'a [T; 
IntoIterator			            impl<'a, T> IntoIterator for &'a mut [T; 
IntoIterator			pub trait IntoIterator 
IntoIterator			impl<'a, T> IntoIterator for &'a [T] 
IntoIterator			impl<'a, T> IntoIterator for &'a mut [T] 
IntoIterator for I			impl<I: Iterator> IntoIterator for I 
IntoIterator for Option			impl<T> IntoIterator for Option<T> 
IntoIterator for Result			impl<T, E> IntoIterator for Result<T, E> 
Item			struct Item<A> 
Iter			pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }
Iter			pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }
Iter			impl<'a, T> Iter<'a, T> 
Iter			pub struct Iter<'a, T: 'a> 
IterMut			pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }
IterMut			pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }
IterMut			impl<'a, T> IterMut<'a, T> 
IterMut			pub struct IterMut<'a, T: 'a> 
Iterator			impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I 
Iterator			pub trait Iterator 
Iterator			        impl<'a, 
Iterator			        impl<'a, T> Iterator for 
Iterator for Bytes			impl<'a> Iterator for Bytes<'a> 
Iterator for Chain			impl<A, B> Iterator for Chain<A, B> where
Iterator for CharIndices			impl<'a> Iterator for CharIndices<'a> 
Iterator for Chars			impl<'a> Iterator for Chars<'a> 
Iterator for Chunks			impl<'a, T> Iterator for Chunks<'a, T> 
Iterator for ChunksMut			impl<'a, T> Iterator for ChunksMut<'a, T> 
Iterator for Cloned			impl<'a, I, T: 'a> Iterator for Cloned<I>
Iterator for Cycle			impl<I> Iterator for Cycle<I> where I: Clone + Iterator 
Iterator for Empty			impl<T> Iterator for Empty<T> 
Iterator for Enumerate			impl<I> Iterator for Enumerate<I> where I: Iterator 
Iterator for EscapeDefault			impl Iterator for EscapeDefault 
Iterator for EscapeUnicode			impl Iterator for EscapeUnicode 
Iterator for Filter			impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool 
Iterator for FilterMap			impl<B, I: Iterator, F> Iterator for FilterMap<I, F>
Iterator for FlatMap			impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>
Iterator for Fuse			impl<I> Iterator for Fuse<I> where I: Iterator 
Iterator for Inspect			impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) 
Iterator for IntoIter			impl<A> Iterator for IntoIter<A> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for Item			impl<A> Iterator for Item<A> 
Iterator for Iter			impl<'a, A> Iterator for Iter<'a, A> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, A> Iterator for IterMut<'a, A> 
Iterator for IterMut			impl<'a, T> Iterator for IterMut<'a, T> 
Iterator for Lines			impl<'a> Iterator for Lines<'a> 
Iterator for LinesAny			impl<'a> Iterator for LinesAny<'a> 
Iterator for Map			impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B 
Iterator for Once			impl<T> Iterator for Once<T> 
Iterator for Peekable			impl<I: Iterator> Iterator for Peekable<I> 
Iterator for RangeInclusive			impl<A> Iterator for RangeInclusive<A> where
Iterator for Repeat			impl<A: Clone> Iterator for Repeat<A> 
Iterator for Rev			impl<I> Iterator for Rev<I> where I: DoubleEndedIterator 
Iterator for Scan			impl<B, I, St, F> Iterator for Scan<I, St, F> where
Iterator for SizeHint			        impl<A> Iterator for SizeHint<A> 
Iterator for Skip			impl<I> Iterator for Skip<I> where I: Iterator 
Iterator for SkipWhile			impl<I: Iterator, P> Iterator for SkipWhile<I, P>
Iterator for Split			impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool 
Iterator for SplitMut			impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
Iterator for StepBy			impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> 
Iterator for StepBy			impl<A> Iterator for StepBy<A, RangeFrom<A>> where
Iterator for Take			impl<I> Iterator for Take<I> where I: Iterator
Iterator for TakeWhile			impl<I: Iterator, P> Iterator for TakeWhile<I, P>
Iterator for Unfold			impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> 
Iterator for Windows			impl<'a, T> Iterator for Windows<'a, T> 
Iterator for Zip			impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator
Iterator for ops			impl<A: Step + One> Iterator for ops::Range<A> where
Iterator for ops			impl<A: Step + One> Iterator for ops::RangeFrom<A> where
Lines			pub struct Lines<'a>(SplitTerminator<'a, char>);
LinesAny			pub struct LinesAny<'a>(Map<Lines<'a>, LinesAnyMap>);
LinesAnyMap			struct LinesAnyMap;
LowerExp			    impl LowerExp for 
LowerExp			pub trait LowerExp 
LowerHex			pub trait LowerHex 
LowerHex			struct LowerHex;
Map			pub struct Map<I, F> 
MatchIndices			        struct MatchIndices;
MatchIndicesInternal			struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);
Matches			        struct Matches;
MatchesInternal			struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);
MinMaxResult			impl<T: Clone> MinMaxResult<T> 
MinMaxResult			pub enum MinMaxResult<T> 
Mul			        impl Mul for 
Mul			pub trait Mul<RHS=Self> 
Mul for Wrapping			        impl Mul for Wrapping<
MutableByteVector			    impl MutableByteVector for [u8] 
MutableByteVector			    pub trait MutableByteVector 
Neg			        impl Neg for 
Neg			pub trait Neg 
NoCopy			pub struct NoCopy;
NonZero			impl<T: Zeroable> NonZero<T> 
NonZero			pub struct NonZero<T: Zeroable>(T);
Not			        impl Not for 
Not			pub trait Not 
Not for Wrapping			        impl Not for Wrapping<
Octal			pub trait Octal 
Octal			struct Octal;
OldMatchIndices			impl<'a, 'b>  OldMatchIndices<'a, 'b> 
OldMatchIndices			struct OldMatchIndices<'a, 'b> 
OldSearcher			enum OldSearcher 
OldSearcher			impl OldSearcher 
Once			pub struct Once<T> 
One			        impl One for 
One			pub trait One 
Option			impl<'a, T: Clone> Option<&'a T> 
Option			impl<T: Default> Option<T> 
Option			impl<T> Option<T> 
Option			pub enum Option<T> 
Ord			            impl<T:Ord> Ord for [T; 
Ord			            impl Ord for 
Ord			    impl Ord for () 
Ord			    impl<'a, A: ?Sized> Ord for &'a A where A: Ord 
Ord			    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord 
Ord			pub trait Ord: Eq + PartialOrd<Self> 
Ord			impl<T: ?Sized> Ord for *const T 
Ord			impl<T: ?Sized> Ord for *mut T 
Ord			impl<T: Ord> Ord for [T] 
Ord			            impl<
Ord for Ordering			impl Ord for Ordering 
Ord for bool			    impl Ord for bool 
Ord for str			    impl Ord for str 
Ordering			pub enum Ordering 
Ordering			impl Ordering 
Ordering			pub enum Ordering 
OverflowingOps			        impl OverflowingOps for 
OverflowingOps			pub trait OverflowingOps 
OverflowingOps for isize			impl OverflowingOps for isize 
OverflowingOps for usize			impl OverflowingOps for usize 
PadAdapter			impl<'a, 'b: 'a> PadAdapter<'a, 'b> 
PadAdapter			struct PadAdapter<'a, 'b: 'a> 
ParseBoolError			pub struct ParseBoolError { _priv: () }
ParseFloatError			impl ParseFloatError 
ParseFloatError			pub struct ParseFloatError 
ParseIntError			impl ParseIntError 
ParseIntError			pub struct ParseIntError { kind: IntErrorKind }
Part			impl<'a> Part<'a> 
Part			pub enum Part<'a> 
PartialEq			            impl PartialEq for 
PartialEq			    impl PartialEq for () 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> 
PartialEq			pub trait PartialEq<Rhs: ?Sized = Self> 
PartialEq			        impl<'a, 'b, A: 
PartialEq			        impl<'a, 'b, A: 
PartialEq			impl<T: ?Sized> PartialEq for *const T 
PartialEq			impl<T: ?Sized> PartialEq for *mut T 
PartialEq			impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> 
PartialEq			            impl<
PartialEq for Cell			impl<T:PartialEq + Copy> PartialEq for Cell<T> 
PartialEq for RefCell			impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> 
PartialEq for extern			            impl<_R,
PartialEq for extern			    impl<_R> PartialEq for extern "C" fn() -> _R 
PartialEq for str			    impl PartialEq for str 
PartialOrd			            impl<T:PartialOrd> PartialOrd for [T; 
PartialOrd			            impl PartialOrd for 
PartialOrd			    impl PartialOrd for () 
PartialOrd			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> 
PartialOrd			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> 
PartialOrd			pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> 
PartialOrd			impl<T: ?Sized> PartialOrd for *const T 
PartialOrd			impl<T: ?Sized> PartialOrd for *mut T 
PartialOrd			impl<T: PartialOrd> PartialOrd for [T] 
PartialOrd			            impl<
PartialOrd for Ordering			impl PartialOrd for Ordering 
PartialOrd for bool			    impl PartialOrd for bool 
PartialOrd for str			    impl PartialOrd for str 
Pattern			impl<'a, 'b> Pattern<'a> for &'b &'b str 
Pattern			impl<'a, 'b> Pattern<'a> for &'b [char] 
Pattern			impl<'a, 'b> Pattern<'a> for &'b str 
Pattern			pub trait Pattern<'a>: Sized 
Pattern for CharEqPattern			impl<'a, C: CharEq> Pattern<'a> for CharEqPattern<C> 
Pattern for F			impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool 
Pattern for char			impl<'a> Pattern<'a> for char 
Peekable			impl<I: Iterator> Peekable<I> 
Peekable			pub struct Peekable<I: Iterator> 
PhantomData			pub struct PhantomData<T:?Sized>;
Pointer			impl<'a, T> Pointer for &'a T 
Pointer			impl<'a, T> Pointer for &'a mut T 
Pointer			impl<T> Pointer for *const T 
Pointer			impl<T> Pointer for *mut T 
Pointer			pub trait Pointer 
Position			pub enum Position 
RMatchIndices			        struct RMatchIndices;
RMatches			        struct RMatches;
RSplit			        struct RSplit;
RSplitN			pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool 
RSplitN			        struct RSplitN;
RSplitNMut			pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool 
RSplitTerminator			        struct RSplitTerminator;
Radix			impl Radix 
Radix			pub struct Radix 
RadixFmt			pub struct RadixFmt<T, R>(T, R);
RandomAccessIterator			pub trait RandomAccessIterator: Iterator 
RandomAccessIterator for Chain			impl<A, B> RandomAccessIterator for Chain<A, B> where
RandomAccessIterator for Chunks			impl<'a, T> RandomAccessIterator for Chunks<'a, T> 
RandomAccessIterator for Cloned			impl<'a, I, T: 'a> RandomAccessIterator for Cloned<I>
RandomAccessIterator for Cycle			impl<I> RandomAccessIterator for Cycle<I> where
RandomAccessIterator for Enumerate			impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator 
RandomAccessIterator for Fuse			impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator 
RandomAccessIterator for Inspect			impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>
RandomAccessIterator for Iter			impl<'a, T> RandomAccessIterator for Iter<'a, T> 
RandomAccessIterator for Map			impl<B, I: RandomAccessIterator, F> RandomAccessIterator for Map<I, F> where
RandomAccessIterator for Repeat			impl<A: Clone> RandomAccessIterator for Repeat<A> 
RandomAccessIterator for Rev			impl<I> RandomAccessIterator for Rev<I>
RandomAccessIterator for Skip			impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator
RandomAccessIterator for Take			impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator
RandomAccessIterator for Windows			impl<'a, T> RandomAccessIterator for Windows<'a, T> 
RandomAccessIterator for Zip			impl<A, B> RandomAccessIterator for Zip<A, B> where
Range			pub struct Range<Idx> 
RangeFrom			impl<A: Step> RangeFrom<A> 
RangeFrom			pub struct RangeFrom<Idx> 
RangeFull			pub struct RangeFull;
RangeInclusive			pub struct RangeInclusive<A> 
RangeTo			pub struct RangeTo<Idx> 
Ref			impl<'b, T: ?Sized> Ref<'b, T> 
Ref			pub struct Ref<'b, T: ?Sized + 'b> 
RefCell			impl<T: ?Sized> RefCell<T> 
RefCell			impl<T> RefCell<T> 
RefCell			pub struct RefCell<T: ?Sized> 
RefMut			impl<'b, T: ?Sized> RefMut<'b, T> 
RefMut			pub struct RefMut<'b, T: ?Sized + 'b> 
Reflect			impl Reflect for .. { }
Reflect			pub trait Reflect {}
Rem			        impl Rem for 
Rem			pub trait Rem<RHS=Self> 
Repeat			pub struct Repeat<A> 
Result			impl<T, E: fmt::Debug> Result<T, E> 
Result			impl<T, E> Result<T, E> 
Result			impl<T: fmt::Debug, E> Result<T, E> 
Result			pub enum Result<T, E> 
Rev			pub struct Rev<T> 
Scan			pub struct Scan<I, St, F> 
SearchStep			pub enum SearchStep 
Shl			        impl Shl<
Shl			pub trait Shl<RHS> 
Shl for Wrapping			        impl Shl<
Shr			        impl Shr<
Shr			pub trait Shr<RHS> 
Shr for Wrapping			        impl Shr<
Sign			pub enum Sign 
SipHasher			impl SipHasher 
SipHasher			pub struct SipHasher 
SizeHint			        struct SizeHint<A>(usize, Option<usize>, marker::PhantomData<A>);
Sized			pub trait Sized 
Skip			pub struct Skip<I> 
SkipWhile			pub struct SkipWhile<I, P> 
Slice			pub struct Slice<T> 
SliceExt			impl<T> SliceExt for [T] 
SliceExt			pub trait SliceExt 
Split			pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool 
Split			        struct Split;
SplitInternal			struct SplitInternal<'a, P: Pattern<'a>> 
SplitIter			trait SplitIter: DoubleEndedIterator 
SplitIter for Split			impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool 
SplitIter for SplitMut			impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
SplitMut			pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool 
SplitN			pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool 
SplitN			        struct SplitN;
SplitNInternal			struct SplitNInternal<'a, P: Pattern<'a>> 
SplitNMut			pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool 
SplitTerminator			        struct SplitTerminator;
State			enum State { Done, NotDone, Reject(usize, usize) }
State			impl State 
Step			        impl Step for 
Step			pub trait Step: PartialOrd 
StepBy			pub struct StepBy<A, R> 
StrExt			pub trait StrExt 
StrExt for str			impl StrExt for str 
StrSearcher			pub struct StrSearcher<'a, 'b> 
Sub			        impl Sub for 
Sub			pub trait Sub<RHS=Self> 
Sub for Wrapping			        impl Sub for Wrapping<
Take			pub struct Take<I> 
TakeWhile			pub struct TakeWhile<I, P> 
TraitObject			pub struct TraitObject 
TwoWaySearcher			impl TwoWaySearcher 
TwoWaySearcher			struct TwoWaySearcher 
TypeId			impl TypeId 
TypeId			pub struct TypeId 
Unfold			impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> 
Unfold			pub struct Unfold<St, F> 
Unique			impl<T: ?Sized> Unique<T> 
Unique			pub struct Unique<T: ?Sized> 
UnsafeCell			impl<T: ?Sized> UnsafeCell<T> 
UnsafeCell			impl<T> UnsafeCell<T> 
UnsafeCell			pub struct UnsafeCell<T: ?Sized> 
Unsize			pub trait Unsize<T> 
UpperExp			    impl UpperExp for 
UpperExp			pub trait UpperExp 
UpperHex			pub trait UpperHex 
UpperHex			struct UpperHex;
Utf8Error			impl Utf8Error 
Utf8Error			pub struct Utf8Error 
Void			enum Void {}
Windows			pub struct Windows<'a, T:'a> 
Wrapping			pub struct Wrapping<T>(#[stable(feature = "rust1", since = "1.0.0")] pub T);
Write			pub trait Write 
Write for Adapter			        impl<'a, T: ?Sized> Write for Adapter<'a, T>
Write for Formatter			impl<'a> Write for Formatter<'a> 
Zero			        impl Zero for 
Zero			pub trait Zero 
Zip			pub struct Zip<A, B> 
__description			    pub fn __description(&self) -> &str 
_assert_is_object_safe			fn _assert_is_object_safe(_: &Iterator<Item=()>) {}
abort			    pub fn abort() -> !;
abs			    fn abs(self) -> f32 
abs			    fn abs(self) -> f64 
abs			        pub fn abs(self) -> Self 
abs			    fn abs(self) -> Self;
add			            pub fn add<'a>(&'a mut self, other: &
add			            fn add(self, other: Wrapping<
add			            fn add(self, other: 
add			    fn add(self, rhs: RHS) -> Self::Output;
align			    pub fn align(&self) -> Alignment { self.align }
align_of			pub fn align_of<T>() -> usize 
align_of_val			pub fn align_of_val<T: ?Sized>(val: &T) -> usize 
all			    fn all<F>(&mut self, mut f: F) -> bool where
and			    pub fn and<U>(self, optb: Option<U>) -> Option<U> 
and			    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> 
and_then			    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> 
and_then			    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> 
any			    fn any<F>(&mut self, mut f: F) -> bool where
any			pub mod any;
arith_offset			    pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;
array			pub mod array;
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes<'a>(&'a self) -> &'a [u8];
as_mut			                fn as_mut(&mut self) -> &mut [T] 
as_mut			    fn as_mut(&mut self) -> &mut T;
as_mut			    fn as_mut(&mut self) -> &mut U 
as_mut			    fn as_mut(&mut self) -> &mut [T] 
as_mut			    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> 
as_mut			    pub unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> where T: Sized 
as_mut			    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> 
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut Self::Item;
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut T 
as_mut_slice			                fn as_mut_slice(&mut self) -> &mut [T] 
as_mut_slice			    fn as_mut_slice(&mut self) -> &mut [T];
as_mut_slice			    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] 
as_mut_slice			    pub fn as_mut_slice(&mut self) -> &mut [T] 
as_ptr			    fn as_ptr(&self) -> *const Self::Item;
as_ptr			    fn as_ptr(&self) -> *const T 
as_ptr			    fn as_ptr(&self) -> *const u8 
as_ptr			    fn as_ptr(&self) -> *const u8;
as_ref			                fn as_ref(&self) -> &[T] 
as_ref			    fn as_ref(&self) -> &T;
as_ref			    fn as_ref(&self) -> &U 
as_ref			    fn as_ref(&self) -> &[T] 
as_ref			    fn as_ref(&self) -> &str 
as_ref			    pub fn as_ref<'r>(&'r self) -> Option<&'r T> 
as_ref			    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized 
as_ref			    pub fn as_ref(&self) -> Result<&T, &E> 
as_ref			    fn as_ref(&self) -> &[u8] 
as_signed			            fn as_signed(&self) -> &[
as_signed			    fn as_signed<'a>(&'a self) -> &'a [S];
as_signed_mut			            fn as_signed_mut(&mut self) -> &mut [
as_signed_mut			    fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];
as_slice			                fn as_slice(&self) -> &[T] 
as_slice			    fn as_slice(&self) -> &[T];
as_slice			    pub fn as_slice<'a>(&'a self) -> &'a [T] 
as_slice			    pub fn as_slice(&self) -> &[T] 
as_slice			    pub fn as_slice(&self) -> &'a [T] 
as_unsafe_cell			    pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> 
as_unsigned			            fn as_unsigned(&self) -> &[
as_unsigned			    fn as_unsigned<'a>(&'a self) -> &'a [U];
as_unsigned_mut			            fn as_unsigned_mut(&mut self) -> &mut [
as_unsigned_mut			    fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];
as_usize			    fn as_usize(&self) -> Option<usize> 
assert_receiver_is_total_eq			    fn assert_receiver_is_total_eq(&self) {}
assume			    pub fn assume(b: bool);
atomic			pub mod atomic;
atomic_add			unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;
atomic_and_acq			    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;
atomic_and_acqrel			    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_and_rel			    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;
atomic_and_relaxed			    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_compare_and_swap			unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T 
atomic_cxchg			    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acq			    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acqrel			    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_rel			    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_relaxed			    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_fence			    pub fn atomic_fence();
atomic_fence_acq			    pub fn atomic_fence_acq();
atomic_fence_acqrel			    pub fn atomic_fence_acqrel();
atomic_fence_rel			    pub fn atomic_fence_rel();
atomic_load			unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T 
atomic_load			    pub fn atomic_load<T>(src: *const T) -> T;
atomic_load_acq			    pub fn atomic_load_acq<T>(src: *const T) -> T;
atomic_load_relaxed			    pub fn atomic_load_relaxed<T>(src: *const T) -> T;
atomic_load_unordered			    pub fn atomic_load_unordered<T>(src: *const T) -> T;
atomic_max			    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;
atomic_max_acq			    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;
atomic_max_acqrel			    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_max_rel			    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;
atomic_max_relaxed			    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_min			    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;
atomic_min_acq			    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;
atomic_min_acqrel			    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_min_rel			    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;
atomic_min_relaxed			    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_nand			unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_nand			    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;
atomic_nand_acq			    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;
atomic_nand_acqrel			    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_nand_rel			    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;
atomic_nand_relaxed			    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_or			unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_or			    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;
atomic_or_acq			    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;
atomic_or_acqrel			    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_or_rel			    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;
atomic_or_relaxed			    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_singlethreadfence			    pub fn atomic_singlethreadfence();
atomic_singlethreadfence_acq			    pub fn atomic_singlethreadfence_acq();
atomic_singlethreadfence_acqrel			    pub fn atomic_singlethreadfence_acqrel();
atomic_singlethreadfence_rel			    pub fn atomic_singlethreadfence_rel();
atomic_store			unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) 
atomic_store			    pub fn atomic_store<T>(dst: *mut T, val: T);
atomic_store_rel			    pub fn atomic_store_rel<T>(dst: *mut T, val: T);
atomic_store_relaxed			    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);
atomic_store_unordered			    pub fn atomic_store_unordered<T>(dst: *mut T, val: T);
atomic_sub			unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_swap			unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_umax			    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;
atomic_umax_acq			    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;
atomic_umax_acqrel			    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umax_rel			    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;
atomic_umax_relaxed			    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_umin			    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;
atomic_umin_acq			    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;
atomic_umin_acqrel			    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umin_rel			    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;
atomic_umin_relaxed			    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xadd			    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acq			    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acqrel			    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_rel			    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_relaxed			    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xchg			    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acq			    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acqrel			    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_rel			    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_relaxed			    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xor			unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_xor			    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;
atomic_xor_acq			    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;
atomic_xor_acqrel			    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xor_rel			    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;
atomic_xor_relaxed			    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xsub			    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acq			    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acqrel			    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_rel			    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_relaxed			    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;
base			            fn base(&self) -> u8 { 
base			    fn base(&self) -> u8 { self.base }
base			    fn base(&self) -> u8;
bignum			pub mod bignum;
binary_search			    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord;
binary_search			    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord 
binary_search_by			    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where
binary_search_by			    fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize> where
bitand			            fn bitand(self, other: Wrapping<
bitand			            fn bitand(self, rhs: 
bitand			    fn bitand(self, rhs: RHS) -> Self::Output;
bitor			            fn bitor(self, other: Wrapping<
bitor			            fn bitor(self, rhs: 
bitor			    fn bitor(self, rhs: RHS) -> Self::Output;
bitxor			            fn bitxor(self, other: Wrapping<
bitxor			            fn bitxor(self, other: 
bitxor			    fn bitxor(self, rhs: RHS) -> Self::Output;
bool			mod bool 
borrow			    pub fn borrow<'a>(&'a self) -> Ref<'a, T> 
borrow_mut			    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> 
borrow_state			    pub fn borrow_state(&self) -> BorrowState 
breakpoint			    pub fn breakpoint();
bswap16			    pub fn bswap16(x: u16) -> u16;
bswap32			    pub fn bswap32(x: u32) -> u32;
bswap64			    pub fn bswap64(x: u64) -> u64;
bswap8			unsafe fn bswap8(x: u8) -> u8 { x }
builders			mod builders;
by_ref			    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }
bytes			pub mod bytes 
bytes			    fn bytes(&self) -> Bytes 
bytes			    fn bytes<'a>(&'a self) -> Bytes<'a>;
cached_power			pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) 
call			        extern "rust-call" fn call(&self, args: A) -> F::Output 
call			    extern "rust-call" fn call(&self, args: Args) -> Self::Output;
call			    extern "rust-call" fn call(&self, (line,): (&'a str,)) -> &'a str 
call			    extern "rust-call" fn call(&self, (ptr,): (&'a u8,)) -> u8 
call_mut			        extern "rust-call" fn call_mut(&mut self, args: A) -> F::Output 
call_mut			    extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
call_mut			    extern "rust-call" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str 
call_mut			    extern "rust-call" fn call_mut(&mut self, (ptr,): (&'a u8,)) -> u8 
call_once			        extern "rust-call" fn call_once(mut self, args: A) -> F::Output 
call_once			        extern "rust-call" fn call_once(self, args: A) -> F::Output 
call_once			    extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
call_once			    extern "rust-call" fn call_once(self, (line,): (&'a str,)) -> &'a str 
call_once			    extern "rust-call" fn call_once(self, (ptr,): (&'a u8,)) -> u8 
ceil			    fn ceil(self) -> f32 
ceil			    fn ceil(self) -> f64 
ceil			    fn ceil(self) -> Self;
ceilf32			    pub fn ceilf32(x: f32) -> f32;
ceilf64			    pub fn ceilf64(x: f64) -> f64;
cell			pub mod cell;
chain			    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where
char			pub mod char;
char_at			    fn char_at(&self, i: usize) -> char 
char_at			    fn char_at(&self, i: usize) -> char;
char_at_reverse			    fn char_at_reverse(&self, i: usize) -> char 
char_at_reverse			    fn char_at_reverse(&self, i: usize) -> char;
char_indices			    fn char_indices(&self) -> CharIndices 
char_indices			    fn char_indices<'a>(&'a self) -> CharIndices<'a>;
char_len			    fn char_len(&self) -> usize { self.chars().count() }
char_len			    fn char_len(&self) -> usize;
char_range_at			    fn char_range_at(&self, i: usize) -> CharRange 
char_range_at			    fn char_range_at(&self, start: usize) -> CharRange;
char_range_at_raw			fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: usize) -> CharRange 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: usize) -> CharRange;
chars			    fn chars(&self) -> Chars 
chars			    fn chars<'a>(&'a self) -> Chars<'a>;
checked_add			        fn checked_add(&self, other: u32) -> Option<Self> 
checked_add			        pub fn checked_add(self, other: Self) -> Option<Self> 
checked_add			    fn checked_add(&self, other: u32) -> Option<Self>;
checked_div			        pub fn checked_div(self, v: Self) -> Option<Self> 
checked_mul			        fn checked_mul(&self, other: u32) -> Option<Self> 
checked_mul			        pub fn checked_mul(self, other: Self) -> Option<Self> 
checked_mul			    fn checked_mul(&self, other: u32) -> Option<Self>;
checked_next_power_of_two			        pub fn checked_next_power_of_two(self) -> Option<Self> 
checked_sub			        fn checked_sub(&self, other: u32) -> Option<Self> 
checked_sub			        pub fn checked_sub(self, other: Self) -> Option<Self> 
checked_sub			    fn checked_sub(&self, other: u32) -> Option<Self>;
chunks			    fn chunks(&self, size: usize) -> Chunks<T> 
chunks			    fn chunks<'a>(&'a self, size: usize) -> Chunks<'a, Self::Item>;
chunks_mut			    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> 
chunks_mut			    fn chunks_mut<'a>(&'a mut self, chunk_size: usize) -> ChunksMut<'a, Self::Item>;
classify			    fn classify(self) -> Fp 
classify			    fn classify(self) -> Fp 
classify			    fn classify(self) -> FpCategory;
clone			                fn clone(&self) -> [T; 
clone			    fn clone(&self) -> BorrowRef<'b> 
clone			    fn clone(&self) -> Cell<T> 
clone			    fn clone(&self) -> RefCell<T> 
clone			    pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> 
clone			            fn clone(&self) -> 
clone			            fn clone(&self) -> extern "C" fn(
clone			            fn clone(&self) -> extern "Rust" fn(
clone			            fn clone(&self) -> unsafe extern "C" fn(
clone			            fn clone(&self) -> unsafe extern "Rust" fn(
clone			    fn clone(&self) -> &'a T { *self }
clone			    fn clone(&self) -> Self;
clone			    fn clone(&self) -> ArgumentV1<'a> 
clone			    fn clone(&self) -> SipHasher 
clone			    fn clone(&self) -> Empty<T> 
clone			    fn clone(&self) -> Peekable<I> 
clone			pub mod clone;
clone			            fn clone(&self) -> 
clone			            fn clone(&self) -> 
clone			    fn clone(&self) -> Iter<'a, A> 
clone			    fn clone(&self) -> *const T 
clone			    fn clone(&self) -> *mut T 
clone			    fn clone(&self) -> Slice<T> { *self }
clone			    fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }
clone			    fn clone(&self) -> Chunks<'a, T> 
clone			    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }
clone			    fn clone(&self) -> Split<'a, T, P> 
clone			    fn clone(&self) -> Windows<'a, T> 
clone			            fn clone(&self) -> Self 
clone			                fn clone(&self) -> (
clone_from			    fn clone_from(&mut self, source: &Self) 
clone_from_slice			    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;
clone_from_slice			    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone 
clone_ref			pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> 
cloned			    fn cloned<'a, T: 'a>(self) -> Cloned<Self>
cloned			    pub fn cloned(self) -> Option<T> 
cmp			                fn cmp(&self, other: &[T; 
cmp			                fn cmp(&self, other: &
cmp			        fn cmp(&self, _other: &()) -> Ordering { Equal }
cmp			        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }
cmp			        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }
cmp			        fn cmp(&self, other: &bool) -> Ordering 
cmp			    fn cmp(&self, other: &Ordering) -> Ordering 
cmp			    fn cmp(&self, other: &Self) -> Ordering;
cmp			    pub fn cmp<A, L, R>(mut a: L, mut b: R) -> cmp::Ordering where
cmp			pub mod cmp;
cmp			            fn cmp(&self, _other: &
cmp			        impl<T:?Sized> cmp::Eq for 
cmp			        impl<T:?Sized> cmp::Ord for 
cmp			        impl<T:?Sized> cmp::PartialEq for 
cmp			        impl<T:?Sized> cmp::PartialOrd for 
cmp			            fn cmp(&self, other: &
cmp			    fn cmp(&self, other: &*const T) -> Ordering 
cmp			    fn cmp(&self, other: &*mut T) -> Ordering 
cmp			    fn cmp(&self, other: &[T]) -> Ordering 
cmp			        fn cmp(&self, other: &str) -> Ordering 
cmp			                fn cmp(&self, other: &(
cmp_macros			mod cmp_macros;
collect			    fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized 
compare_and_swap			    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T 
compare_and_swap			    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool 
compare_and_swap			    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize 
compare_and_swap			    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize 
consts			pub mod consts 
consts			pub mod consts 
contains			    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;
contains			    fn contains(&self, x: &T) -> bool where T: PartialEq 
contains			    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 
contains			    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;
contains_char			    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 
contains_char			    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;
convert			pub mod convert;
copy			    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);
copy_lifetime			pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,
copy_memory			    pub fn copy_memory(src: &[u8], dst: &mut [u8]) 
copy_mut_lifetime			pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,
copy_nonoverlapping			    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);
copysignf32			    pub fn copysignf32(x: f32, y: f32) -> f32;
copysignf64			    pub fn copysignf64(x: f64, y: f64) -> f64;
core			mod core 
cosf32			    pub fn cosf32(x: f32) -> f32;
cosf64			    pub fn cosf64(x: f64) -> f64;
count			    fn count(self) -> usize where Self: Sized 
count			    fn count(self) -> usize 
count			            fn count(self) -> usize 
count_ones			        pub fn count_ones(self) -> u32 { (self as 
count_ones			        pub fn count_ones(self) -> u32 
count_zeros			        pub fn count_zeros(self) -> u32 
ctlz16			    pub fn ctlz16(x: u16) -> u16;
ctlz32			    pub fn ctlz32(x: u32) -> u32;
ctlz64			    pub fn ctlz64(x: u64) -> u64;
ctlz8			    pub fn ctlz8(x: u8) -> u8;
ctpop16			    pub fn ctpop16(x: u16) -> u16;
ctpop32			    pub fn ctpop32(x: u32) -> u32;
ctpop64			    pub fn ctpop64(x: u64) -> u64;
ctpop8			    pub fn ctpop8(x: u8) -> u8;
cttz16			    pub fn cttz16(x: u16) -> u16;
cttz32			    pub fn cttz32(x: u32) -> u32;
cttz64			    pub fn cttz64(x: u64) -> u64;
cttz8			    pub fn cttz8(x: u8) -> u8;
cycle			    fn cycle(self) -> Cycle<Self> where Self: Sized + Clone 
debug_list			    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> 
debug_list_new			pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> 
debug_map			    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> 
debug_map_new			pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> 
debug_set			    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> 
debug_set_new			pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> 
debug_struct			    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> 
debug_struct_new			pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str)
debug_tuple			    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> 
debug_tuple_new			pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> 
decode			pub fn decode<T: DecodableFloat>(v: T) -> (\/*negative?*\/ bool, FullDecoded) 
decoder			pub mod decoder;
default			    fn default() -> AtomicPtr<T> 
default			    fn default() -> Self 
default			    fn default() -> Cell<T> 
default			    fn default() -> RefCell<T> 
default			            fn default() -> 
default			    fn default() -> Self;
default			    fn default() -> SipHasher 
default			    fn default() -> Empty<T> 
default			pub mod default;
default			    fn default() -> Option<T> { None }
default			    fn default() -> &'a [T] { &[] }
default			    fn default() -> &'a str { "" }
default			                fn default() -> (
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref<'a>(&'a self) -> &'a T 
deref			    fn deref(&self) -> &T { *self }
deref			    fn deref<'a>(&'a self) -> &'a Self::Target;
deref			    fn deref<'a>(&'a self) -> &'a *mut T 
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T { *self }
deref_mut			    fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;
determine_sign			fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] 
digit			            fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8;
digits_to_dec_str			fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,
digits_to_exp_str			fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,
discriminant_value			    pub fn discriminant_value<T>(v: &T) -> u64;
div			            fn div(self, other: 
div			    fn div(self, rhs: RHS) -> Self::Output;
div_2pow10			fn div_2pow10<'a>(x: &'a mut Big, mut n: usize) -> &'a mut Big 
div_rem_small			            pub fn div_rem_small<'a>(&'a mut self, other: 
div_rem_upto_16			fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,
do_inspect			    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> 
downcast_mut			    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> 
downcast_ref			    pub fn downcast_ref<T: Any>(&self) -> Option<&T> 
dragon			    pub mod dragon;
drop			    fn drop(&mut self) 
drop			pub fn drop<T>(_x: T) { }
drop			    fn drop(&mut self);
drop_in_place			    pub fn drop_in_place<T: ?Sized>(_: *mut T);
dropped			pub unsafe fn dropped<T>() -> T 
dropped_impl			    unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }
empty			pub fn empty<T>() -> Empty<T> 
encode_utf16			    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> 
encode_utf16			    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;
encode_utf16_raw			pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> 
encode_utf8			    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> 
encode_utf8			    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;
encode_utf8_raw			pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> 
ends_with			    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
ends_with			    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq 
ends_with			    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool
entries			    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>
entries			    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>
entries			    pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>
entry			    fn entry(&mut self, entry: &fmt::Debug) 
entry			    pub fn entry(&mut self, entry: &fmt::Debug) -> &mut DebugList<'a, 'b> 
entry			    pub fn entry(&mut self, entry: &fmt::Debug) -> &mut DebugSet<'a, 'b> 
entry			    pub fn entry(&mut self, key: &fmt::Debug, value: &fmt::Debug) -> &mut DebugMap<'a, 'b> 
enumerate			    fn enumerate(self) -> Enumerate<Self> where Self: Sized 
eq			    fn eq(&self, other: &Cell<T>) -> bool 
eq			    fn eq(&self, other: &RefCell<T>) -> bool 
eq			                fn eq(&self, other: &
eq			        fn eq(&self, _other: &()) -> bool { true }
eq			        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }
eq			        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }
eq			        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }
eq			    fn eq(&self, other: &Rhs) -> bool;
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			    pub fn eq<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where
eq			            fn eq(&self, _other: &
eq			            fn eq(&self, other: &
eq			                fn eq(&self, other: &extern "C" fn(
eq			        fn eq(&self, other: &extern "C" fn() -> _R) -> bool 
eq			    fn eq(&self, other: &*const T) -> bool { *self == *other }
eq			    fn eq(&self, other: &*mut T) -> bool { *self == *other }
eq			    fn eq(&self, other: &[B]) -> bool 
eq			        fn eq(&self, other: &str) -> bool 
eq			                fn eq(&self, other: &(
eq_slice			fn eq_slice(a: &str, b: &str) -> bool 
eq_slice_			fn eq_slice_(a: &str, b: &str) -> bool 
equals			    pub fn equals<A, L, R>(mut a: L, mut b: R) -> bool where
err			    pub fn err(self) -> Option<E> 
escape_default			    fn escape_default(self) -> EscapeDefault 
escape_default			    fn escape_default(self) -> EscapeDefault;
escape_unicode			    fn escape_unicode(self) -> EscapeUnicode 
escape_unicode			    fn escape_unicode(self) -> EscapeUnicode;
estimate_max_buf_len			fn estimate_max_buf_len(exp: i16) -> usize 
estimate_scaling_factor			pub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 
estimator			pub mod estimator;
exp			    fn exp(self) -> f32 
exp			    fn exp(self) -> f64 
exp			    fn exp(self) -> Self;
exp2			    fn exp2(self) -> f32 
exp2			    fn exp2(self) -> f64 
exp2			    fn exp2(self) -> Self;
exp2f32			    pub fn exp2f32(x: f32) -> f32;
exp2f64			    pub fn exp2f64(x: f64) -> f64;
expect			    pub fn expect(self, msg: &str) -> T 
expect			    pub fn expect(self, msg: &str) -> T 
expf32			    pub fn expf32(x: f32) -> f32;
expf64			    pub fn expf64(x: f64) -> f64;
extend			    fn extend<T: IntoIterator<Item=A>>(&mut self, iterable: T);
externfnpointers			mod externfnpointers 
f32x4			pub struct f32x4(pub f32, pub f32, pub f32, pub f32);
f64x2			pub struct f64x2(pub f64, pub f64);
fabsf32			    pub fn fabsf32(x: f32) -> f32;
fabsf64			    pub fn fabsf64(x: f64) -> f64;
fence			pub fn fence(order: Ordering) 
fetch_add			    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize 
fetch_add			    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize 
fetch_and			    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool 
fetch_and			    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize 
fetch_and			    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize 
fetch_nand			    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize 
fetch_or			    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize 
fetch_sub			    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize 
fetch_sub			    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize 
fetch_xor			    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool 
fetch_xor			    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize 
fetch_xor			    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize 
field			    pub fn field(&mut self, name: &str, value: &fmt::Debug) -> &mut DebugStruct<'a, 'b> 
field			    pub fn field(&mut self, value: &fmt::Debug) -> &mut DebugTuple<'a, 'b> 
fill			    pub fn fill(&self) -> char { self.fill }
filter			    fn filter<P>(self, predicate: P) -> Filter<Self, P> where
filter_map			    pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Option<Ref<'b, U>>
filter_map			    pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Option<RefMut<'b, U>>
filter_map			    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where
find			    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where
find			    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> 
find			    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;
find_str			    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> 
find_str			    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;
finish			    pub fn finish(&mut self) -> fmt::Result 
finish			    pub fn finish(&mut self) 
finish			    fn finish(&self) -> u64;
finish			    fn finish(&self) -> u64 
finish			    fn finish(&mut self) -> Option<&'a [T]> 
finish			    fn finish(&mut self) -> Option<&'a mut [T]> 
finish			    fn finish(&mut self) -> Option<Self::Item>;
first			    fn first(&self) -> Option<&T> 
first			    fn first<'a>(&'a self) -> Option<&'a Self::Item>;
first_mut			    fn first_mut(&mut self) -> Option<&mut T> 
first_mut			    fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;
flags			    pub fn flags(&self) -> u32 { self.flags }
flat_map			    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>
float_macros			mod float_macros;
float_to_decimal_common			fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result
float_to_exponential_common			fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result
floor			    fn floor(self) -> f32 
floor			    fn floor(self) -> f64 
floor			    fn floor(self) -> Self;
floorf32			    pub fn floorf32(x: f32) -> f32;
floorf64			    pub fn floorf64(x: f64) -> f64;
flt2dec			pub mod flt2dec;
fmaf32			    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;
fmaf64			    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            impl<T: fmt::Debug> fmt::Debug for [T; 
fmt			            fn fmt(&self, f: &mut Formatter) -> Result { 
fmt			            fn fmt(&self, f: &mut Formatter) -> Result 
fmt			        fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			    fn fmt(&self, &mut Formatter) -> Result;
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result 
fmt			    fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl fmt::
fmt			        impl fmt::Debug for 
fmt			pub mod fmt;
fmt			            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for Any			impl fmt::Debug for Any + Send 
fmt::Debug for Any			impl fmt::Debug for Any 
fmt::Debug for RadixFmt			        impl fmt::Debug for RadixFmt<
fmt::Debug for Range			impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> 
fmt::Debug for RangeFrom			impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> 
fmt::Debug for RangeFull			impl fmt::Debug for RangeFull 
fmt::Debug for RangeTo			impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> 
fmt::Display for ParseBoolError			impl fmt::Display for ParseBoolError 
fmt::Display for ParseFloatError			impl fmt::Display for ParseFloatError 
fmt::Display for ParseIntError			impl fmt::Display for ParseIntError 
fmt::Display for RadixFmt			        impl fmt::Display for RadixFmt<
fmt::Display for Utf8Error			impl fmt::Display for Utf8Error 
fmt::Pointer for Unique			impl<T> fmt::Pointer for Unique<T> 
fmt::Write for PadAdapter			impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> 
fmt_int			    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result 
fold			    fn fold<B, F>(self, init: B, mut f: F) -> B where
fold			pub fn fold<T,
forget			    pub fn forget<T>(_: T) -> ();
forget			pub fn forget<T>(t: T) 
format_exact			pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_exact			pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_exact_opt			pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)
format_shortest			pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_shortest			pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_shortest_opt			pub fn format_shortest_opt(d: &Decoded,
fract			    fn fract(self) -> f32 { self - self.trunc() }
fract			    fn fract(self) -> f64 { self - self.trunc() }
fract			    fn fract(self) -> Self;
from			    fn from(T) -> Self;
from			    fn from(t: T) -> T { t }
from_be			        pub fn from_be(x: Self) -> Self 
from_digit			pub fn from_digit(num: u32, radix: u32) -> Option<char> 
from_iter			    fn from_iter<T: IntoIterator<Item=A>>(iterator: T) -> Self;
from_iter			    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> 
from_iter			    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> 
from_le			        pub fn from_le(x: Self) -> Self 
from_raw_parts			pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] 
from_raw_parts_mut			pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] 
from_small			            pub fn from_small(v: 
from_str			            fn from_str(src: &str) -> Result<Self, ParseFloatError> 
from_str			            fn from_str(src: &str) -> Result<Self, ParseIntError> 
from_str			    fn from_str(s: &str) -> Result<Self, Self::Err>;
from_str			    fn from_str(s: &str) -> Result<bool, ParseBoolError> 
from_str_radix			        fn from_str_radix(src: &str, radix: u32)
from_str_radix			        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> 
from_str_radix			    fn from_str_radix(s: &str, r: u32) -> Result<Self, ParseFloatError>;
from_str_radix			fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)
from_u32			pub fn from_u32(i: u32) -> Option<char> 
from_u32			        fn from_u32(u: u32) -> Self { u as Self }
from_u32			    fn from_u32(u: u32) -> Self;
from_u64			            pub fn from_u64(mut v: u64) -> 
from_u8			        fn from_u8(u: u8) -> 
from_u8			    fn from_u8(u: u8) -> Self;
from_usize			    pub fn from_usize(x: &usize) -> ArgumentV1 
from_utf8			pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> 
from_utf8_unchecked			pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str 
full_add			                fn full_add(self, other: 
full_add			    fn full_add(self, other: Self, carry: bool) -> (bool \/*carry*\/, Self);
full_div_rem			                fn full_div_rem(self, other: 
full_div_rem			    fn full_div_rem(self, other: Self, borrow: Self) -> (Self \/*quotient*\/, Self \/*remainder*\/);
full_mul			                fn full_mul(self, other: 
full_mul			    fn full_mul(self, other: Self, carry: Self) -> (Self \/*carry*\/, Self);
full_mul_add			                fn full_mul_add(self, other: 
full_mul_add			    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self \/*carry*\/, Self);
fuse			    fn fuse(self) -> Fuse<Self> where Self: Sized 
ge			                fn ge(&self, other: &[T; 
ge			                fn ge(&self, other: &
ge			        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }
ge			        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }
ge			    fn ge(&self, other: &Rhs) -> bool 
ge			    pub fn ge<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where
ge			    fn ge(&self, other: &*const T) -> bool { *self >= *other }
ge			    fn ge(&self, other: &*mut T) -> bool { *self >= *other }
ge			    fn ge(&self, other: &[T]) -> bool 
ge			                fn ge(&self, other: &(
get			    pub fn get(&self) -> *mut T 
get			    pub fn get(&self) -> T 
get			    pub unsafe fn get(&self) -> &T 
get			    fn get(&self, index: usize) -> Option<&T> 
get			    fn get<'a>(&'a self, index: usize) -> Option<&'a Self::Item>;
get_end			    fn get_end(&mut self) -> Option<&'a str> 
get_mut			    pub unsafe fn get_mut(&mut self) -> &mut T 
get_mut			    fn get_mut(&mut self, index: usize) -> Option<&mut T> 
get_mut			    fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;
get_type_id			    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }
get_type_id			    fn get_type_id(&self) -> TypeId;
get_unchecked			    unsafe fn get_unchecked(&self, index: usize) -> &T 
get_unchecked			    unsafe fn get_unchecked<'a>(&'a self, index: usize) -> &'a Self::Item;
get_unchecked_mut			    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T 
get_unchecked_mut			    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: usize) -> &'a mut Self::Item;
getcount			    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> 
grisu			    pub mod grisu;
gt			                fn gt(&self, other: &[T; 
gt			                fn gt(&self, other: &
gt			        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }
gt			        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }
gt			    fn gt(&self, other: &Rhs) -> bool 
gt			    pub fn gt<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where
gt			    fn gt(&self, other: &*const T) -> bool { *self > *other }
gt			    fn gt(&self, other: &*mut T) -> bool { *self > *other }
gt			    fn gt(&self, other: &[T]) -> bool 
gt			                fn gt(&self, other: &(
hash			                fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			                fn hash<H: Hasher>(&self, _state: &mut H) {}
hash			                fn hash<H: Hasher>(&self, state: &mut H) 
hash			                fn hash<S: Hasher>(&self, state: &mut S) 
hash			        fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H);
hash			pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 
hash			pub mod hash;
hash			            fn hash<H: Hasher>(&self, _: &mut H) 
hash_slice			                fn hash_slice<H: Hasher>(data: &[
hash_slice			    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized 
haystack			        fn haystack(&self) -> &'a str 
haystack			    fn haystack(&self) -> &'a str 
haystack			    fn haystack(&self) -> &'a str;
i16			impl i16 
i16_add_with_overflow			    pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_mul_with_overflow			    pub fn i16_mul_with_overflow(x: i16, y: i16) -> (i16, bool);
i16_sub_with_overflow			    pub fn i16_sub_with_overflow(x: i16, y: i16) -> (i16, bool);
i16x8			pub struct i16x8(pub i16, pub i16, pub i16, pub i16,
i32			impl i32 
i32_add_with_overflow			    pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_mul_with_overflow			    pub fn i32_mul_with_overflow(x: i32, y: i32) -> (i32, bool);
i32_sub_with_overflow			    pub fn i32_sub_with_overflow(x: i32, y: i32) -> (i32, bool);
i32x4			pub struct i32x4(pub i32, pub i32, pub i32, pub i32);
i64			impl i64 
i64_add_with_overflow			    pub fn i64_add_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_mul_with_overflow			    pub fn i64_mul_with_overflow(x: i64, y: i64) -> (i64, bool);
i64_sub_with_overflow			    pub fn i64_sub_with_overflow(x: i64, y: i64) -> (i64, bool);
i64x2			pub struct i64x2(pub i64, pub i64);
i8			impl i8 
i8_add_with_overflow			    pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_mul_with_overflow			    pub fn i8_mul_with_overflow(x: i8, y: i8) -> (i8, bool);
i8_sub_with_overflow			    pub fn i8_sub_with_overflow(x: i8, y: i8) -> (i8, bool);
i8x16			pub struct i8x16(pub i8, pub i8, pub i8, pub i8,
idx			    fn idx(&mut self, _: usize) -> Option<A> { Some(self.element.clone()) }
idx			    fn idx(&mut self, index: usize) -> Option<(A::Item, B::Item)> 
idx			    fn idx(&mut self, index: usize) -> Option<(usize, <I as Iterator>::Item)> 
idx			    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> 
idx			    fn idx(&mut self, index: usize) -> Option<A::Item> 
idx			    fn idx(&mut self, index: usize) -> Option<B> 
idx			    fn idx(&mut self, index: usize) -> Option<I::Item> 
idx			    fn idx(&mut self, index: usize) -> Option<Self::Item>;
idx			    fn idx(&mut self, index: usize) -> Option<T> 
idx			    fn idx(&mut self, index: usize) -> Option<&'a T> 
idx			    fn idx(&mut self, index: usize) -> Option<&'a [T]> 
impls			mod impls 
impls			mod impls 
impls			mod impls 
impls			mod impls 
index			    fn index<'a>(&'a self, index: Idx) -> &'a Self::Output;
index			    fn index(&self, _index: RangeFull) -> &[T] 
index			    fn index(&self, index: ops::Range<usize>) -> &[T] 
index			    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] 
index			    fn index(&self, index: ops::RangeTo<usize>) -> &[T] 
index			    fn index(&self, index: usize) -> &T 
index			        fn index(&self, _index: ops::RangeFull) -> &str 
index			        fn index(&self, index: ops::Range<usize>) -> &str 
index			        fn index(&self, index: ops::RangeFrom<usize>) -> &str 
index			        fn index(&self, index: ops::RangeTo<usize>) -> &str 
index_mut			    fn index_mut<'a>(&'a mut self, index: Idx) -> &'a mut Self::Output;
index_mut			    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: usize) -> &mut T 
indexable			    fn indexable(&self) -> usize { self.iter.indexable() }
indexable			    fn indexable(&self) -> usize { usize::MAX }
indexable			    fn indexable(&self) -> usize 
indexable			    fn indexable(&self) -> usize;
indexable			    fn indexable(&self) -> usize 
infinity			    fn infinity() -> f32 { INFINITY }
infinity			    fn infinity() -> f64 { INFINITY }
infinity			    fn infinity() -> Self;
init			    pub fn init<T>() -> T;
init			    fn init(&self) -> &[T] 
init			    fn init<'a>(&'a self) -> &'a [Self::Item];
init_dropped			    pub fn init_dropped<T>() -> T;
init_mut			    fn init_mut(&mut self) -> &mut [T] 
init_mut			    fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];
inspect			    fn inspect<F>(self, f: F) -> Inspect<Self, F> where
int_macros			mod int_macros;
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8);
into			    fn into(self) -> T;
into			    fn into(self) -> U 
into_inner			    pub fn into_inner(self) -> T 
into_inner			    pub unsafe fn into_inner(self) -> T 
into_iter			                fn into_iter(self) -> Iter<'a, T> 
into_iter			                fn into_iter(self) -> IterMut<'a, T> 
into_iter			    fn into_iter(self) -> I 
into_iter			    fn into_iter(self) -> Self::IntoIter;
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    fn into_iter(self) -> IterMut<'a, T> 
into_option			    pub fn into_option(self) -> Option<(T,T)> 
into_searcher			        fn into_searcher(self, haystack: &'a str) -> 
into_searcher			    fn into_searcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> 
into_searcher			    fn into_searcher(self, haystack: &'a str) -> Self::Searcher;
into_searcher			    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> 
into_slice			    pub fn into_slice(self) -> &'a mut [T] 
intrinsics			pub mod intrinsics;
is			    pub fn is<T: Any>(&self) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: usize) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: usize) -> bool;
is_contained_in			        fn is_contained_in(self, haystack: &'a str) -> bool 
is_contained_in			    fn is_contained_in(self, haystack: &'a str) -> bool 
is_digit			    fn is_digit(self, radix: u32) -> bool 
is_digit			    fn is_digit(self, radix: u32) -> bool;
is_empty			    pub fn is_empty(&mut self) -> bool 
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool;
is_err			    pub fn is_err(&self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool;
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool;
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool;
is_negative			    fn is_negative(self) -> bool 
is_negative			    fn is_negative(self) -> bool 
is_negative			        pub fn is_negative(self) -> bool { self < 0 }
is_negative			    fn is_negative(self) -> bool;
is_none			    pub fn is_none(&self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool;
is_null			    pub fn is_null(self) -> bool where T: Sized 
is_ok			    pub fn is_ok(&self) -> bool 
is_positive			    fn is_positive(self) -> bool 
is_positive			    fn is_positive(self) -> bool 
is_positive			        pub fn is_positive(self) -> bool { self > 0 }
is_positive			    fn is_positive(self) -> bool;
is_power_of_two			        pub fn is_power_of_two(self) -> bool 
is_prefix_of			        fn is_prefix_of(self, haystack: &'a str) -> bool 
is_prefix_of			    fn is_prefix_of(self, haystack: &'a str) -> bool 
is_pretty			    fn is_pretty(&self) -> bool 
is_some			    pub fn is_some(&self) -> bool 
is_suffix_of			        fn is_suffix_of(self, haystack: &'a str) -> bool
is_suffix_of			    fn is_suffix_of(self, haystack: &'a str) -> bool
is_zero			            pub fn is_zero(&self) -> bool 
isize			impl isize 
iter			pub mod iter;
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;
iter			    fn iter<'a>(&'a self) -> Iter<'a, T> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;
iter_mut			    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> 
iter_nth			    fn iter_nth(&mut self, n: usize) -> Option<&'a T> 
iter_nth			    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> 
iterate			pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where
last			    fn last(mut self) -> Option<I::Item> 
last			    fn last(self) -> Option<A::Item> 
last			    fn last(self) -> Option<I::Item> 
last			    fn last(self) -> Option<Self::Item> where Self: Sized 
last			            fn last(mut self) -> Option<
last			    fn last(&self) -> Option<&T> 
last			    fn last<'a>(&'a self) -> Option<&'a Self::Item>;
last_mut			    fn last_mut(&mut self) -> Option<&mut T> 
last_mut			    fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;
ldexpi			    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }
ldexpi			    fn ldexpi(f: i64, exp: isize) -> Self;
le			                fn le(&self, other: &[T; 
le			                fn le(&self, other: &
le			        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }
le			        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }
le			    fn le(&self, other: &Rhs) -> bool 
le			    pub fn le<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where
le			    fn le(&self, other: &*const T) -> bool { *self <= *other }
le			    fn le(&self, other: &*mut T) -> bool { *self <= *other }
le			    fn le(&self, other: &[T]) -> bool 
le			                fn le(&self, other: &(
leading_zeros			        pub fn leading_zeros(self) -> u32 
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> usize 
len			    fn len(&self) -> usize { self.repr().len }
len			    fn len(&self) -> usize;
len			    fn len(&self) -> usize { self.repr().len }
len			    fn len(&self) -> usize 
len			    fn len(&self) -> usize;
len_utf16			    fn len_utf16(self) -> usize 
len_utf16			    fn len_utf16(self) -> usize;
len_utf8			    fn len_utf8(self) -> usize 
len_utf8			    fn len_utf8(self) -> usize;
lines			    fn lines(&self) -> Lines 
lines			    fn lines<'a>(&'a self) -> Lines<'a>;
lines_any			    fn lines_any(&self) -> LinesAny 
lines_any			    fn lines_any<'a>(&'a self) -> LinesAny<'a>;
ln			    fn ln(self) -> f32 
ln			    fn ln(self) -> f64 
ln			    fn ln(self) -> Self;
load			    pub fn load(&self, order: Ordering) -> *mut T 
load			    pub fn load(&self, order: Ordering) -> bool 
load			    pub fn load(&self, order: Ordering) -> isize 
load			    pub fn load(&self, order: Ordering) -> usize 
log			    fn log(self, base: f32) -> f32 { self.ln() \/ base.ln() }
log			    fn log(self, base: f64) -> f64 { self.ln() \/ base.ln() }
log			    fn log(self, base: Self) -> Self;
log10			    fn log10(self) -> f32 
log10			    fn log10(self) -> f64 
log10			    fn log10(self) -> Self;
log10f32			    pub fn log10f32(x: f32) -> f32;
log10f64			    pub fn log10f64(x: f64) -> f64;
log2			    fn log2(self) -> f32 
log2			    fn log2(self) -> f64 
log2			    fn log2(self) -> Self;
log2f32			    pub fn log2f32(x: f32) -> f32;
log2f64			    pub fn log2f64(x: f64) -> f64;
logf32			    pub fn logf32(x: f32) -> f32;
logf64			    pub fn logf64(x: f64) -> f64;
lt			                fn lt(&self, other: &[T; 
lt			                fn lt(&self, other: &
lt			        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }
lt			        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }
lt			    fn lt(&self, other: &Rhs) -> bool 
lt			    pub fn lt<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where
lt			    fn lt(&self, other: &*const T) -> bool { *self < *other }
lt			    fn lt(&self, other: &*mut T) -> bool { *self < *other }
lt			    fn lt(&self, other: &[T]) -> bool 
lt			                fn lt(&self, other: &(
macros			mod macros;
map			    pub fn map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>
map			    pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>
map			    fn map<B, F>(self, f: F) -> Map<Self, F> where
map			    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> 
map			    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> 
map_err			    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> 
map_or			    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U 
map_or_else			    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U 
marker			pub mod marker;
match_indices			    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> 
match_indices			    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;
matches			    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> 
matches			    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P>;
matches			    fn matches(&mut self, c: char) -> bool { (*self)(c) }
matches			    fn matches(&mut self, c: char) -> bool { *self == c }
matches			    fn matches(&mut self, c: char) -> bool 
matches			    fn matches(&mut self, char) -> bool;
max			pub fn max<T: Ord>(v1: T, v2: T) -> T 
max			    fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord
max_by			    fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where
max_pow10_no_more_than			pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) 
max_value			        pub fn max_value() -> Self { !0 }
max_value			        pub fn max_value() -> Self 
maximal_suffix			    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) 
mem			pub mod mem;
min			pub fn min<T: Ord>(v1: T, v2: T) -> T 
min			    fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord
min_align_of			    pub fn min_align_of<T>() -> usize;
min_align_of			pub fn min_align_of<T>() -> usize 
min_align_of_val			    pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;
min_align_of_val			pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize 
min_by			    fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where
min_max			    fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord
min_pos_norm_value			    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }
min_pos_norm_value			    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }
min_pos_norm_value			    fn min_pos_norm_value() -> Self;
min_value			        fn min_value() -> Self { Self::min_value() }
min_value			        pub fn min_value() -> Self { 0 }
min_value			        pub fn min_value() -> Self 
min_value			    fn min_value() -> Self;
move_val_init			    pub fn move_val_init<T>(dst: &mut T, src: T);
mul			    fn mul(&self, other: &Fp) -> Fp 
mul			            fn mul(self, other: Wrapping<
mul			            fn mul(self, other: 
mul			    fn mul(self, rhs: RHS) -> Self::Output;
mul_add			    fn mul_add(self, a: f32, b: f32) -> f32 
mul_add			    fn mul_add(self, a: f64, b: f64) -> f64 
mul_add			    fn mul_add(self, a: Self, b: Self) -> Self;
mul_digits			            pub fn mul_digits<'a>(&'a mut self, other: &[
mul_inner			                fn mul_inner(ret: &mut [
mul_pow10			pub fn mul_pow10<'a>(x: &'a mut Big, n: usize) -> &'a mut Big 
mul_pow2			            pub fn mul_pow2<'a>(&'a mut self, bits: usize) -> &'a mut 
mul_small			            pub fn mul_small<'a>(&'a mut self, other: 
multibyte_char_range_at			    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) 
multibyte_char_range_at_reverse			        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange 
mut_ref_slice			pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] 
nan			    fn nan() -> f32 { NAN }
nan			    fn nan() -> f64 { NAN }
nan			    fn nan() -> Self;
ne			                fn ne(&self, other: &
ne			        fn ne(&self, _other: &()) -> bool { false }
ne			        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }
ne			        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }
ne			        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }
ne			    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }
ne			            fn ne(&self, other: &
ne			            fn ne(&self, other: &
ne			    pub fn ne<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where
ne			    fn ne(&self, other: &[B]) -> bool 
ne			        fn ne(&self, other: &str) -> bool { !(*self).eq(other) }
ne			                fn ne(&self, other: &(
nearbyintf32			    pub fn nearbyintf32(x: f32) -> f32;
nearbyintf64			    pub fn nearbyintf64(x: f64) -> f64;
needs_drop			    pub fn needs_drop<T>() -> bool;
neg			            fn neg(self) -> 
neg			    fn neg(self) -> Self::Output;
neg_infinity			    fn neg_infinity() -> f32 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> f64 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { -0.0 }
neg_zero			    fn neg_zero() -> f64 { -0.0 }
neg_zero			    fn neg_zero() -> Self;
new			    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> 
new			    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> 
new			    fn new(fmt: &'a mut fmt::Formatter<'b>) -> PadAdapter<'a, 'b> 
new			    pub fn new<'b, T>(x: &'b T,
new			    fn new(base: u8) -> Radix 
new			    pub fn new() -> SipHasher 
new			    pub fn new(initial_state: St, f: F) -> Unfold<St, F> 
new			    pub unsafe fn new(inner: T) -> NonZero<T> 
new			    pub unsafe fn new(ptr: *mut T) -> Unique<T> 
new			    fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher 
new			    fn new(needle: &[u8]) -> TwoWaySearcher 
new_v1			    pub fn new_v1(pieces: &'a [&'a str],
new_v1_formatted			    pub fn new_v1_formatted(pieces: &'a [&'a str],
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher 
next			    fn next(&mut self) -> Option<char> 
next			            fn next(&mut self) -> Option<A> { None }
next			    fn next(&mut self) -> Option<(A::Item, B::Item)> 
next			    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> 
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> 
next			    fn next(&mut self) -> Option<A::Item> 
next			    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }
next			    fn next(&mut self) -> Option<A> 
next			    fn next(&mut self) -> Option<B> 
next			    fn next(&mut self) -> Option<I::Item> { (**self).next() }
next			    fn next(&mut self) -> Option<I::Item> 
next			    fn next(&mut self) -> Option<Self::Item>;
next			    fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<U::Item> 
next			    fn next<T, F>(st: &mut IterateState<T, F>) -> Option<T> where
next			            fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<&'a A> { self.inner.next() }
next			    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }
next			    fn next(&mut self) -> Option<A> { self.inner.next() }
next			    fn next(&mut self) -> Option<A> 
next			            fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<&'a T> { self.inner.take() }
next			    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }
next			    fn next(&mut self) -> Option<T> { self.inner.take() }
next			            fn next(&mut self) -> Option<
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a [T]> 
next			    fn next(&mut self) -> Option<&'a mut [T]> 
next			    fn next(&mut self) -> Option<T> 
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a str> 
next			    fn next(&mut self) -> Option<(usize, char)> 
next			    fn next(&mut self) -> Option<(usize, usize)> 
next			    fn next(&mut self) -> Option<char> 
next			    fn next(&mut self) -> Option<u8> 
next			    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)
next			        fn next(&mut self) -> SearchStep 
next			    fn next(&mut self) -> SearchStep 
next			    fn next(&mut self) -> SearchStep;
next_back			    fn next_back(&mut self) -> Option<(A::Item, B::Item)> 
next_back			    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> 
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> 
next_back			    fn next_back(&mut self) -> Option<A::Item> 
next_back			    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<B> 
next_back			    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }
next_back			    fn next_back(&mut self) -> Option<I::Item> 
next_back			    fn next_back(&mut self) -> Option<Self::Item>;
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back(&mut self) -> Option<U::Item> 
next_back			    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }
next_back			    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }
next_back			    fn next_back(&mut self) -> Option<T> { self.inner.take() }
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a [T]> 
next_back			    fn next_back(&mut self) -> Option<&'a mut [T]> 
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a str> 
next_back			    fn next_back(&mut self) -> Option<&'a str>
next_back			    fn next_back(&mut self) -> Option<(usize, char)> 
next_back			    fn next_back(&mut self) -> Option<(usize, usize)>
next_back			    fn next_back(&mut self) -> Option<char> 
next_back			    fn next_back(&mut self) -> Option<u8> 
next_back			        fn next_back(&mut self) -> SearchStep 
next_back			    fn next_back(&mut self) -> SearchStep 
next_back			    fn next_back(&mut self) -> SearchStep;
next_code_point			pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> 
next_code_point_reverse			fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> 
next_match			        fn next_match(&mut self) -> Option<(usize, usize)> 
next_match			    fn next_match(&mut self) -> Option<(usize, usize)> 
next_match_back			        fn next_match_back(&mut self) -> Option<(usize, usize)> 
next_match_back			    fn next_match_back(&mut self) -> Option<(usize, usize)>
next_permutation			    fn next_permutation(&mut self) -> bool where Self::Item: Ord;
next_permutation			    fn next_permutation(&mut self) -> bool where T: Ord 
next_power_of_two			        pub fn next_power_of_two(self) -> Self 
next_reject			        fn next_reject(&mut self) -> Option<(usize, usize)> 
next_reject			    fn next_reject(&mut self) -> Option<(usize, usize)> 
next_reject_back			        fn next_reject_back(&mut self) -> Option<(usize, usize)> 
next_reject_back			    fn next_reject_back(&mut self) -> Option<(usize, usize)>
nonzero			pub mod nonzero;
normalize			    fn normalize(&self) -> Fp 
normalize_to			    fn normalize_to(&self, e: i16) -> Fp 
not			            fn not(self) -> Wrapping<
not			            fn not(self) -> 
not			    fn not(self) -> Self::Output;
nth			    fn nth(&mut self, mut n: usize) -> Option<A::Item> 
nth			    fn nth(&mut self, mut n: usize) -> Option<Self::Item> where Self: Sized 
nth			    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> 
nth			    fn nth(&mut self, n: usize) -> Option<I::Item> 
nth			            fn nth(&mut self, n: usize) -> Option<
null			pub fn null<T>() -> *const T { 0 as *const T }
null_mut			pub fn null_mut<T>() -> *mut T { 0 as *mut T }
num			mod num;
num			pub mod num;
of			    pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId 
offset			    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;
offset			    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized 
offset			    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized 
ok			    pub fn ok(self) -> Option<T> 
ok_or			    pub fn ok_or<E>(self, err: E) -> Result<T, E> 
ok_or_else			    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> 
once			pub fn once<T>(value: T) -> Once<T> 
one			    fn one() -> f32 { 1.0 }
one			    fn one() -> f64 { 1.0 }
one			            fn one() -> Self { 1 }
one			            fn one() -> Self { 1.0 }
one			    fn one() -> Self;
only_ascii			    fn only_ascii(&self) -> bool { (*self as u32) < 128 }
only_ascii			    fn only_ascii(&self) -> bool { false }
only_ascii			    fn only_ascii(&self) -> bool 
only_ascii			    fn only_ascii(&self) -> bool;
ops			impl<A: Step> ops::Range<A> 
ops			pub mod ops;
ops			impl<T> ops::Index<RangeFull> for [T] 
ops			impl<T> ops::Index<ops::Range<usize>> for [T] 
ops			impl<T> ops::Index<ops::RangeFrom<usize>> for [T] 
ops			impl<T> ops::Index<ops::RangeTo<usize>> for [T] 
ops			impl<T> ops::Index<usize> for [T] 
ops			impl<T> ops::IndexMut<RangeFull> for [T] 
ops			impl<T> ops::IndexMut<ops::Range<usize>> for [T] 
ops			impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] 
ops			impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] 
ops			impl<T> ops::IndexMut<usize> for [T] 
ops			    impl ops::Index<ops::Range<usize>> for str 
ops			    impl ops::Index<ops::RangeFrom<usize>> for str 
ops			    impl ops::Index<ops::RangeTo<usize>> for str 
ops::Index for str			    impl ops::Index<ops::RangeFull> for str 
option			pub mod option;
or			    pub fn or(self, optb: Option<T>) -> Option<T> 
or			    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> 
or_else			    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> 
or_else			    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> 
order			pub mod order 
overflowing_add			    pub fn overflowing_add<T>(a: T, b: T) -> T;
overflowing_add			            fn overflowing_add(self, rhs: 
overflowing_add			    fn overflowing_add(self, rhs: Self) -> (Self, bool);
overflowing_add			    fn overflowing_add(self, rhs: isize) -> (isize, bool) 
overflowing_add			    fn overflowing_add(self, rhs: usize) -> (usize, bool) 
overflowing_div			            fn overflowing_div(self, rhs: 
overflowing_div			    fn overflowing_div(self, rhs: Self) -> (Self, bool);
overflowing_div			    fn overflowing_div(self, rhs: isize) -> (isize, bool) 
overflowing_div			    fn overflowing_div(self, rhs: usize) -> (usize, bool) 
overflowing_mul			    pub fn overflowing_mul<T>(a: T, b: T) -> T;
overflowing_mul			            fn overflowing_mul(self, rhs: 
overflowing_mul			    fn overflowing_mul(self, rhs: Self) -> (Self, bool);
overflowing_mul			    fn overflowing_mul(self, rhs: isize) -> (isize, bool) 
overflowing_mul			    fn overflowing_mul(self, rhs: usize) -> (usize, bool) 
overflowing_neg			            fn overflowing_neg(self) -> (
overflowing_neg			    fn overflowing_neg(self) -> (Self, bool);
overflowing_neg			    fn overflowing_neg(self) -> (isize, bool) 
overflowing_neg			    fn overflowing_neg(self) -> (usize, bool) 
overflowing_rem			            fn overflowing_rem(self, rhs: 
overflowing_rem			    fn overflowing_rem(self, rhs: Self) -> (Self, bool);
overflowing_rem			    fn overflowing_rem(self, rhs: isize) -> (isize, bool) 
overflowing_rem			    fn overflowing_rem(self, rhs: usize) -> (usize, bool) 
overflowing_shl			            fn overflowing_shl(self, rhs: u32) -> (
overflowing_shl			    fn overflowing_shl(self, rhs: u32) -> (Self, bool);
overflowing_shl			    fn overflowing_shl(self, rhs: u32) -> (isize, bool) 
overflowing_shl			    fn overflowing_shl(self, rhs: u32) -> (usize, bool) 
overflowing_shr			            fn overflowing_shr(self, rhs: u32) -> (
overflowing_shr			    fn overflowing_shr(self, rhs: u32) -> (Self, bool);
overflowing_shr			    fn overflowing_shr(self, rhs: u32) -> (isize, bool) 
overflowing_shr			    fn overflowing_shr(self, rhs: u32) -> (usize, bool) 
overflowing_sub			    pub fn overflowing_sub<T>(a: T, b: T) -> T;
overflowing_sub			            fn overflowing_sub(self, rhs: 
overflowing_sub			    fn overflowing_sub(self, rhs: Self) -> (Self, bool);
overflowing_sub			    fn overflowing_sub(self, rhs: isize) -> (isize, bool) 
overflowing_sub			    fn overflowing_sub(self, rhs: usize) -> (usize, bool) 
pad			    pub fn pad(&mut self, s: &str) -> Result 
pad_formatted_parts			    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result 
pad_integral			    pub fn pad_integral(&mut self,
panic			pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! 
panic_bounds_check			fn panic_bounds_check(file_line: &(&'static str, u32),
panic_fmt			pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! 
panic_impl			        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32) -> !;
panicking			pub mod panicking;
parse			    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }
parse			    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;
partial_cmp			                fn partial_cmp(&self, other: &[T; 
partial_cmp			                fn partial_cmp(&self, other: &
partial_cmp			        fn partial_cmp(&self, _: &()) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &bool) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;
partial_cmp			    pub fn partial_cmp<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> Option<cmp::Ordering> where
partial_cmp			            fn partial_cmp(&self, _other: &
partial_cmp			            fn partial_cmp(&self, other: &
partial_cmp			    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &str) -> Option<Ordering> 
partial_cmp			                fn partial_cmp(&self, other: &(
partial_max			pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> 
partial_min			pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> 
partition			    fn partition<B, F>(self, mut f: F) -> (B, B) where
pattern			pub mod pattern;
peek			    pub fn peek(&mut self) -> Option<&I::Item> 
peekable			    fn peekable(self) -> Peekable<Self> where Self: Sized 
position			    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where
position_elem			    fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;
position_elem			    fn position_elem(&self, x: &T) -> Option<usize> where T: PartialEq 
possibly_round			    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,
pow			        pub fn pow(self, mut exp: u32) -> Self 
powf			    fn powf(self, n: f32) -> f32 
powf			    fn powf(self, n: f64) -> f64 
powf			    fn powf(self, n: Self) -> Self;
powf32			    pub fn powf32(a: f32, x: f32) -> f32;
powf64			    pub fn powf64(a: f64, x: f64) -> f64;
powi			    fn powi(self, n: i32) -> f32 
powi			    fn powi(self, n: i32) -> f64 
powi			    fn powi(self, n: i32) -> Self;
powif32			    pub fn powif32(a: f32, x: i32) -> f32;
powif64			    pub fn powif64(a: f64, x: i32) -> f64;
precision			    pub fn precision(&self) -> Option<usize> { self.precision }
pref_align_of			    pub fn pref_align_of<T>() -> usize;
prefix			            fn prefix(&self) -> &'static str { 
prefix			    fn prefix(&self) -> &'static str { "" }
prelude			pub mod prelude;
prev_permutation			    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;
prev_permutation			    fn prev_permutation(&mut self) -> bool where T: Ord 
product			    fn product<P=<Self as Iterator>::Item>(self) -> P where
ptr			pub mod ptr;
radix			pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> 
range_inclusive			pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>
raw			pub mod raw;
read			pub unsafe fn read<T>(src: *const T) -> T 
read_and_drop			pub unsafe fn read_and_drop<T>(dest: *mut T) -> T 
read_and_zero			pub unsafe fn read_and_zero<T>(dest: *mut T) -> T 
recip			    fn recip(self) -> f32 { 1.0 \/ self }
recip			    fn recip(self) -> f64 { 1.0 \/ self }
recip			    fn recip(self) -> Self;
ref_slice			pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] 
rem			            fn rem(self, other: 
rem			            fn rem(self, other: 
rem			    fn rem(self, rhs: RHS) -> Self::Output;
repeat			pub fn repeat<T: Clone>(elt: T) -> Repeat<T> 
replace			pub fn replace<T>(dest: &mut T, mut src: T) -> T 
replace			pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T 
repr			    fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }
reset			    fn reset(&mut self) 
reset_fuse			    pub fn reset_fuse(&mut self) 
result			pub mod result;
return_address			    pub fn return_address() -> *const u8;
rev			    fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator 
reverse			    pub fn reverse(self) -> Ordering 
reverse			    fn reverse(&mut self) 
reverse			    fn reverse(&mut self);
reverse_in_place			    fn reverse_in_place<'a, T: 'a>(&mut self) where
rfind			    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>
rintf32			    pub fn rintf32(x: f32) -> f32;
rintf64			    pub fn rintf64(x: f64) -> f64;
rmatch_indices			    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>
rmatches			    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>
rotate_left			        pub fn rotate_left(self, n: u32) -> Self 
rotate_right			        pub fn rotate_right(self, n: u32) -> Self 
round			    fn round(self) -> f32 
round			    fn round(self) -> f64 
round			    fn round(self) -> Self;
round_and_weed			    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,
round_up			pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> 
roundf32			    pub fn roundf32(x: f32) -> f32;
roundf64			    pub fn roundf64(x: f64) -> f64;
rposition			    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where
rposition_elem			    fn rposition_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;
rposition_elem			    fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq 
rsplit			    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>
rsplit_terminator			    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>
rsplitn			    fn rsplitn<'a, P>(&'a self,  n: usize, pred: P) -> RSplitN<'a, Self::Item, P>
rsplitn			    fn rsplitn<'a, P>(&'a self, n: usize, pred: P) -> RSplitN<'a, T, P> where
rsplitn			    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>
rsplitn_mut			    fn rsplitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> RSplitNMut<'a, T, P> where
rsplitn_mut			    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>
rsqrt			    fn rsqrt(self) -> f32 { self.sqrt().recip() }
rsqrt			    fn rsqrt(self) -> f64 { self.sqrt().recip() }
rsqrt			    fn rsqrt(self) -> Self;
rt			pub mod rt 
run			    fn run(&mut self, arg: &rt::v1::Argument) -> Result 
run_utf8_validation_iterator			fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)
saturating_add			        pub fn saturating_add(self, other: Self) -> Self 
saturating_sub			        pub fn saturating_sub(self, other: Self) -> Self 
scan			    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>
select_fold1			fn select_fold1<I,B, FProj, FCmp>(mut it: I,
set			    pub fn set(&self, value: T) 
set_memory			        fn set_memory(&mut self, value: u8) 
set_memory			        fn set_memory(&mut self, value: u8);
shift_max			mod shift_max 
shl			            fn shl(self, other: 
shl			            fn shl(self, other: 
shl			    fn shl(self, rhs: RHS) -> Self::Output;
show_usize			    fn show_usize(x: &usize, f: &mut Formatter) -> Result 
shr			            fn shr(self, other: 
shr			            fn shr(self, other: 
shr			    fn shr(self, rhs: RHS) -> Self::Output;
signum			    fn signum(self) -> f32 
signum			    fn signum(self) -> f64 
signum			        pub fn signum(self) -> Self 
signum			    fn signum(self) -> Self;
simd			pub mod simd;
sinf32			    pub fn sinf32(x: f32) -> f32;
sinf64			    pub fn sinf64(x: f64) -> f64;
sip			mod sip;
size_from_ptr			fn size_from_ptr<T>(_: *const T) -> usize 
size_hint			            fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>)
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			            fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_of			    pub fn size_of<T>() -> usize;
size_of			pub fn size_of<T>() -> usize 
size_of_val			    pub fn size_of_val<T: ?Sized>(_: &T) -> usize;
size_of_val			pub fn size_of_val<T: ?Sized>(val: &T) -> usize 
skip			    fn skip(self, n: usize) -> Skip<Self> where Self: Sized 
skip_while			    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where
slice			pub mod slice;
slice_chars			    fn slice_chars(&self, begin: usize, end: usize) -> &str 
slice_chars			    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;
slice_error_fail			fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! 
slice_shift_char			    fn slice_shift_char(&self) -> Option<(char, &str)> 
slice_shift_char			    fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;
slice_unchecked			    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str 
slice_unchecked			    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;
split			    fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>
split			    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P> where P: FnMut(&T) -> bool 
split			    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> 
split			    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;
split_at			    fn split_at(&self, mid: usize) -> (&[T], &[T]) 
split_at			    fn split_at<'a>(&'a self, mid: usize) -> (&'a [Self::Item], &'a [Self::Item]);
split_at			    fn split_at(&self, mid: usize) -> (&str, &str) 
split_at			    fn split_at(&self, mid: usize) -> (&str, &str);
split_at_mut			    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) 
split_at_mut			    fn split_at_mut<'a>(&'a mut self, mid: usize) -> (&'a mut [Self::Item], &'a mut [Self::Item]);
split_mut			    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>
split_mut			    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
split_terminator			    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> 
split_terminator			    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;
splitn			    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, Self::Item, P>
splitn			    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, T, P> where
splitn			    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> 
splitn			    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;
splitn_mut			    fn splitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> SplitNMut<'a, T, P> where
splitn_mut			    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>
sqrt			    fn sqrt(self) -> f32 
sqrt			    fn sqrt(self) -> f64 
sqrt			    fn sqrt(self) -> Self;
sqrtf32			    pub fn sqrtf32(x: f32) -> f32;
sqrtf64			    pub fn sqrtf64(x: f64) -> f64;
starts_with			    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
starts_with			    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq 
starts_with			    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 
starts_with			    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;
std			mod std 
step			            fn step(&self, by: &
step			    fn step(&self, by: &Self) -> Option<Self>;
step_by			    pub fn step_by(self, by: A) -> StepBy<A, Self> 
steps_between			            fn steps_between(_a: &
steps_between			            fn steps_between(start: &
steps_between			    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;
store			    pub fn store(&self, ptr: *mut T, order: Ordering) 
store			    pub fn store(&self, val: bool, order: Ordering) 
store			    pub fn store(&self, val: isize, order: Ordering) 
store			    pub fn store(&self, val: usize, order: Ordering) 
str			pub mod str;
str_search_step			fn str_search_step<F, G>(mut m: &mut StrSearcher,
strategy			pub mod strategy 
sub			            pub fn sub<'a>(&'a mut self, other: &
sub			            fn sub(self, other: Wrapping<
sub			            fn sub(self, other: 
sub			    fn sub(self, rhs: RHS) -> Self::Output;
subslice_offset			    fn subslice_offset(&self, inner: &str) -> usize 
subslice_offset			    fn subslice_offset(&self, inner: &str) -> usize;
sum			    fn sum<S=<Self as Iterator>::Item>(self) -> S where
swap			    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T 
swap			    pub fn swap(&self, val: bool, order: Ordering) -> bool 
swap			    pub fn swap(&self, val: isize, order: Ordering) -> isize 
swap			    pub fn swap(&self, val: usize, order: Ordering) -> usize 
swap			pub fn swap<T>(x: &mut T, y: &mut T) 
swap			pub unsafe fn swap<T>(x: *mut T, y: *mut T) 
swap			    fn swap(&mut self, a: usize, b: usize) 
swap			    fn swap(&mut self, a: usize, b: usize);
swap_bytes			        pub fn swap_bytes(self) -> Self 
tail			    fn tail(&self) -> &[T] { &self[1..] }
tail			    fn tail<'a>(&'a self) -> &'a [Self::Item];
tail_mut			    fn tail_mut(&mut self) -> &mut [T] 
tail_mut			    fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];
take			    fn take(self, n: usize) -> Take<Self> where Self: Sized, 
take			    pub fn take(&mut self) -> Option<T> 
take_while			    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where
tests			pub mod tests 
to_be			        pub fn to_be(self) -> Self { \/\/ or not to be?
to_degrees			    fn to_degrees(self) -> f32 { self * (180.0f32 \/ consts::PI) }
to_degrees			    fn to_degrees(self) -> f64 { self * (180.0f64 \/ consts::PI) }
to_degrees			    fn to_degrees(self) -> Self;
to_digit			    fn to_digit(self, radix: u32) -> Option<u32> 
to_digit			    fn to_digit(self, radix: u32) -> Option<u32>;
to_exact_exp_str			pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,
to_exact_fixed_str			pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,
to_le			        pub fn to_le(self) -> Self 
to_radians			    fn to_radians(self) -> f32 
to_radians			    fn to_radians(self) -> f64 
to_radians			    fn to_radians(self) -> Self;
to_shortest_exp_str			pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,
to_shortest_str			pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,
to_u8			        fn to_u8(&self) -> u8 { *self as u8 }
to_u8			    fn to_u8(&self) -> u8;
trailing_zeros			        pub fn trailing_zeros(self) -> u32 
traits			mod traits 
transmute			    pub fn transmute<T,U>(e: T) -> U;
transmute_copy			pub unsafe fn transmute_copy<T, U>(src: &T) -> U 
trim_left_matches			    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str 
trim_left_matches			    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;
trim_matches			    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str
trim_right_matches			    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str
trunc			    fn trunc(self) -> f32 
trunc			    fn trunc(self) -> f64 
trunc			    fn trunc(self) -> Self;
truncf32			    pub fn truncf32(x: f32) -> f32;
truncf64			    pub fn truncf64(x: f64) -> f64;
tuple			mod tuple;
type_id			    pub fn type_id<T: ?Sized + 'static>() -> u64;
type_name			    pub fn type_name<T: ?Sized>() -> &'static str;
u16			impl u16 
u16_add_with_overflow			    pub fn u16_add_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_mul_with_overflow			    pub fn u16_mul_with_overflow(x: u16, y: u16) -> (u16, bool);
u16_sub_with_overflow			    pub fn u16_sub_with_overflow(x: u16, y: u16) -> (u16, bool);
u16x8			pub struct u16x8(pub u16, pub u16, pub u16, pub u16,
u32			impl u32 
u32_add_with_overflow			    pub fn u32_add_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_mul_with_overflow			    pub fn u32_mul_with_overflow(x: u32, y: u32) -> (u32, bool);
u32_sub_with_overflow			    pub fn u32_sub_with_overflow(x: u32, y: u32) -> (u32, bool);
u32x4			pub struct u32x4(pub u32, pub u32, pub u32, pub u32);
u64			impl u64 
u64_add_with_overflow			    pub fn u64_add_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_mul_with_overflow			    pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);
u64_sub_with_overflow			    pub fn u64_sub_with_overflow(x: u64, y: u64) -> (u64, bool);
u64x2			pub struct u64x2(pub u64, pub u64);
u8			impl u8 
u8_add_with_overflow			    pub fn u8_add_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_mul_with_overflow			    pub fn u8_mul_with_overflow(x: u8, y: u8) -> (u8, bool);
u8_sub_with_overflow			    pub fn u8_sub_with_overflow(x: u8, y: u8) -> (u8, bool);
u8x16			pub struct u8x16(pub u8, pub u8, pub u8, pub u8,
uint_macros			mod uint_macros;
unchecked_sdiv			    pub fn unchecked_sdiv<T>(x: T, y: T) -> T;
unchecked_srem			    pub fn unchecked_srem<T>(x: T, y: T) -> T;
unchecked_udiv			    pub fn unchecked_udiv<T>(x: T, y: T) -> T;
unchecked_urem			    pub fn unchecked_urem<T>(x: T, y: T) -> T;
uninit			    pub fn uninit<T>() -> T;
uninitialized			pub unsafe fn uninitialized<T>() -> T 
unreachable			    pub fn unreachable() -> !;
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(self) -> T 
unwrap_err			    pub fn unwrap_err(self) -> E 
unwrap_or			    pub fn unwrap_or(self, def: T) -> T 
unwrap_or			    pub fn unwrap_or(self, optb: T) -> T 
unwrap_or_0			fn unwrap_or_0(opt: Option<&u8>) -> u8 
unwrap_or_default			    pub fn unwrap_or_default(self) -> T 
unwrap_or_else			    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T 
unwrap_or_else			    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T 
unzip			    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where
usize			impl usize 
utf8_acc_cont_byte			fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }
utf8_first_byte			fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }
utf8_is_cont_byte			fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }
v1			    pub mod v1;
valid_up_to			    pub fn valid_up_to(&self) -> usize { self.valid_up_to }
volatile_copy_memory			    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);
volatile_copy_nonoverlapping_memory			    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,
volatile_load			    pub fn volatile_load<T>(src: *const T) -> T;
volatile_set_memory			    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);
volatile_store			    pub fn volatile_store<T>(dst: *mut T, val: T);
width			    pub fn width(&self) -> Option<usize> { self.width }
windows			    fn windows(&self, size: usize) -> Windows<T> 
windows			    fn windows<'a>(&'a self, size: usize) -> Windows<'a, Self::Item>;
with_padding			    fn with_padding<F>(&mut self, padding: usize, default: Alignment,
wrapping			pub mod wrapping;
wrapping_add			        pub fn wrapping_add(self, rhs: Self) -> Self 
wrapping_div			        pub fn wrapping_div(self, rhs: Self) -> Self 
wrapping_mul			        pub fn wrapping_mul(self, rhs: Self) -> Self 
wrapping_neg			        pub fn wrapping_neg(self) -> Self 
wrapping_rem			        pub fn wrapping_rem(self, rhs: Self) -> Self 
wrapping_shl			        pub fn wrapping_shl(self, rhs: u32) -> Self 
wrapping_shr			        pub fn wrapping_shr(self, rhs: u32) -> Self 
wrapping_sub			        pub fn wrapping_sub(self, rhs: Self) -> Self 
write			pub fn write(output: &mut Write, args: Arguments) -> Result 
write			    fn write(&mut self, bytes: &[u8]);
write			    fn write(&mut self, msg: &[u8]) 
write			    pub fn write(&self, out: &mut [u8]) -> Option<usize> 
write			pub unsafe fn write<T>(dst: *mut T, src: T) 
write_bytes			        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result 
write_bytes			    pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);
write_char			    fn write_char(&mut self, c: char) -> Result 
write_fmt			            fn write_fmt(&mut self, args: Arguments) -> Result 
write_fmt			    fn write_fmt(&mut self, args: Arguments) -> Result 
write_fmt			    pub fn write_fmt(&mut self, fmt: Arguments) -> Result 
write_formatted_parts			    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result 
write_i16			    fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }
write_i32			    fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }
write_i64			    fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }
write_i8			    fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }
write_isize			    fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }
write_str			    fn write_str(&mut self, mut s: &str) -> fmt::Result 
write_str			            fn write_str(&mut self, s: &str) -> Result 
write_str			    fn write_str(&mut self, s: &str) -> Result 
write_str			    fn write_str(&mut self, s: &str) -> Result;
write_str			    pub fn write_str(&mut self, data: &str) -> Result 
write_u16			    fn write_u16(&mut self, i: u16) 
write_u32			    fn write_u32(&mut self, i: u32) 
write_u64			    fn write_u64(&mut self, i: u64) 
write_u8			    fn write_u8(&mut self, i: u8) { self.write(&[i]) }
write_usize			    fn write_usize(&mut self, i: usize) 
zero			    fn zero() -> f32 { 0.0 }
zero			    fn zero() -> f64 { 0.0 }
zero			            fn zero() -> Self { 0 }
zero			            fn zero() -> Self { 0.0 }
zero			    fn zero() -> Self;
zeroed			pub unsafe fn zeroed<T>() -> T 
zip			    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where
