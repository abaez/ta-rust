Adapter			        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);
Adapter			        struct Adapter<Iter> 
Adapter			        struct Adapter<Iter, E> 
Add			        impl Add for 
Add			pub trait Add<RHS=Self> 
Add for Wrapping			        impl Add for Wrapping<
AddAssign			        impl AddAssign for 
AddAssign			pub trait AddAssign<Rhs=Self> 
AddAssign for Wrapping			        impl AddAssign for Wrapping<
Alignment			pub enum Alignment 
Any			impl Any 
Any			impl Any+Send 
Any			pub trait Any: Reflect + 'static 
Any for T			impl<T: Reflect + 'static + ?Sized > Any for T 
Argument			pub struct Argument 
ArgumentV1			impl<'a> ArgumentV1<'a> 
ArgumentV1			pub struct ArgumentV1<'a> 
Arguments			impl<'a> Arguments<'a> 
Arguments			pub struct Arguments<'a> 
AsMut			            impl<T> AsMut<[T]> for [T; 
AsMut			impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> 
AsMut			impl<T> AsMut<[T]> for [T] 
AsMut			pub trait AsMut<T: ?Sized> 
AsRef			            impl<T> AsRef<[T]> for [T; 
AsRef			impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U> 
AsRef			impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> 
AsRef			impl<T> AsRef<[T]> for [T] 
AsRef			pub trait AsRef<T: ?Sized> 
AsRef for str			impl AsRef<str> for str 
AsRef for str			impl AsRef<[u8]> for str 
AtomicBool			impl AtomicBool 
AtomicBool			pub struct AtomicBool 
AtomicIsize			impl AtomicIsize 
AtomicIsize			pub struct AtomicIsize 
AtomicPtr			impl<T> AtomicPtr<T> 
AtomicPtr			pub struct AtomicPtr<T> 
AtomicUsize			impl AtomicUsize 
AtomicUsize			pub struct AtomicUsize 
Binary			pub trait Binary 
Binary			struct Binary;
BitAnd			        impl BitAnd for 
BitAnd			pub trait BitAnd<RHS=Self> 
BitAnd for Wrapping			        impl BitAnd for Wrapping<
BitAndAssign			        impl BitAndAssign for 
BitAndAssign			pub trait BitAndAssign<Rhs=Self> 
BitAndAssign for Wrapping			        impl BitAndAssign for Wrapping<
BitOr			        impl BitOr for 
BitOr			pub trait BitOr<RHS=Self> 
BitOr for Wrapping			        impl BitOr for Wrapping<
BitOrAssign			        impl BitOrAssign for 
BitOrAssign			pub trait BitOrAssign<Rhs=Self> 
BitOrAssign for Wrapping			        impl BitOrAssign for Wrapping<
BitXor			        impl BitXor for 
BitXor			pub trait BitXor<RHS=Self> 
BitXor for Wrapping			        impl BitXor for Wrapping<
BitXorAssign			        impl BitXorAssign for 
BitXorAssign			pub trait BitXorAssign<Rhs=Self> 
BitXorAssign for Wrapping			        impl BitXorAssign for Wrapping<
Borrow			            impl<T> Borrow<[T]> for [T; 
Borrow			impl<'a, T: ?Sized> Borrow<T> for &'a T 
Borrow			impl<'a, T: ?Sized> Borrow<T> for &'a mut T 
Borrow			pub trait Borrow<Borrowed: ?Sized> 
Borrow for T			impl<T: ?Sized> Borrow<T> for T 
BorrowMut			            impl<T> BorrowMut<[T]> for [T; 
BorrowMut			impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T 
BorrowMut			pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> 
BorrowMut for T			impl<T: ?Sized> BorrowMut<T> for T 
BorrowRef			impl<'b> BorrowRef<'b> 
BorrowRef			struct BorrowRef<'b> 
BorrowRefMut			impl<'b> BorrowRefMut<'b> 
BorrowRefMut			struct BorrowRefMut<'b> 
BorrowState			pub enum BorrowState 
BoxPlace			pub trait BoxPlace<Data: ?Sized> : Place<Data> 
Boxed			pub trait Boxed 
BuildHasher			pub trait BuildHasher 
BuildHasher for BuildHasherDefault			impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> 
BuildHasher for T			impl<T: HashState> BuildHasher for T 
BuildHasherDefault			pub struct BuildHasherDefault<H>(marker::PhantomData<H>);
Bytes			pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);
Cell			impl<T:Copy> Cell<T> 
Cell			pub struct Cell<T> 
Chain			pub struct Chain<A, B> 
ChainState			enum ChainState 
CharEq			impl<'a> CharEq for &'a [char] 
CharEq			trait CharEq 
CharEq for F			impl<F> CharEq for F where F: FnMut(char) -> bool 
CharEq for char			impl CharEq for char 
CharEqPattern			struct CharEqPattern<C: CharEq>(C);
CharEqSearcher			struct CharEqSearcher<'a, C: CharEq> 
CharExt			pub trait CharExt 
CharExt for char			impl CharExt for char 
CharIndices			impl<'a> CharIndices<'a> 
CharIndices			pub struct CharIndices<'a> 
CharPredicateSearcher			pub struct CharPredicateSearcher<'a, F>(<CharEqPattern<F> as Pattern<'a>>::Searcher)
CharRange			pub struct CharRange 
CharSearcher			pub struct CharSearcher<'a>(<CharEqPattern<char> as Pattern<'a>>::Searcher);
CharSliceSearcher			pub struct CharSliceSearcher<'a, 'b>(<CharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);
Chars			impl<'a> Chars<'a> 
Chars			pub struct Chars<'a> 
Chunks			pub struct Chunks<'a, T:'a> 
ChunksMut			pub struct ChunksMut<'a, T:'a> 
Clone			            impl<T:Copy> Clone for [T; 
Clone			        impl Clone for 
Clone			impl<'a, T: ?Sized> Clone for &'a T 
Clone			pub trait Clone : Sized 
Clone			        impl<T:?Sized> Clone for 
Clone			        impl<Ret, 
Clone			impl<T: ?Sized> Clone for *const T 
Clone			impl<T: ?Sized> Clone for *mut T 
Clone			            impl<
Clone for ArgumentV1			impl<'a> Clone for ArgumentV1<'a> 
Clone for BorrowRef			impl<'b> Clone for BorrowRef<'b> 
Clone for BuildHasherDefault			impl<H> Clone for BuildHasherDefault<H> 
Clone for Cell			impl<T:Copy> Clone for Cell<T> 
Clone for Chunks			impl<'a, T> Clone for Chunks<'a, T> 
Clone for Empty			impl<T> Clone for Empty<T> 
Clone for Iter			impl<'a, A> Clone for Iter<'a, A> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for Iter			impl<'a, T> Clone for Iter<'a, T> 
Clone for RefCell			impl<T: Clone> Clone for RefCell<T> 
Clone for Shared			impl<T: ?Sized> Clone for Shared<T> 
Clone for SipHasher			impl Clone for SipHasher 
Clone for Slice			impl<T> Clone for Slice<T> 
Clone for Split			impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool 
Clone for Windows			impl<'a, T> Clone for Windows<'a, T> 
Cloned			pub struct Cloned<I> 
CoerceUnsized			pub trait CoerceUnsized<T> 
CoerceUnsized			impl<T: ?Sized, U: ?Sized> CoerceUnsized<Shared<U>> for Shared<T> where T: Unsize<U> { }
CoerceUnsized			impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }
Copy			        impl<T:?Sized> Copy for 
Copy			pub trait Copy : Clone 
Copy for Shared			impl<T: ?Sized> Copy for Shared<T> { }
Copy for Slice			impl<T> Copy for Slice<T> {}
Count			pub enum Count 
Cycle			pub struct Cycle<I> 
Debug			        impl<
Debug			    impl Debug for 
Debug			impl Debug for () 
Debug			impl<T: Debug> Debug for [T] 
Debug			impl<T> Debug for *const T 
Debug			impl<T> Debug for *mut T 
Debug			pub trait Debug 
Debug for Arguments			impl<'a> Debug for Arguments<'a> 
Debug for Cell			impl<T: Copy + Debug> Debug for Cell<T> 
Debug for PhantomData			impl<T: ?Sized> Debug for PhantomData<T> 
Debug for Ref			impl<'b, T: ?Sized + Debug> Debug for Ref<'b, T> 
Debug for RefCell			impl<T: ?Sized + Debug> Debug for RefCell<T> 
Debug for RefMut			impl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> 
Debug for bool			impl Debug for bool 
Debug for char			impl Debug for char 
Debug for str			impl Debug for str 
DebugInner			impl<'a, 'b: 'a> DebugInner<'a, 'b> 
DebugInner			struct DebugInner<'a, 'b: 'a> 
DebugList			impl<'a, 'b: 'a> DebugList<'a, 'b> 
DebugList			pub struct DebugList<'a, 'b: 'a> 
DebugMap			impl<'a, 'b: 'a> DebugMap<'a, 'b> 
DebugMap			pub struct DebugMap<'a, 'b: 'a> 
DebugSet			impl<'a, 'b: 'a> DebugSet<'a, 'b> 
DebugSet			pub struct DebugSet<'a, 'b: 'a> 
DebugStruct			impl<'a, 'b: 'a> DebugStruct<'a, 'b> 
DebugStruct			pub struct DebugStruct<'a, 'b: 'a> 
DebugTuple			impl<'a, 'b: 'a> DebugTuple<'a, 'b> 
DebugTuple			pub struct DebugTuple<'a, 'b: 'a> 
Decimal			struct Decimal;
Decimal			impl<'a> Decimal<'a> 
Decimal			pub struct Decimal<'a> 
DecodableFloat			pub trait DecodableFloat: Float + Copy 
DecodableFloat for f32			impl DecodableFloat for f32 
DecodableFloat for f64			impl DecodableFloat for f64 
Decoded			pub struct Decoded 
Default			        impl<T> Default for [T; 
Default			        impl<T> Default for [T; 
Default			        impl Default for 
Default			pub trait Default: Sized 
Default			        impl<T:?Sized> Default for 
Default			impl<'a, T> Default for &'a [T] 
Default			impl<'a, T> Default for &'a mut [T] 
Default			impl<'a> Default for &'a str 
Default			            impl<
Default for AtomicBool			impl Default for AtomicBool 
Default for AtomicIsize			impl Default for AtomicIsize 
Default for AtomicPtr			impl<T> Default for AtomicPtr<T> 
Default for AtomicUsize			impl Default for AtomicUsize 
Default for BuildHasherDefault			impl<H> Default for BuildHasherDefault<H> 
Default for Cell			impl<T:Default + Copy> Default for Cell<T> 
Default for Empty			impl<T> Default for Empty<T> 
Default for Option			impl<T> Default for Option<T> 
Default for RefCell			impl<T:Default> Default for RefCell<T> 
Default for SipHasher			impl Default for SipHasher 
Deref			impl<'a, T: ?Sized> Deref for &'a T 
Deref			impl<'a, T: ?Sized> Deref for &'a mut T 
Deref			pub trait Deref 
Deref for NonZero			impl<T: Zeroable> Deref for NonZero<T> 
Deref for Ref			impl<'b, T: ?Sized> Deref for Ref<'b, T> 
Deref for RefMut			impl<'b, T: ?Sized> Deref for RefMut<'b, T> 
Deref for Shared			impl<T: ?Sized> Deref for Shared<T> 
Deref for Unique			impl<T:?Sized> Deref for Unique<T> 
DerefMut			impl<'a, T: ?Sized> DerefMut for &'a mut T 
DerefMut			pub trait DerefMut: Deref 
DerefMut for RefMut			impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> 
Display			    impl Display for 
Display			pub trait Display 
Display for Arguments			impl<'a> Display for Arguments<'a> 
Display for Error			impl Display for Error 
Display for bool			impl Display for bool 
Display for char			impl Display for char 
Display for str			impl Display for str 
Div			        impl Div for 
Div			pub trait Div<RHS=Self> 
Div for Wrapping			        impl Div for Wrapping<
DivAssign			        impl DivAssign for 
DivAssign			pub trait DivAssign<Rhs=Self> 
DivAssign for Wrapping			        impl DivAssign for Wrapping<
DoubleEndedIterator			impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I 
DoubleEndedIterator			pub trait DoubleEndedIterator: Iterator 
DoubleEndedIterator			        impl<'a, T> DoubleEndedIterator for 
DoubleEndedIterator for Bytes			impl<'a> DoubleEndedIterator for Bytes<'a> 
DoubleEndedIterator for Chain			impl<A, B> DoubleEndedIterator for Chain<A, B> where
DoubleEndedIterator for CharIndices			impl<'a> DoubleEndedIterator for CharIndices<'a> 
DoubleEndedIterator for Chars			impl<'a> DoubleEndedIterator for Chars<'a> 
DoubleEndedIterator for Chunks			impl<'a, T> DoubleEndedIterator for Chunks<'a, T> 
DoubleEndedIterator for ChunksMut			impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> 
DoubleEndedIterator for Cloned			impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>
DoubleEndedIterator for Empty			impl<T> DoubleEndedIterator for Empty<T> 
DoubleEndedIterator for Enumerate			impl<I> DoubleEndedIterator for Enumerate<I> where
DoubleEndedIterator for Filter			impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>
DoubleEndedIterator for FilterMap			impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>
DoubleEndedIterator for FlatMap			impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> where
DoubleEndedIterator for Fuse			impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator 
DoubleEndedIterator for Inspect			impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>
DoubleEndedIterator for IntoIter			impl<A> DoubleEndedIterator for IntoIter<A> 
DoubleEndedIterator for IntoIter			impl<T> DoubleEndedIterator for IntoIter<T> 
DoubleEndedIterator for Item			impl<A> DoubleEndedIterator for Item<A> 
DoubleEndedIterator for Iter			impl<'a, A> DoubleEndedIterator for Iter<'a, A> 
DoubleEndedIterator for Iter			impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
DoubleEndedIterator for IterMut			impl<'a, A> DoubleEndedIterator for IterMut<'a, A> 
DoubleEndedIterator for IterMut			impl<'a, T> DoubleEndedIterator for IterMut<'a, T> 
DoubleEndedIterator for Lines			impl<'a> DoubleEndedIterator for Lines<'a> 
DoubleEndedIterator for LinesAny			impl<'a> DoubleEndedIterator for LinesAny<'a> 
DoubleEndedIterator for Map			impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where
DoubleEndedIterator for Once			impl<T> DoubleEndedIterator for Once<T> 
DoubleEndedIterator for RangeInclusive			impl<A> DoubleEndedIterator for RangeInclusive<A> where
DoubleEndedIterator for Repeat			impl<A: Clone> DoubleEndedIterator for Repeat<A> 
DoubleEndedIterator for Rev			impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator 
DoubleEndedIterator for Split			impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool 
DoubleEndedIterator for SplitMut			impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where
DoubleEndedIterator for Windows			impl<'a, T> DoubleEndedIterator for Windows<'a, T> 
DoubleEndedIterator for Zip			impl<A, B> DoubleEndedIterator for Zip<A, B> where
DoubleEndedIterator for ops			impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where
DoubleEndedSearcher			pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}
DoubleEndedSearcher for CharEqSearcher			impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}
DoubleEndedSearcher for CharPredicateSearcher			impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F>
DoubleEndedSearcher for CharSearcher			impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}
DoubleEndedSearcher for CharSliceSearcher			impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}
Drop			pub trait Drop 
Drop for BorrowRef			impl<'b> Drop for BorrowRef<'b> 
Drop for BorrowRefMut			impl<'b> Drop for BorrowRefMut<'b> 
Empty			pub struct Empty<T>(marker::PhantomData<T>);
EmptyNeedle			struct EmptyNeedle 
Enumerate			pub struct Enumerate<I> 
Eq			            impl<T:Eq> Eq for [T; 
Eq			            impl Eq for 
Eq			    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}
Eq			    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}
Eq			pub trait Eq: PartialEq<Self> 
Eq			        impl<Ret, 
Eq			impl<T: ?Sized> Eq for *const T {}
Eq			impl<T: ?Sized> Eq for *mut T {}
Eq			impl<T: Eq> Eq for [T] {}
Eq			            impl<
Eq for Cell			impl<T:Eq + Copy> Eq for Cell<T> {}
Eq for Ordering			impl Eq for Ordering {}
Eq for RefCell			impl<T: ?Sized + Eq> Eq for RefCell<T> {}
Eq for str			    impl Eq for str {}
Error			pub struct Error;
EscapeDefault			pub struct EscapeDefault 
EscapeDefaultState			enum EscapeDefaultState 
EscapeUnicode			pub struct EscapeUnicode 
EscapeUnicodeState			enum EscapeUnicodeState 
ExactSizeIterator			impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}
ExactSizeIterator			pub trait ExactSizeIterator: Iterator 
ExactSizeIterator for Bytes			impl<'a> ExactSizeIterator for Bytes<'a> 
ExactSizeIterator for Chunks			impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}
ExactSizeIterator for ChunksMut			impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}
ExactSizeIterator for Cloned			impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>
ExactSizeIterator for Empty			impl<T> ExactSizeIterator for Empty<T> 
ExactSizeIterator for Enumerate			impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}
ExactSizeIterator for Fuse			impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}
ExactSizeIterator for Inspect			impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F> where
ExactSizeIterator for IntoIter			impl<A> ExactSizeIterator for IntoIter<A> {}
ExactSizeIterator for IntoIter			impl<T> ExactSizeIterator for IntoIter<T> {}
ExactSizeIterator for Item			impl<A> ExactSizeIterator for Item<A> {}
ExactSizeIterator for Iter			impl<'a, A> ExactSizeIterator for Iter<'a, A> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for Iter			impl<'a, T> ExactSizeIterator for Iter<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for IterMut			impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}
ExactSizeIterator for Map			impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F> where
ExactSizeIterator for Once			impl<T> ExactSizeIterator for Once<T> 
ExactSizeIterator for Peekable			impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}
ExactSizeIterator for Rev			impl<I> ExactSizeIterator for Rev<I>
ExactSizeIterator for Skip			impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}
ExactSizeIterator for Take			impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}
ExactSizeIterator for Windows			impl<'a, T> ExactSizeIterator for Windows<'a, T> {}
ExactSizeIterator for Zip			impl<A, B> ExactSizeIterator for Zip<A, B>
ExactSizeIterator for ops			        impl ExactSizeIterator for ops::Range<
Extend			pub trait Extend<A> 
Filter			pub struct Filter<I, P> 
FilterMap			pub struct FilterMap<I, F> 
FixedSizeArray			pub unsafe trait FixedSizeArray<T> 
FlagV1			enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }
FlatMap			pub struct FlatMap<I, U: IntoIterator, F> 
Float			pub trait Float: Sized 
Float for f32			impl Float for f32 
Float for f64			impl Float for f64 
FloatErrorKind			enum FloatErrorKind 
Fn			    impl<'a,A,F:?Sized> Fn<A> for &'a F
Fn			pub trait Fn<Args> : FnMut<Args> 
Fn for LinesAnyMap			impl<'a> Fn<(&'a str,)> for LinesAnyMap 
FnMut			    impl<'a,A,F:?Sized> FnMut<A> for &'a F
FnMut			    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F
FnMut			pub trait FnMut<Args> : FnOnce<Args> 
FnMut for LinesAnyMap			impl<'a> FnMut<(&'a str,)> for LinesAnyMap 
FnOnce			    impl<'a,A,F:?Sized> FnOnce<A> for &'a F
FnOnce			    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F
FnOnce			pub trait FnOnce<Args> 
FnOnce for LinesAnyMap			impl<'a> FnOnce<(&'a str,)> for LinesAnyMap 
FormatSpec			pub struct FormatSpec 
Formatted			impl<'a> Formatted<'a> 
Formatted			pub struct Formatted<'a> 
Formatter			impl<'a> Formatter<'a> 
Formatter			pub struct Formatter<'a> 
Fp			impl Fp 
Fp			pub struct Fp 
FpCategory			pub enum FpCategory 
From			pub trait From<T>: Sized 
From			        impl From<
From for T			impl<T> From<T> for T 
FromIterator			pub trait FromIterator<A>: Sized 
FromStr			        impl FromStr for 
FromStr			        impl FromStr for 
FromStr			pub trait FromStr: Sized 
FromStr for bool			impl FromStr for bool 
FromStrRadixHelper			trait FromStrRadixHelper: PartialOrd + Copy 
FullDecoded			pub enum FullDecoded 
FullOps			            impl FullOps for 
FullOps			pub trait FullOps 
Fuse			pub struct Fuse<I> 
GenericRadix			        impl GenericRadix for 
GenericRadix			trait GenericRadix 
GenericRadix for Radix			impl GenericRadix for Radix 
GenericSplitN			struct GenericSplitN<I> 
Hash			            impl<T: Hash> Hash for [T; 
Hash			            impl Hash for 
Hash			            impl Hash for () 
Hash			            impl<
Hash			    impl<'a, T: ?Sized + Hash> Hash for &'a T 
Hash			    impl<'a, T: ?Sized + Hash> Hash for &'a mut T 
Hash			    impl<T: Hash> Hash for [T] 
Hash			    impl<T> Hash for *const T 
Hash			    impl<T> Hash for *mut T 
Hash			pub trait Hash 
Hash			        impl<T:?Sized> Hash for 
Hash for bool			    impl Hash for bool 
Hash for char			    impl Hash for char 
Hash for str			    impl Hash for str 
HashState			pub trait HashState 
Hasher			pub trait Hasher 
Hasher for SipHasher			impl Hasher for SipHasher 
InPlace			pub trait InPlace<Data: ?Sized>: Place<Data> 
Index			pub trait Index<Idx: ?Sized> 
IndexMut			pub trait IndexMut<Idx: ?Sized>: Index<Idx> 
Inspect			impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) 
Inspect			pub struct Inspect<I, F> 
Int			trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +
IntErrorKind			enum IntErrorKind 
Into			pub trait Into<T>: Sized 
Into for T			impl<T, U> Into<U> for T where U: From<T> 
IntoIter			pub struct IntoIter<A> { inner: Item<A> }
IntoIter			pub struct IntoIter<T> { inner: Option<T> }
IntoIterator			            impl<'a, T> IntoIterator for &'a [T; 
IntoIterator			            impl<'a, T> IntoIterator for &'a mut [T; 
IntoIterator			pub trait IntoIterator 
IntoIterator			impl<'a, T> IntoIterator for &'a Option<T> 
IntoIterator			impl<'a, T> IntoIterator for &'a mut Option<T> 
IntoIterator			impl<'a, T, E> IntoIterator for &'a Result<T, E> 
IntoIterator			impl<'a, T, E> IntoIterator for &'a mut Result<T, E> 
IntoIterator			impl<'a, T> IntoIterator for &'a [T] 
IntoIterator			impl<'a, T> IntoIterator for &'a mut [T] 
IntoIterator for I			impl<I: Iterator> IntoIterator for I 
IntoIterator for Option			impl<T> IntoIterator for Option<T> 
IntoIterator for Result			impl<T, E> IntoIterator for Result<T, E> 
Item			struct Item<A> 
Iter			pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }
Iter			pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }
Iter			impl<'a, T> Iter<'a, T> 
Iter			pub struct Iter<'a, T: 'a> 
IterMut			pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }
IterMut			pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }
IterMut			impl<'a, T> IterMut<'a, T> 
IterMut			pub struct IterMut<'a, T: 'a> 
Iterator			impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I 
Iterator			pub trait Iterator 
Iterator			        impl<'a, 
Iterator			        impl<'a, T> Iterator for 
Iterator for Bytes			impl<'a> Iterator for Bytes<'a> 
Iterator for Chain			impl<A, B> Iterator for Chain<A, B> where
Iterator for CharIndices			impl<'a> Iterator for CharIndices<'a> 
Iterator for Chars			impl<'a> Iterator for Chars<'a> 
Iterator for Chunks			impl<'a, T> Iterator for Chunks<'a, T> 
Iterator for ChunksMut			impl<'a, T> Iterator for ChunksMut<'a, T> 
Iterator for Cloned			impl<'a, I, T: 'a> Iterator for Cloned<I>
Iterator for Cycle			impl<I> Iterator for Cycle<I> where I: Clone + Iterator 
Iterator for Empty			impl<T> Iterator for Empty<T> 
Iterator for Enumerate			impl<I> Iterator for Enumerate<I> where I: Iterator 
Iterator for EscapeDefault			impl Iterator for EscapeDefault 
Iterator for EscapeUnicode			impl Iterator for EscapeUnicode 
Iterator for Filter			impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool 
Iterator for FilterMap			impl<B, I: Iterator, F> Iterator for FilterMap<I, F>
Iterator for FlatMap			impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>
Iterator for Fuse			impl<I> Iterator for Fuse<I> where I: Iterator 
Iterator for Inspect			impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) 
Iterator for IntoIter			impl<A> Iterator for IntoIter<A> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for Item			impl<A> Iterator for Item<A> 
Iterator for Iter			impl<'a, A> Iterator for Iter<'a, A> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, A> Iterator for IterMut<'a, A> 
Iterator for IterMut			impl<'a, T> Iterator for IterMut<'a, T> 
Iterator for Lines			impl<'a> Iterator for Lines<'a> 
Iterator for LinesAny			impl<'a> Iterator for LinesAny<'a> 
Iterator for Map			impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B 
Iterator for Once			impl<T> Iterator for Once<T> 
Iterator for Peekable			impl<I: Iterator> Iterator for Peekable<I> 
Iterator for RangeInclusive			impl<A> Iterator for RangeInclusive<A> where
Iterator for Repeat			impl<A: Clone> Iterator for Repeat<A> 
Iterator for Rev			impl<I> Iterator for Rev<I> where I: DoubleEndedIterator 
Iterator for Scan			impl<B, I, St, F> Iterator for Scan<I, St, F> where
Iterator for SizeHint			        impl<A> Iterator for SizeHint<A> 
Iterator for Skip			impl<I> Iterator for Skip<I> where I: Iterator 
Iterator for SkipWhile			impl<I: Iterator, P> Iterator for SkipWhile<I, P>
Iterator for Split			impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool 
Iterator for SplitMut			impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
Iterator for StepBy			impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> 
Iterator for StepBy			impl<A> Iterator for StepBy<A, RangeFrom<A>> where
Iterator for Take			impl<I> Iterator for Take<I> where I: Iterator
Iterator for TakeWhile			impl<I: Iterator, P> Iterator for TakeWhile<I, P>
Iterator for Windows			impl<'a, T> Iterator for Windows<'a, T> 
Iterator for Zip			impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator
Iterator for ops			impl<A: Step + One> Iterator for ops::Range<A> where
Iterator for ops			impl<A: Step + One> Iterator for ops::RangeFrom<A> where
Lines			pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);
LinesAny			pub struct LinesAny<'a>(Lines<'a>);
LinesAnyMap			struct LinesAnyMap;
LowerExp			    impl LowerExp for 
LowerExp			pub trait LowerExp 
LowerHex			pub trait LowerHex 
LowerHex			struct LowerHex;
Map			pub struct Map<I, F> 
MatchIndices			        struct MatchIndices;
MatchIndicesInternal			struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);
MatchOnly			enum MatchOnly { }
Matches			        struct Matches;
MatchesInternal			struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);
Mul			        impl Mul for 
Mul			pub trait Mul<RHS=Self> 
Mul for Wrapping			        impl Mul for Wrapping<
MulAssign			        impl MulAssign for 
MulAssign			pub trait MulAssign<Rhs=Self> 
MulAssign for Wrapping			        impl MulAssign for Wrapping<
MutableByteVector			    impl MutableByteVector for [u8] 
MutableByteVector			    pub trait MutableByteVector 
Neg			        impl Neg for 
Neg			pub trait Neg 
NonZero			impl<T: Zeroable> NonZero<T> 
NonZero			pub struct NonZero<T: Zeroable>(T);
Not			        impl Not for 
Not			pub trait Not 
Not for Wrapping			        impl Not for Wrapping<
Octal			pub trait Octal 
Octal			struct Octal;
Once			pub struct Once<T> 
One			        impl One for 
One			pub trait One: Sized 
Option			impl<'a, T: Clone> Option<&'a T> 
Option			impl<T: Default> Option<T> 
Option			impl<T> Option<T> 
Option			pub enum Option<T> 
Ord			            impl<T:Ord> Ord for [T; 
Ord			            impl Ord for 
Ord			    impl Ord for () 
Ord			    impl<'a, A: ?Sized> Ord for &'a A where A: Ord 
Ord			    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord 
Ord			pub trait Ord: Eq + PartialOrd<Self> 
Ord			        impl<Ret, 
Ord			impl<T: ?Sized> Ord for *const T 
Ord			impl<T: ?Sized> Ord for *mut T 
Ord			impl<T: Ord> Ord for [T] 
Ord			            impl<
Ord for Ordering			impl Ord for Ordering 
Ord for bool			    impl Ord for bool 
Ord for str			    impl Ord for str 
Ordering			impl Ordering 
Ordering			pub enum Ordering 
Ordering			pub enum Ordering 
OverflowingOps			        impl OverflowingOps for 
OverflowingOps			pub trait OverflowingOps 
PadAdapter			impl<'a, 'b: 'a> PadAdapter<'a, 'b> 
PadAdapter			struct PadAdapter<'a, 'b: 'a> 
ParseBoolError			pub struct ParseBoolError { _priv: () }
ParseFloatError			impl ParseFloatError 
ParseFloatError			pub struct ParseFloatError 
ParseIntError			impl ParseIntError 
ParseIntError			pub struct ParseIntError { kind: IntErrorKind }
ParseResult			pub enum ParseResult<'a> 
Part			impl<'a> Part<'a> 
Part			pub enum Part<'a> 
PartialEq			        impl<'a, 'b, A: 
PartialEq			        impl<'a, 'b, A: 
PartialEq			            impl PartialEq for 
PartialEq			    impl PartialEq for () 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> 
PartialEq			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> 
PartialEq			pub trait PartialEq<Rhs: ?Sized = Self> 
PartialEq			        impl<Ret, 
PartialEq			impl<T: ?Sized> PartialEq for *const T 
PartialEq			impl<T: ?Sized> PartialEq for *mut T 
PartialEq			impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> 
PartialEq			            impl<
PartialEq for Cell			impl<T:PartialEq + Copy> PartialEq for Cell<T> 
PartialEq for RefCell			impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> 
PartialEq for str			    impl PartialEq for str 
PartialOrd			            impl<T:PartialOrd> PartialOrd for [T; 
PartialOrd			            impl PartialOrd for 
PartialOrd			    impl PartialOrd for () 
PartialOrd			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> 
PartialOrd			    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> 
PartialOrd			pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> 
PartialOrd			        impl<Ret, 
PartialOrd			impl<T: ?Sized> PartialOrd for *const T 
PartialOrd			impl<T: ?Sized> PartialOrd for *mut T 
PartialOrd			impl<T: PartialOrd> PartialOrd for [T] 
PartialOrd			            impl<
PartialOrd for Ordering			impl PartialOrd for Ordering 
PartialOrd for bool			    impl PartialOrd for bool 
PartialOrd for str			    impl PartialOrd for str 
Pattern			impl<'a, 'b> Pattern<'a> for &'b &'b str 
Pattern			impl<'a, 'b> Pattern<'a> for &'b [char] 
Pattern			impl<'a, 'b> Pattern<'a> for &'b str 
Pattern			pub trait Pattern<'a>: Sized 
Pattern for CharEqPattern			impl<'a, C: CharEq> Pattern<'a> for CharEqPattern<C> 
Pattern for F			impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool 
Pattern for char			impl<'a> Pattern<'a> for char 
Peekable			impl<I: Iterator> Peekable<I> 
Peekable			pub struct Peekable<I: Iterator> 
PhantomData			pub struct PhantomData<T:?Sized>;
Place			pub trait Place<Data: ?Sized> 
Placer			pub trait Placer<Data: ?Sized> 
Pointer			impl<'a, T: ?Sized> Pointer for &'a T 
Pointer			impl<'a, T: ?Sized> Pointer for &'a mut T 
Pointer			impl<T: ?Sized> Pointer for *const T 
Pointer			impl<T: ?Sized> Pointer for *mut T 
Pointer			pub trait Pointer 
Position			pub enum Position 
RMatchIndices			        struct RMatchIndices;
RMatches			        struct RMatches;
RSplit			        struct RSplit;
RSplitN			pub struct RSplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool 
RSplitN			        struct RSplitN;
RSplitNMut			pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool 
RSplitTerminator			        struct RSplitTerminator;
Radix			impl Radix 
Radix			pub struct Radix 
RadixFmt			pub struct RadixFmt<T, R>(T, R);
Range			pub struct Range<Idx> 
RangeFrom			impl<A: Step> RangeFrom<A> 
RangeFrom			pub struct RangeFrom<Idx> 
RangeFull			pub struct RangeFull;
RangeInclusive			pub struct RangeInclusive<A> 
RangeTo			pub struct RangeTo<Idx> 
RawFloat			pub trait RawFloat : Float + Copy + Debug + LowerExp
RawFloat for f32			impl RawFloat for f32 
RawFloat for f64			impl RawFloat for f64 
Ref			impl<'b, T: ?Sized> Ref<'b, T> 
Ref			pub struct Ref<'b, T: ?Sized + 'b> 
RefCell			impl<T: ?Sized> RefCell<T> 
RefCell			impl<T> RefCell<T> 
RefCell			pub struct RefCell<T: ?Sized> 
RefMut			impl<'b, T: ?Sized> RefMut<'b, T> 
RefMut			pub struct RefMut<'b, T: ?Sized + 'b> 
Reflect			impl Reflect for .. { }
Reflect			pub trait Reflect {}
RejectAndMatch			enum RejectAndMatch { }
Rem			        impl Rem for 
Rem			pub trait Rem<RHS=Self> 
Rem for Wrapping			        impl Rem for Wrapping<
RemAssign			        impl RemAssign for 
RemAssign			pub trait RemAssign<Rhs=Self> 
RemAssign for Wrapping			        impl RemAssign for Wrapping<
Repeat			pub struct Repeat<A> 
Repr			pub unsafe trait Repr<T> 
Repr			unsafe impl Repr<Slice<u8>> for str {}
Repr			unsafe impl<T> Repr<Slice<T>> for [T] {}
Result			impl<T, E: fmt::Debug> Result<T, E> 
Result			impl<T, E> Result<T, E> 
Result			impl<T: fmt::Debug, E> Result<T, E> 
Result			pub enum Result<T, E> 
Rev			pub struct Rev<T> 
ReverseSearcher			pub unsafe trait ReverseSearcher<'a>: Searcher<'a> 
ReverseSearcher for CharEqSearcher			unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> 
ReverseSearcher for CharPredicateSearcher			unsafe impl<'a, F> ReverseSearcher<'a> for CharPredicateSearcher<'a, F>
ReverseSearcher for CharSearcher			unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> 
ReverseSearcher for CharSliceSearcher			unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> 
ReverseSearcher for StrSearcher			unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> 
Scan			pub struct Scan<I, St, F> 
SearchStep			pub enum SearchStep 
Searcher			pub unsafe trait Searcher<'a> 
Searcher for CharEqSearcher			unsafe impl<'a, C: CharEq> Searcher<'a> for CharEqSearcher<'a, C> 
Searcher for CharPredicateSearcher			unsafe impl<'a, F> Searcher<'a> for CharPredicateSearcher<'a, F>
Searcher for CharSearcher			unsafe impl<'a> Searcher<'a> for CharSearcher<'a> 
Searcher for CharSliceSearcher			unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> 
Searcher for StrSearcher			unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> 
Send			    unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}
Send			    unsafe impl<'a, T: Sync + ?Sized> Send for &'a T {}
Send			pub unsafe trait Send 
Send			unsafe impl Send for .. { }
Send for AtomicPtr			unsafe impl<T> Send for AtomicPtr<T> {}
Send for Cell			unsafe impl<T> Send for Cell<T> where T: Send {}
Send for Iter			unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}
Send for IterMut			unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}
Send for RefCell			unsafe impl<T: ?Sized> Send for RefCell<T> where T: Send {}
Send for Unique			unsafe impl<T: Send + ?Sized> Send for Unique<T> { }
Shared			impl<T: ?Sized> Shared<T> 
Shared			pub struct Shared<T: ?Sized> 
Shl			        impl Shl<
Shl			pub trait Shl<RHS> 
Shl for Wrapping			        impl Shl<
ShlAssign			        impl ShlAssign<
ShlAssign			pub trait ShlAssign<Rhs> 
ShlAssign for Wrapping			        impl ShlAssign<
Shr			        impl Shr<
Shr			pub trait Shr<RHS> 
Shr for Wrapping			        impl Shr<
ShrAssign			        impl ShrAssign<
ShrAssign			pub trait ShrAssign<Rhs=Self> 
ShrAssign for Wrapping			        impl ShrAssign<
Sign			pub enum Sign 
Sign			pub enum Sign 
SipHasher			impl SipHasher 
SipHasher			pub struct SipHasher 
SizeHint			        struct SizeHint<A>(usize, Option<usize>, marker::PhantomData<A>);
Sized			pub trait Sized 
Skip			pub struct Skip<I> 
SkipWhile			pub struct SkipWhile<I, P> 
Slice			pub struct Slice<T> 
SliceExt			impl<T> SliceExt for [T] 
SliceExt			pub trait SliceExt 
Split			pub struct Split<'a, T:'a, P> where P: FnMut(&T) -> bool 
Split			        struct Split;
SplitInternal			struct SplitInternal<'a, P: Pattern<'a>> 
SplitIter			trait SplitIter: DoubleEndedIterator 
SplitIter for Split			impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool 
SplitIter for SplitMut			impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool 
SplitMut			pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool 
SplitN			pub struct SplitN<'a, T: 'a, P> where P: FnMut(&T) -> bool 
SplitN			        struct SplitN;
SplitNInternal			struct SplitNInternal<'a, P: Pattern<'a>> 
SplitNMut			pub struct SplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool 
SplitTerminator			        struct SplitTerminator;
Step			        impl Step for 
Step			pub trait Step: PartialOrd + Sized 
StepBy			pub struct StepBy<A, R> 
StrExt			pub trait StrExt 
StrExt for str			impl StrExt for str 
StrSearcher			impl<'a, 'b> StrSearcher<'a, 'b> 
StrSearcher			pub struct StrSearcher<'a, 'b> 
StrSearcherImpl			enum StrSearcherImpl 
Sub			        impl Sub for 
Sub			pub trait Sub<RHS=Self> 
Sub for Wrapping			        impl Sub for Wrapping<
SubAssign			        impl SubAssign for 
SubAssign			pub trait SubAssign<Rhs=Self> 
SubAssign for Wrapping			        impl SubAssign for Wrapping<
Sync			pub unsafe trait Sync 
Sync			unsafe impl Sync for .. { }
Sync for AtomicBool			unsafe impl Sync for AtomicBool {}
Sync for AtomicIsize			unsafe impl Sync for AtomicIsize {}
Sync for AtomicPtr			unsafe impl<T> Sync for AtomicPtr<T> {}
Sync for AtomicUsize			unsafe impl Sync for AtomicUsize {}
Sync for Iter			unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}
Sync for IterMut			unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}
Sync for Unique			unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }
Take			pub struct Take<I> 
TakeWhile			pub struct TakeWhile<I, P> 
TraitObject			pub struct TraitObject 
TwoWaySearcher			impl TwoWaySearcher 
TwoWaySearcher			struct TwoWaySearcher 
TwoWayStrategy			trait TwoWayStrategy 
TwoWayStrategy for MatchOnly			impl TwoWayStrategy for MatchOnly 
TwoWayStrategy for RejectAndMatch			impl TwoWayStrategy for RejectAndMatch 
TypeId			impl TypeId 
TypeId			pub struct TypeId 
Unique			impl<T: ?Sized> Unique<T> 
Unique			pub struct Unique<T: ?Sized> 
Unpacked			impl Unpacked 
Unpacked			pub struct Unpacked 
UnsafeCell			impl<T: ?Sized> UnsafeCell<T> 
UnsafeCell			impl<T> UnsafeCell<T> 
UnsafeCell			pub struct UnsafeCell<T: ?Sized> 
Unsize			pub trait Unsize<T: ?Sized> 
UpperExp			    impl UpperExp for 
UpperExp			pub trait UpperExp 
UpperHex			pub trait UpperHex 
UpperHex			struct UpperHex;
Utf8Error			impl Utf8Error 
Utf8Error			pub struct Utf8Error 
Void			enum Void {}
Windows			pub struct Windows<'a, T:'a> 
Wrapping			pub struct Wrapping<T>(#[stable(feature = "rust1", since = "1.0.0")] pub T);
Write			impl<'a, W: Write + ?Sized> Write for &'a mut W 
Write			pub trait Write 
Write for Adapter			        impl<'a, T: ?Sized> Write for Adapter<'a, T>
Write for Formatter			impl<'a> Write for Formatter<'a> 
Zero			        impl Zero for 
Zero			pub trait Zero: Sized 
Zeroable			pub unsafe trait Zeroable {}
Zeroable			unsafe impl<T:?Sized> Zeroable for *const T {}
Zeroable			unsafe impl<T:?Sized> Zeroable for *mut T {}
Zeroable for i16			unsafe impl Zeroable for i16 {}
Zeroable for i32			unsafe impl Zeroable for i32 {}
Zeroable for i64			unsafe impl Zeroable for i64 {}
Zeroable for i8			unsafe impl Zeroable for i8 {}
Zeroable for isize			unsafe impl Zeroable for isize {}
Zeroable for u16			unsafe impl Zeroable for u16 {}
Zeroable for u32			unsafe impl Zeroable for u32 {}
Zeroable for u64			unsafe impl Zeroable for u64 {}
Zeroable for u8			unsafe impl Zeroable for u8 {}
Zeroable for usize			unsafe impl Zeroable for usize {}
Zip			pub struct Zip<A, B> 
__description			    pub fn __description(&self) -> &str 
__description			    pub fn __description(&self) -> &str 
_assert_is_object_safe			fn _assert_is_object_safe(_: &Iterator<Item=()>) {}
abort			    pub fn abort() -> !;
abs			    fn abs(self) -> f32 
abs			    fn abs(self) -> f64 
abs			        pub fn abs(self) -> Self 
abs			    fn abs(self) -> Self;
add			            pub fn add<'a>(&'a mut self, other: &
add			            fn add(self, other: Wrapping<
add			            fn add(self, other: 
add			    fn add(self, rhs: RHS) -> Self::Output;
add_assign			            fn add_assign(&mut self, other: Wrapping<
add_assign			            fn add_assign(&mut self, other: 
add_assign			    fn add_assign(&mut self, Rhs);
add_small			            pub fn add_small(&mut self, other: 
add_with_overflow			    pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);
algorithm			mod algorithm;
algorithm_m			pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T 
algorithm_r			fn algorithm_r<T: RawFloat>(f: &Big, e: i16, z0: T) -> T 
align			    pub fn align(&self) -> Alignment { self.align }
align_of			pub fn align_of<T>() -> usize 
align_of_val			pub fn align_of_val<T: ?Sized>(val: &T) -> usize 
all			    fn all<F>(&mut self, mut f: F) -> bool where
alternate			    pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }
and			    pub fn and<U>(self, optb: Option<U>) -> Option<U> 
and			    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> 
and_then			    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> 
and_then			    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> 
any			    fn any<F>(&mut self, mut f: F) -> bool where
any			pub mod any;
arith_offset			    pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;
array			pub mod array;
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8];
as_mut			                fn as_mut(&mut self) -> &mut [T] 
as_mut			    fn as_mut(&mut self) -> &mut T;
as_mut			    fn as_mut(&mut self) -> &mut U 
as_mut			    fn as_mut(&mut self) -> &mut [T] 
as_mut			    pub fn as_mut(&mut self) -> Option<&mut T> 
as_mut			    pub unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> where T: Sized 
as_mut			    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> 
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut Self::Item;
as_mut_ptr			    fn as_mut_ptr(&mut self) -> *mut T 
as_mut_slice			    fn as_mut_slice(&mut self) -> &mut [T] 
as_mut_slice			    fn as_mut_slice(&mut self) -> &mut [T];
as_ptr			    fn as_ptr(&self) -> *const Self::Item;
as_ptr			    fn as_ptr(&self) -> *const T 
as_ptr			    fn as_ptr(&self) -> *const u8 
as_ptr			    fn as_ptr(&self) -> *const u8;
as_ref			                fn as_ref(&self) -> &[T] 
as_ref			    fn as_ref(&self) -> &T;
as_ref			    fn as_ref(&self) -> &U 
as_ref			    fn as_ref(&self) -> &[T] 
as_ref			    fn as_ref(&self) -> &str 
as_ref			    pub fn as_ref(&self) -> Option<&T> 
as_ref			    pub unsafe fn as_ref<'a>(&self) -> Option<&'a T> where T: Sized 
as_ref			    pub fn as_ref(&self) -> Result<&T, &E> 
as_ref			    fn as_ref(&self) -> &[u8] 
as_slice			    fn as_slice(&self) -> &[T] 
as_slice			    fn as_slice(&self) -> &[T];
as_slice			    pub fn as_slice(&self) -> &'a [T] 
as_str			    pub fn as_str(&self) -> &'a str 
as_unsafe_cell			    pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> 
as_usize			    fn as_usize(&self) -> Option<usize> 
assert_receiver_is_total_eq			    fn assert_receiver_is_total_eq(&self) {}
assume			    pub fn assume(b: bool);
atomic			pub mod atomic;
atomic_add			unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and			    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;
atomic_and			unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_and_acq			    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;
atomic_and_acqrel			    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_and_rel			    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;
atomic_and_relaxed			    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_compare_exchange			unsafe fn atomic_compare_exchange<T>(dst: *mut T,
atomic_compare_exchange_weak			unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,
atomic_cxchg			    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acq			    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acq_failrelaxed			    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acqrel			    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_acqrel_failrelaxed			    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_failacq			    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_failrelaxed			    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_rel			    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchg_relaxed			    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;
atomic_cxchgweak			    pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_acq			    pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_acq_failrelaxed			    pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_acqrel			    pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_acqrel_failrelaxed			    pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_failacq			    pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_failrelaxed			    pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_rel			    pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_cxchgweak_relaxed			    pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);
atomic_fence			    pub fn atomic_fence();
atomic_fence_acq			    pub fn atomic_fence_acq();
atomic_fence_acqrel			    pub fn atomic_fence_acqrel();
atomic_fence_rel			    pub fn atomic_fence_rel();
atomic_load			    pub fn atomic_load<T>(src: *const T) -> T;
atomic_load			unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T 
atomic_load_acq			    pub fn atomic_load_acq<T>(src: *const T) -> T;
atomic_load_relaxed			    pub fn atomic_load_relaxed<T>(src: *const T) -> T;
atomic_load_unordered			    pub fn atomic_load_unordered<T>(src: *const T) -> T;
atomic_max			    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;
atomic_max_acq			    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;
atomic_max_acqrel			    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_max_rel			    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;
atomic_max_relaxed			    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_min			    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;
atomic_min_acq			    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;
atomic_min_acqrel			    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_min_rel			    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;
atomic_min_relaxed			    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_nand			    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;
atomic_nand			unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_nand_acq			    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;
atomic_nand_acqrel			    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_nand_rel			    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;
atomic_nand_relaxed			    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_or			    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;
atomic_or			unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_or_acq			    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;
atomic_or_acqrel			    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_or_rel			    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;
atomic_or_relaxed			    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_singlethreadfence			    pub fn atomic_singlethreadfence();
atomic_singlethreadfence_acq			    pub fn atomic_singlethreadfence_acq();
atomic_singlethreadfence_acqrel			    pub fn atomic_singlethreadfence_acqrel();
atomic_singlethreadfence_rel			    pub fn atomic_singlethreadfence_rel();
atomic_store			    pub fn atomic_store<T>(dst: *mut T, val: T);
atomic_store			unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) 
atomic_store_rel			    pub fn atomic_store_rel<T>(dst: *mut T, val: T);
atomic_store_relaxed			    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);
atomic_store_unordered			    pub fn atomic_store_unordered<T>(dst: *mut T, val: T);
atomic_sub			unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_swap			unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_umax			    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;
atomic_umax_acq			    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;
atomic_umax_acqrel			    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umax_rel			    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;
atomic_umax_relaxed			    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_umin			    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;
atomic_umin_acq			    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;
atomic_umin_acqrel			    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_umin_rel			    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;
atomic_umin_relaxed			    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xadd			    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acq			    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;
atomic_xadd_acqrel			    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_rel			    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;
atomic_xadd_relaxed			    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xchg			    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acq			    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;
atomic_xchg_acqrel			    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_rel			    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;
atomic_xchg_relaxed			    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xor			    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;
atomic_xor			unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T 
atomic_xor_acq			    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;
atomic_xor_acqrel			    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xor_rel			    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;
atomic_xor_relaxed			    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;
atomic_xsub			    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acq			    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;
atomic_xsub_acqrel			    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_rel			    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;
atomic_xsub_relaxed			    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;
base			            fn base(&self) -> u8 { 
base			    fn base(&self) -> u8 
base			    fn base(&self) -> u8;
bellerophon			pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T 
big_to_fp			pub fn big_to_fp(f: &Big) -> Fp 
bignum			pub mod bignum;
binary_search			    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize>
binary_search			    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord 
binary_search_by			    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>
binary_search_by			    fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize> where
bit_length			            pub fn bit_length(&self) -> usize 
bitand			            fn bitand(self, other: Wrapping<
bitand			            fn bitand(self, rhs: 
bitand			    fn bitand(self, rhs: RHS) -> Self::Output;
bitand_assign			            fn bitand_assign(&mut self, other: Wrapping<
bitand_assign			            fn bitand_assign(&mut self, other: 
bitand_assign			    fn bitand_assign(&mut self, Rhs);
bitor			            fn bitor(self, other: Wrapping<
bitor			            fn bitor(self, rhs: 
bitor			    fn bitor(self, rhs: RHS) -> Self::Output;
bitor_assign			            fn bitor_assign(&mut self, other: Wrapping<
bitor_assign			            fn bitor_assign(&mut self, other: 
bitor_assign			    fn bitor_assign(&mut self, Rhs);
bitxor			            fn bitxor(self, other: Wrapping<
bitxor			            fn bitxor(self, other: 
bitxor			    fn bitxor(self, rhs: RHS) -> Self::Output;
bitxor_assign			            fn bitxor_assign(&mut self, other: Wrapping<
bitxor_assign			            fn bitxor_assign(&mut self, other: 
bitxor_assign			    fn bitxor_assign(&mut self, Rhs);
borrow			                fn borrow(&self) -> &[T] 
borrow			    fn borrow(&self) -> &Borrowed;
borrow			    fn borrow(&self) -> &T { &**self }
borrow			    fn borrow(&self) -> &T { self }
borrow			    pub fn borrow(&self) -> Ref<T> 
borrow			pub mod borrow;
borrow_mut			                fn borrow_mut(&mut self) -> &mut [T] 
borrow_mut			    fn borrow_mut(&mut self) -> &mut Borrowed;
borrow_mut			    fn borrow_mut(&mut self) -> &mut T { &mut **self }
borrow_mut			    fn borrow_mut(&mut self) -> &mut T { self }
borrow_mut			    pub fn borrow_mut(&self) -> RefMut<T> 
borrow_state			    pub fn borrow_state(&self) -> BorrowState 
bound_intermediate_digits			fn bound_intermediate_digits(decimal: &Decimal, e: i64) -> u64 
breakpoint			    pub fn breakpoint();
bswap			    pub fn bswap<T>(x: T) -> T;
build_hasher			    fn build_hasher(&self) -> H 
build_hasher			    fn build_hasher(&self) -> Self::Hasher;
build_hasher			    fn build_hasher(&self) -> T::Hasher { self.hasher() }
builders			mod builders;
by_ref			    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }
bytes			pub mod bytes 
bytes			    fn bytes(&self) -> Bytes 
bytes			    fn bytes(&self) -> Bytes;
byteset_contains			    fn byteset_contains(&self, byte: u8) -> bool 
byteset_create			    fn byteset_create(bytes: &[u8]) -> u64 
cached_power			pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) 
call			        extern "rust-call" fn call(&self, args: A) -> F::Output 
call			    extern "rust-call" fn call(&self, args: Args) -> Self::Output;
call			    extern "rust-call" fn call(&self, (line,): (&'a str,)) -> &'a str 
call_mut			        extern "rust-call" fn call_mut(&mut self, args: A) -> F::Output 
call_mut			    extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
call_mut			    extern "rust-call" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str 
call_once			        extern "rust-call" fn call_once(mut self, args: A) -> F::Output 
call_once			        extern "rust-call" fn call_once(self, args: A) -> F::Output 
call_once			    extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
call_once			    extern "rust-call" fn call_once(self, (line,): (&'a str,)) -> &'a str 
ceil_log5_of_max_sig			    fn ceil_log5_of_max_sig() -> i16 
ceil_log5_of_max_sig			    fn ceil_log5_of_max_sig() -> i16;
ceilf32			    pub fn ceilf32(x: f32) -> f32;
ceilf64			    pub fn ceilf64(x: f64) -> f64;
cell			pub mod cell;
chain			    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where
char			pub mod char;
char_at			    fn char_at(&self, i: usize) -> char 
char_at			    fn char_at(&self, i: usize) -> char;
char_at_reverse			    fn char_at_reverse(&self, i: usize) -> char 
char_at_reverse			    fn char_at_reverse(&self, i: usize) -> char;
char_indices			    fn char_indices(&self) -> CharIndices 
char_indices			    fn char_indices(&self) -> CharIndices;
char_range_at			    fn char_range_at(&self, i: usize) -> CharRange 
char_range_at			    fn char_range_at(&self, start: usize) -> CharRange;
char_range_at_raw			fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: usize) -> CharRange 
char_range_at_reverse			    fn char_range_at_reverse(&self, start: usize) -> CharRange;
chars			    fn chars(&self) -> Chars 
chars			    fn chars(&self) -> Chars;
checked_add			        fn checked_add(&self, other: u32) -> Option<Self> 
checked_add			        pub fn checked_add(self, other: Self) -> Option<Self> 
checked_add			    fn checked_add(&self, other: u32) -> Option<Self>;
checked_div			        pub fn checked_div(self, other: Self) -> Option<Self> 
checked_mul			        fn checked_mul(&self, other: u32) -> Option<Self> 
checked_mul			        pub fn checked_mul(self, other: Self) -> Option<Self> 
checked_mul			    fn checked_mul(&self, other: u32) -> Option<Self>;
checked_neg			        pub fn checked_neg(self) -> Option<Self> 
checked_next_power_of_two			        pub fn checked_next_power_of_two(self) -> Option<Self> 
checked_rem			        pub fn checked_rem(self, other: Self) -> Option<Self> 
checked_shl			        pub fn checked_shl(self, rhs: u32) -> Option<Self> 
checked_shr			        pub fn checked_shr(self, rhs: u32) -> Option<Self> 
checked_sub			        fn checked_sub(&self, other: u32) -> Option<Self> 
checked_sub			        pub fn checked_sub(self, other: Self) -> Option<Self> 
checked_sub			    fn checked_sub(&self, other: u32) -> Option<Self>;
chunks			    fn chunks(&self, size: usize) -> Chunks<Self::Item>;
chunks			    fn chunks(&self, size: usize) -> Chunks<T> 
chunks_mut			    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;
chunks_mut			    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> 
classify			    fn classify(self) -> Fp 
classify			    fn classify(self) -> Fp 
classify			    fn classify(self) -> FpCategory;
clone			                fn clone(&self) -> [T; 
clone			    fn clone(&self) -> BorrowRef<'b> 
clone			    fn clone(&self) -> Cell<T> 
clone			    fn clone(&self) -> RefCell<T> 
clone			    pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> 
clone			            fn clone(&self) -> 
clone			    fn clone(&self) -> &'a T { *self }
clone			    fn clone(&self) -> Self;
clone			    fn clone(&self) -> ArgumentV1<'a> 
clone			    fn clone(&self) -> BuildHasherDefault<H> 
clone			    fn clone(&self) -> SipHasher 
clone			    fn clone(&self) -> Empty<T> 
clone			pub mod clone;
clone			            fn clone(&self) -> 
clone			            fn clone(&self) -> 
clone			    fn clone(&self) -> Iter<'a, A> 
clone			            fn clone(&self) -> Self 
clone			    fn clone(&self) -> *const T 
clone			    fn clone(&self) -> *mut T 
clone			    fn clone(&self) -> Self 
clone			    fn clone(&self) -> Slice<T> { *self }
clone			    fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }
clone			    fn clone(&self) -> Chunks<'a, T> 
clone			    fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }
clone			    fn clone(&self) -> Split<'a, T, P> 
clone			    fn clone(&self) -> Windows<'a, T> 
clone			            fn clone(&self) -> Self 
clone			                fn clone(&self) -> (
clone_from			    fn clone_from(&mut self, source: &Self) 
clone_from_slice			    fn clone_from_slice(&mut self, &[Self::Item]) where Self::Item: Clone;
clone_from_slice			    fn clone_from_slice(&mut self, src: &[T]) where T: Clone 
cloned			    fn cloned<'a, T: 'a>(self) -> Cloned<Self>
cloned			    pub fn cloned(self) -> Option<T> 
cmp			                fn cmp(&self, other: &[T; 
cmp			                fn cmp(&self, other: &
cmp			        fn cmp(&self, _other: &()) -> Ordering { Equal }
cmp			        fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }
cmp			        fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }
cmp			        fn cmp(&self, other: &bool) -> Ordering 
cmp			    fn cmp(&self, other: &Ordering) -> Ordering 
cmp			    fn cmp(&self, other: &Self) -> Ordering;
cmp			    fn cmp<I>(mut self, other: I) -> Ordering where
cmp			pub mod cmp;
cmp			            fn cmp(&self, _other: &
cmp			        impl<T:?Sized> cmp::Eq for 
cmp			        impl<T:?Sized> cmp::Ord for 
cmp			        impl<T:?Sized> cmp::PartialEq for 
cmp			        impl<T:?Sized> cmp::PartialOrd for 
cmp			            fn cmp(&self, other: &
cmp			            fn cmp(&self, other: &Self) -> Ordering 
cmp			    fn cmp(&self, other: &*const T) -> Ordering 
cmp			    fn cmp(&self, other: &*mut T) -> Ordering 
cmp			    fn cmp(&self, other: &[T]) -> Ordering 
cmp			        fn cmp(&self, other: &str) -> Ordering 
cmp			                fn cmp(&self, other: &(
cmp_slice			unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 
collect			    fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized 
compare_and_swap			    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T 
compare_and_swap			    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool 
compare_and_swap			    pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize 
compare_and_swap			    pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize 
compare_exchange			    pub fn compare_exchange(&self,
compare_exchange_weak			    pub fn compare_exchange_weak(&self,
compare_with_half_ulp			pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering 
consts			pub mod consts 
consts			pub mod consts 
contains			    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;
contains			    fn contains(&self, x: &T) -> bool where T: PartialEq 
contains			    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 
contains			    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;
contains_nonascii			fn contains_nonascii(x: usize) -> bool 
convert			pub mod convert;
convert			fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, ParseFloatError> 
copy			    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);
copy_from_slice			    fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;
copy_from_slice			    fn copy_from_slice(&mut self, src: &[T]) where T: Copy 
copy_memory			    pub fn copy_memory(src: &[u8], dst: &mut [u8]) 
copy_nonoverlapping			    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);
copysignf32			    pub fn copysignf32(x: f32, y: f32) -> f32;
copysignf64			    pub fn copysignf64(x: f64, y: f64) -> f64;
cosf32			    pub fn cosf32(x: f32) -> f32;
cosf64			    pub fn cosf64(x: f64) -> f64;
count			    fn count(self) -> usize 
count			    fn count(self) -> usize where Self: Sized 
count			    fn count(self) -> usize 
count			            fn count(self) -> usize 
count			    fn count(self) -> usize 
count			    fn count(self) -> usize 
count_ones			        pub fn count_ones(self) -> u32 { (self as 
count_ones			        pub fn count_ones(self) -> u32 
count_zeros			        pub fn count_zeros(self) -> u32 
ctlz			    pub fn ctlz<T>(x: T) -> T;
ctpop			    pub fn ctpop<T>(x: T) -> T;
cttz			    pub fn cttz<T>(x: T) -> T;
cycle			    fn cycle(self) -> Cycle<Self> where Self: Sized + Clone 
debug_list			    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> 
debug_list_new			pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> 
debug_map			    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> 
debug_map_new			pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> 
debug_set			    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> 
debug_set_new			pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> 
debug_struct			    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> 
debug_struct_new			pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,
debug_tuple			    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> 
debug_tuple_new			pub fn debug_tuple_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str) -> DebugTuple<'a, 'b> 
dec2flt			fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> 
dec2flt			pub mod dec2flt;
decode			pub fn decode<T: DecodableFloat>(v: T) -> (\/*negative?*\/ bool, FullDecoded) 
decoder			pub mod decoder;
default			            fn default() -> [T; 
default			            fn default() -> [T; 
default			    fn default() -> Cell<T> 
default			    fn default() -> RefCell<T> 
default			            fn default() -> 
default			    fn default() -> Self;
default			    fn default() -> BuildHasherDefault<H> 
default			    fn default() -> SipHasher 
default			    fn default() -> Empty<T> 
default			pub mod default;
default			            fn default() -> 
default			    fn default() -> Option<T> { None }
default			    fn default() -> &'a [T] { &[] }
default			    fn default() -> &'a mut [T] { &mut [] }
default			    fn default() -> &'a str { "" }
default			    fn default() -> AtomicPtr<T> 
default			    fn default() -> Self 
default			                fn default() -> (
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &Self::Target;
deref			    fn deref(&self) -> &T { *self }
deref			    fn deref(&self) -> &*mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut Self::Target;
deref_mut			    fn deref_mut(&mut self) -> &mut T { *self }
determine_sign			fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] 
digit			            fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8 
digit			    fn digit(&self, x: u8) -> u8;
digits			            pub fn digits(&self) -> &[
digits_to_big			pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big 
digits_to_dec_str			fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,
digits_to_exp_str			fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,
discriminant_value			    pub fn discriminant_value<T>(v: &T) -> u64;
div			            fn div(self, other: Wrapping<
div			            fn div(self, other: 
div			    fn div(self, rhs: RHS) -> Self::Output;
div_2pow10			fn div_2pow10(x: &mut Big, mut n: usize) -> &mut Big 
div_assign			            fn div_assign(&mut self, other: Wrapping<
div_assign			            fn div_assign(&mut self, other: 
div_assign			    fn div_assign(&mut self, Rhs);
div_rem			            pub fn div_rem(&self, d: &
div_rem_small			            pub fn div_rem_small(&mut self, other: 
div_rem_upto_16			fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,
diy_float			pub mod diy_float;
do_inspect			    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> 
downcast_mut			    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> 
downcast_ref			    pub fn downcast_ref<T: Any>(&self) -> Option<&T> 
dragon			    pub mod dragon;
drop			    fn drop(&mut self) 
drop			pub fn drop<T>(_x: T) { }
drop			    fn drop(&mut self);
drop_in_place			    pub fn drop_in_place<T: ?Sized>(to_drop: *mut T);
dropped			pub unsafe fn dropped<T>() -> T 
dropped_impl			    unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }
eat_digits			fn eat_digits(s: &[u8]) -> (&[u8], &[u8]) 
empty			pub fn empty<T>() -> Empty<T> 
encode_normal			pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T 
encode_subnormal			pub fn encode_subnormal<T: RawFloat>(significand: u64) -> T 
encode_utf16			    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> 
encode_utf16			    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;
encode_utf16_raw			pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> 
encode_utf8			    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> 
encode_utf8			    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;
encode_utf8_raw			pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> 
ends_with			    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
ends_with			    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq 
ends_with			    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool
entries			    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>
entries			    pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>
entries			    pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>
entry			    fn entry(&mut self, entry: &fmt::Debug) 
entry			    pub fn entry(&mut self, entry: &fmt::Debug) -> &mut DebugList<'a, 'b> 
entry			    pub fn entry(&mut self, entry: &fmt::Debug) -> &mut DebugSet<'a, 'b> 
entry			    pub fn entry(&mut self, key: &fmt::Debug, value: &fmt::Debug) -> &mut DebugMap<'a, 'b> 
enumerate			    fn enumerate(self) -> Enumerate<Self> where Self: Sized 
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			    fn eq(&self, other: &Cell<T>) -> bool 
eq			    fn eq(&self, other: &RefCell<T>) -> bool 
eq			                fn eq(&self, other: &
eq			        fn eq(&self, _other: &()) -> bool { true }
eq			        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }
eq			        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }
eq			        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }
eq			    fn eq(&self, other: &Rhs) -> bool;
eq			    fn eq<I>(mut self, other: I) -> bool where
eq			            fn eq(&self, _other: &
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &Self) -> bool 
eq			    fn eq(&self, other: &*const T) -> bool { *self == *other }
eq			    fn eq(&self, other: &*mut T) -> bool { *self == *other }
eq			    fn eq(&self, other: &[B]) -> bool 
eq			        fn eq(&self, other: &str) -> bool 
eq			                fn eq(&self, other: &(
eq_slice			fn eq_slice(a: &str, b: &str) -> bool 
err			    pub fn err(self) -> Option<E> 
escape_default			    fn escape_default(self) -> EscapeDefault 
escape_default			    fn escape_default(self) -> EscapeDefault;
escape_unicode			    fn escape_unicode(self) -> EscapeUnicode 
escape_unicode			    fn escape_unicode(self) -> EscapeUnicode;
estimate_max_buf_len			fn estimate_max_buf_len(exp: i16) -> usize 
estimate_scaling_factor			pub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 
estimator			pub mod estimator;
exp2f32			    pub fn exp2f32(x: f32) -> f32;
exp2f64			    pub fn exp2f64(x: f64) -> f64;
exp_bits			    fn exp_bits() -> u8 
exp_bits			    fn exp_bits() -> u8;
expect			    pub fn expect(self, msg: &str) -> T 
expect			    pub fn expect(self, msg: &str) -> T 
expect_failed			fn expect_failed(msg: &str) -> ! 
expf32			    pub fn expf32(x: f32) -> f32;
expf64			    pub fn expf64(x: f64) -> f64;
explicit_sig_bits			    fn explicit_sig_bits() -> u8 
extend			    fn extend<T: IntoIterator<Item=A>>(&mut self, iterable: T);
extract_sign			fn extract_sign(s: &str) -> (Sign, &str) 
fabsf32			    pub fn fabsf32(x: f32) -> f32;
fabsf64			    pub fn fabsf64(x: f64) -> f64;
fast_path			pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> 
fence			pub fn fence(order: Ordering) 
fetch_add			    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize 
fetch_add			    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize 
fetch_and			    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool 
fetch_and			    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize 
fetch_and			    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize 
fetch_nand			    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool 
fetch_or			    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize 
fetch_or			    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize 
fetch_sub			    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize 
fetch_sub			    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize 
fetch_xor			    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool 
fetch_xor			    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize 
fetch_xor			    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize 
field			    pub fn field(&mut self, name: &str, value: &fmt::Debug) -> &mut DebugStruct<'a, 'b> 
field			    pub fn field(&mut self, value: &fmt::Debug) -> &mut DebugTuple<'a, 'b> 
fill			    pub fn fill(&self) -> char { self.fill }
filter			    fn filter<P>(self, predicate: P) -> Filter<Self, P> where
filter_map			    pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Option<Ref<'b, U>>
filter_map			    pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Option<RefMut<'b, U>>
filter_map			    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where
finalize			    unsafe fn finalize(filled: Self::Place) -> Self;
finalize			    unsafe fn finalize(self) -> Self::Owner;
find			    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where
find			    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> 
find			    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;
find_str			    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> 
find_str			    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;
finish			    pub fn finish(&mut self) -> fmt::Result 
finish			    pub fn finish(&mut self) 
finish			    fn finish(&self) -> u64;
finish			    fn finish(&self) -> u64 
finish			    fn finish(&mut self) -> Option<&'a [T]> 
finish			    fn finish(&mut self) -> Option<&'a mut [T]> 
finish			    fn finish(&mut self) -> Option<Self::Item>;
first			    fn first(&self) -> Option<&Self::Item>;
first			    fn first(&self) -> Option<&T> 
first_mut			    fn first_mut(&mut self) -> Option<&mut Self::Item>;
first_mut			    fn first_mut(&mut self) -> Option<&mut T> 
flags			    pub fn flags(&self) -> u32 { self.flags }
flat_map			    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>
float_macros			mod float_macros;
float_to_decimal_common			fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result
float_to_exponential_common			fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result
floorf32			    pub fn floorf32(x: f32) -> f32;
floorf64			    pub fn floorf64(x: f64) -> f64;
flt2dec			pub mod flt2dec;
fmaf32			    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;
fmaf64			    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            impl<T: fmt::Debug> fmt::Debug for [T; 
fmt			            fn fmt(&self, f: &mut Formatter) -> Result { 
fmt			            fn fmt(&self, f: &mut Formatter) -> Result 
fmt			        fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			    fn fmt(&self, &mut Formatter) -> Result;
fmt			    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }
fmt			    fn fmt(&self, f: &mut Formatter) -> Result 
fmt			    fn fmt(&self, fmt: &mut Formatter) -> Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl fmt::
fmt			        impl fmt::Debug for 
fmt			    impl fmt::Display for 
fmt			pub mod fmt;
fmt			            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl<Ret, 
fmt			        impl<Ret, 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        impl fmt::Debug for 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for Any			impl fmt::Debug for Any + Send 
fmt::Debug for Any			impl fmt::Debug for Any 
fmt::Debug for AtomicPtr			impl<T> fmt::Debug for AtomicPtr<T> 
fmt::Debug for RadixFmt			        impl fmt::Debug for RadixFmt<
fmt::Debug for Range			impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> 
fmt::Debug for RangeFrom			impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> 
fmt::Debug for RangeFull			impl fmt::Debug for RangeFull 
fmt::Debug for RangeTo			impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> 
fmt::Display for ParseBoolError			impl fmt::Display for ParseBoolError 
fmt::Display for ParseFloatError			impl fmt::Display for ParseFloatError 
fmt::Display for ParseIntError			impl fmt::Display for ParseIntError 
fmt::Display for RadixFmt			        impl fmt::Display for RadixFmt<
fmt::Display for Utf8Error			impl fmt::Display for Utf8Error 
fmt::Pointer for Shared			impl<T> fmt::Pointer for Shared<T> 
fmt::Pointer for Unique			impl<T> fmt::Pointer for Unique<T> 
fmt::Write for PadAdapter			impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> 
fmt_int			    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result 
fold			    fn fold<B, F>(self, init: B, mut f: F) -> B where
forget			    pub fn forget<T>(_: T) -> ();
forget			pub fn forget<T>(t: T) 
format_exact			pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_exact			pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_exact_opt			pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)
format_shortest			pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_shortest			pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (\/*#digits*\/ usize, \/*exp*\/ i16) 
format_shortest_opt			pub fn format_shortest_opt(d: &Decoded,
formatter			    pub fn formatter(&mut self) -> &mut fmt::Formatter<'b> 
fp_to_float			pub fn fp_to_float<T: RawFloat>(x: Fp) -> T 
from			    fn from(T) -> Self;
from			    fn from(t: T) -> T { t }
from			            fn from(small: 
from_be			        pub fn from_be(x: Self) -> Self 
from_bits			    fn from_bits(bits: u64) -> Self;
from_bits			    fn from_bits(bits: u64) -> f32 
from_bits			    fn from_bits(bits: u64) -> f64 
from_digit			pub fn from_digit(num: u32, radix: u32) -> Option<char> 
from_int			    fn from_int(x: u64) -> Self;
from_int			    fn from_int(x: u64) -> f32 
from_int			    fn from_int(x: u64) -> f64 
from_iter			    fn from_iter<T: IntoIterator<Item=A>>(iterator: T) -> Self;
from_iter			    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> 
from_iter			    fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> 
from_le			        pub fn from_le(x: Self) -> Self 
from_raw_parts			pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] 
from_raw_parts_mut			pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] 
from_raw_parts_mut			unsafe fn from_raw_parts_mut<'a>(p: *mut u8, len: usize) -> &'a mut str 
from_small			            pub fn from_small(v: 
from_str			            fn from_str(src: &str) -> Result<Self, ParseFloatError> 
from_str			            fn from_str(src: &str) -> Result<Self, ParseIntError> 
from_str			    fn from_str(s: &str) -> Result<Self, Self::Err>;
from_str			    fn from_str(s: &str) -> Result<bool, ParseBoolError> 
from_str_radix			        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> 
from_str_radix			fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)
from_str_unchecked			pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'a u8> 
from_u32			pub fn from_u32(i: u32) -> Option<char> 
from_u32			        fn from_u32(u: u32) -> Self { u as Self }
from_u32			    fn from_u32(u: u32) -> Self;
from_u32_unchecked			pub unsafe fn from_u32_unchecked(i: u32) -> char 
from_u64			            pub fn from_u64(mut v: u64) -> 
from_u8			        fn from_u8(u: u8) -> 
from_u8			    fn from_u8(u: u8) -> Self;
from_usize			    pub fn from_usize(x: &usize) -> ArgumentV1 
from_utf8			pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> 
from_utf8_unchecked			pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str 
full_add			                fn full_add(self, other: 
full_add			    fn full_add(self, other: Self, carry: bool) -> (bool \/*carry*\/, Self);
full_div_rem			                fn full_div_rem(self, other: 
full_div_rem			    fn full_div_rem(self, other: Self, borrow: Self) -> (Self \/*quotient*\/, Self \/*remainder*\/);
full_mul			                fn full_mul(self, other: 
full_mul			    fn full_mul(self, other: Self, carry: Self) -> (Self \/*carry*\/, Self);
full_mul_add			                fn full_mul_add(self, other: 
full_mul_add			    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self \/*carry*\/, Self);
fuse			    fn fuse(self) -> Fuse<Self> where Self: Sized 
ge			                fn ge(&self, other: &[T; 
ge			                fn ge(&self, other: &
ge			        fn ge(&self, other: & &'b B) -> bool { PartialOrd::ge(*self, *other) }
ge			        fn ge(&self, other: &&'b mut B) -> bool { PartialOrd::ge(*self, *other) }
ge			    fn ge(&self, other: &Rhs) -> bool 
ge			    fn ge<I>(mut self, other: I) -> bool where
ge			    fn ge(&self, other: &*const T) -> bool { *self >= *other }
ge			    fn ge(&self, other: &*mut T) -> bool { *self >= *other }
ge			                fn ge(&self, other: &(
get			    pub fn get(&self) -> *mut T 
get			    pub fn get(&self) -> T 
get			    pub unsafe fn get(&self) -> &T 
get			    fn get(&self, index: usize) -> Option<&Self::Item>;
get			    fn get(&self, index: usize) -> Option<&T> 
get_bit			            pub fn get_bit(&self, i: usize) -> u8 
get_bits			pub fn get_bits(x: &Big, start: usize, end: usize) -> u64 
get_end			    fn get_end(&mut self) -> Option<&'a str> 
get_mut			    pub unsafe fn get_mut(&mut self) -> &mut T 
get_mut			    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;
get_mut			    fn get_mut(&mut self, index: usize) -> Option<&mut T> 
get_type_id			    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }
get_type_id			    fn get_type_id(&self) -> TypeId;
get_unchecked			    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;
get_unchecked			    unsafe fn get_unchecked(&self, index: usize) -> &T 
get_unchecked_mut			    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;
get_unchecked_mut			    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T 
getcount			    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> 
grisu			    pub mod grisu;
gt			                fn gt(&self, other: &[T; 
gt			                fn gt(&self, other: &
gt			        fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }
gt			        fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }
gt			    fn gt(&self, other: &Rhs) -> bool 
gt			    fn gt<I>(mut self, other: I) -> bool where
gt			    fn gt(&self, other: &*const T) -> bool { *self > *other }
gt			    fn gt(&self, other: &*mut T) -> bool { *self > *other }
gt			                fn gt(&self, other: &(
hash			                fn hash<H: hash::Hasher>(&self, state: &mut H) 
hash			                fn hash<H: Hasher>(&self, _state: &mut H) {}
hash			                fn hash<H: Hasher>(&self, state: &mut H) 
hash			                fn hash<S: Hasher>(&self, state: &mut S) 
hash			        fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H);
hash			pub mod hash;
hash			            fn hash<H: Hasher>(&self, _: &mut H) 
hash			            fn hash<HH: hash::Hasher>(&self, state: &mut HH) 
hash			        impl<Ret, 
hash_slice			                fn hash_slice<H: Hasher>(data: &[
hash_slice			    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)
hasher			    fn hasher(&self) -> Self::Hasher;
haystack			        fn haystack(&self) -> &'a str 
haystack			    fn haystack(&self) -> &'a str { self.haystack }
haystack			    fn haystack(&self) -> &'a str 
haystack			    fn haystack(&self) -> &'a str;
i16			impl i16 
i32			impl i32 
i64			impl i64 
i8			impl i8 
impls			mod impls 
impls			mod impls 
impls			mod impls 
impls			mod impls 
index			    fn index(&self, index: Idx) -> &Self::Output;
index			    fn index(&self, _index: RangeFull) -> &[T] 
index			    fn index(&self, index: ops::Range<usize>) -> &[T] 
index			    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] 
index			    fn index(&self, index: ops::RangeTo<usize>) -> &[T] 
index			    fn index(&self, index: usize) -> &T 
index			        fn index(&self, _index: ops::RangeFull) -> &str 
index			        fn index(&self, index: ops::Range<usize>) -> &str 
index			        fn index(&self, index: ops::RangeFrom<usize>) -> &str 
index			        fn index(&self, index: ops::RangeTo<usize>) -> &str 
index_mut			    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;
index_mut			    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] 
index_mut			    fn index_mut(&mut self, index: usize) -> &mut T 
index_mut			        fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str 
index_mut			        fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str 
index_mut			        fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str 
index_mut			        fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str 
inf_cutoff			    fn inf_cutoff() -> i64 
inf_cutoff			    fn inf_cutoff() -> i64;
infinity			    fn infinity() -> f32 { INFINITY }
infinity			    fn infinity() -> f64 { INFINITY }
infinity			    fn infinity() -> Self;
init			    pub fn init<T>() -> T;
init_dropped			    pub fn init_dropped<T>() -> T;
inspect			    fn inspect<F>(self, f: F) -> Inspect<Self, F> where
int_macros			mod int_macros;
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    fn integer_decode(self) -> (u64, i16, i8);
into			    fn into(self) -> T;
into			    fn into(self) -> U 
into_inner			    pub fn into_inner(self) -> T 
into_inner			    pub unsafe fn into_inner(self) -> T 
into_iter			                fn into_iter(self) -> Iter<'a, T> 
into_iter			                fn into_iter(self) -> IterMut<'a, T> 
into_iter			    fn into_iter(self) -> I 
into_iter			    fn into_iter(self) -> Self::IntoIter;
into_iter			    fn into_iter(mut self) -> IterMut<'a, T> 
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    fn into_iter(mut self) -> IterMut<'a, T> 
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    fn into_iter(self) -> IterMut<'a, T> 
into_searcher			        fn into_searcher(self, haystack: &'a str) -> 
into_searcher			    fn into_searcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> 
into_searcher			    fn into_searcher(self, haystack: &'a str) -> Self::Searcher;
into_searcher			    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> 
into_slice			    pub fn into_slice(self) -> &'a mut [T] 
intrinsics			pub mod intrinsics;
is			    pub fn is<T: Any>(&self) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: usize) -> bool 
is_char_boundary			    fn is_char_boundary(&self, index: usize) -> bool;
is_contained_in			        fn is_contained_in(self, haystack: &'a str) -> bool 
is_contained_in			    fn is_contained_in(self, haystack: &'a str) -> bool 
is_digit			    fn is_digit(self, radix: u32) -> bool 
is_digit			    fn is_digit(self, radix: u32) -> bool;
is_empty			    pub fn is_empty(&mut self) -> bool 
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    fn is_empty(&self) -> bool;
is_err			    pub fn is_err(&self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool 
is_finite			    fn is_finite(self) -> bool;
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool 
is_infinite			    fn is_infinite(self) -> bool;
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool { self != self }
is_nan			    fn is_nan(self) -> bool;
is_negative			        pub fn is_negative(self) -> bool { self < 0 }
is_none			    pub fn is_none(&self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool 
is_normal			    fn is_normal(self) -> bool;
is_null			    pub fn is_null(self) -> bool where T: Sized 
is_ok			    pub fn is_ok(&self) -> bool 
is_positive			        pub fn is_positive(self) -> bool { self > 0 }
is_power_of_two			        pub fn is_power_of_two(self) -> bool 
is_prefix_of			        fn is_prefix_of(self, haystack: &'a str) -> bool 
is_prefix_of			    fn is_prefix_of(self, haystack: &'a str) -> bool 
is_pretty			    fn is_pretty(&self) -> bool 
is_sign_negative			    fn is_sign_negative(self) -> bool 
is_sign_negative			    fn is_sign_negative(self) -> bool 
is_sign_negative			    fn is_sign_negative(self) -> bool;
is_sign_positive			    fn is_sign_positive(self) -> bool 
is_sign_positive			    fn is_sign_positive(self) -> bool 
is_sign_positive			    fn is_sign_positive(self) -> bool;
is_some			    pub fn is_some(&self) -> bool 
is_suffix_of			        fn is_suffix_of(self, haystack: &'a str) -> bool
is_suffix_of			    fn is_suffix_of(self, haystack: &'a str) -> bool 
is_suffix_of			    fn is_suffix_of(self, haystack: &'a str) -> bool
is_zero			            pub fn is_zero(&self) -> bool 
isize			impl isize 
iter			pub mod iter;
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter(&self) -> Iter<Self::Item>;
iter			    fn iter(&self) -> Iter<T> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<T> 
iter_mut			    fn iter_mut(&mut self) -> IterMut<Self::Item>;
iter_mut			    fn iter_mut(&mut self) -> IterMut<T> 
iter_nth			    fn iter_nth(&mut self, n: usize) -> Option<&'a T> 
iter_nth			    fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> 
last			    fn last(self) -> Option<char> 
last			    fn last(mut self) -> Option<I::Item> 
last			    fn last(self) -> Option<A::Item> 
last			    fn last(self) -> Option<I::Item> 
last			    fn last(self) -> Option<Self::Item> where Self: Sized 
last			            fn last(mut self) -> Option<
last			    fn last(&self) -> Option<&Self::Item>;
last			    fn last(&self) -> Option<&T> 
last			    fn last(self) -> Option<Self::Item> 
last			    fn last(self) -> Option<Self::Item> 
last_mut			    fn last_mut(&mut self) -> Option<&mut Self::Item>;
last_mut			    fn last_mut(&mut self) -> Option<&mut T> 
le			                fn le(&self, other: &[T; 
le			                fn le(&self, other: &
le			        fn le(&self, other: & &'b B) -> bool { PartialOrd::le(*self, *other) }
le			        fn le(&self, other: &&'b mut B) -> bool { PartialOrd::le(*self, *other) }
le			    fn le(&self, other: &Rhs) -> bool 
le			    fn le<I>(mut self, other: I) -> bool where
le			    fn le(&self, other: &*const T) -> bool { *self <= *other }
le			    fn le(&self, other: &*mut T) -> bool { *self <= *other }
le			                fn le(&self, other: &(
leading_zeros			        pub fn leading_zeros(self) -> u32 
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> usize 
len			    fn len(&self) -> usize { self.repr().len }
len			    fn len(&self) -> usize;
len			    fn len(&self) -> usize { self.repr().len }
len			    fn len(&self) -> usize 
len			    fn len(&self) -> usize;
len_utf16			    fn len_utf16(self) -> usize 
len_utf16			    fn len_utf16(self) -> usize;
len_utf8			    fn len_utf8(self) -> usize 
len_utf8			    fn len_utf8(self) -> usize;
lines			    fn lines(&self) -> Lines 
lines			    fn lines(&self) -> Lines;
lines_any			    fn lines_any(&self) -> LinesAny 
lines_any			    fn lines_any(&self) -> LinesAny;
load			    pub fn load(&self, order: Ordering) -> *mut T 
load			    pub fn load(&self, order: Ordering) -> bool 
load			    pub fn load(&self, order: Ordering) -> isize 
load			    pub fn load(&self, order: Ordering) -> usize 
load_u64_le			unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 
log10f32			    pub fn log10f32(x: f32) -> f32;
log10f64			    pub fn log10f64(x: f64) -> f64;
log2f32			    pub fn log2f32(x: f32) -> f32;
log2f64			    pub fn log2f64(x: f64) -> f64;
logf32			    pub fn logf32(x: f32) -> f32;
logf64			    pub fn logf64(x: f64) -> f64;
lt			                fn lt(&self, other: &[T; 
lt			                fn lt(&self, other: &
lt			        fn lt(&self, other: & &'b B) -> bool { PartialOrd::lt(*self, *other) }
lt			        fn lt(&self, other: &&'b mut B) -> bool { PartialOrd::lt(*self, *other) }
lt			    fn lt(&self, other: &Rhs) -> bool 
lt			    fn lt<I>(mut self, other: I) -> bool where
lt			    fn lt(&self, other: &*const T) -> bool { *self < *other }
lt			    fn lt(&self, other: &*mut T) -> bool { *self < *other }
lt			                fn lt(&self, other: &(
macros			mod macros;
make_place			    fn make_place() -> Self;
make_place			    fn make_place(self) -> Self::Place;
make_ratio			fn make_ratio(x: &mut Big, y: &mut Big, e: i16, k: i16) 
map			    pub fn map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>
map			    pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>
map			    fn map<B, F>(self, f: F) -> Map<Self, F> where
map			    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> 
map			    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U,E> 
map_err			    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T,F> 
map_or			    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U 
map_or_else			    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U 
marker			pub mod marker;
match_indices			    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> 
match_indices			    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;
matches			    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> 
matches			    fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P>;
matches			    fn matches(&mut self, c: char) -> bool { (*self)(c) }
matches			    fn matches(&mut self, c: char) -> bool { *self == c }
matches			    fn matches(&mut self, c: char) -> bool 
matches			    fn matches(&mut self, char) -> bool;
matching			    fn matching(a: usize, b: usize) -> Self::Output { SearchStep::Match(a, b) }
matching			    fn matching(a: usize, b: usize) -> Self::Output { Some((a, b)) }
matching			    fn matching(usize, usize) -> Self::Output;
max			pub fn max<T: Ord>(v1: T, v2: T) -> T 
max			    fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord
max_by			    fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where
max_by_key			    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>
max_encoded_exp			    fn max_encoded_exp() -> i16 
max_exp			    fn max_exp() -> i16 
max_exp_int			    fn max_exp_int() -> i16 
max_normal_digits			    fn max_normal_digits() -> usize 
max_normal_digits			    fn max_normal_digits() -> usize;
max_pow10_no_more_than			pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) 
max_sig			    fn max_sig() -> u64 
maximal_suffix			    fn maximal_suffix(arr: &[u8], order_greater: bool) -> (usize, usize) 
mem			pub mod mem;
min			pub fn min<T: Ord>(v1: T, v2: T) -> T 
min			    fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord
min_align_of			    pub fn min_align_of<T>() -> usize;
min_align_of			pub fn min_align_of<T>() -> usize 
min_align_of_val			    pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;
min_align_of_val			pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize 
min_by			    fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where
min_by_key			    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>
min_exp			    fn min_exp() -> i16 
min_exp_int			    fn min_exp_int() -> i16 
min_pos_norm_value			    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }
min_pos_norm_value			    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }
min_pos_norm_value			    fn min_pos_norm_value() -> Self;
min_sig			    fn min_sig() -> u64 
min_value			        fn min_value() -> Self { Self::min_value() }
min_value			    fn min_value() -> Self;
move_val_init			    pub fn move_val_init<T>(dst: *mut T, src: T);
mul			    pub fn mul(&self, other: &Fp) -> Fp 
mul			            fn mul(self, other: Wrapping<
mul			            fn mul(self, other: 
mul			    fn mul(self, rhs: RHS) -> Self::Output;
mul_assign			            fn mul_assign(&mut self, other: Wrapping<
mul_assign			            fn mul_assign(&mut self, other: 
mul_assign			    fn mul_assign(&mut self, Rhs);
mul_digits			            pub fn mul_digits<'a>(&'a mut self, other: &[
mul_inner			                fn mul_inner(ret: &mut [
mul_pow10			pub fn mul_pow10(x: &mut Big, n: usize) -> &mut Big 
mul_pow2			            pub fn mul_pow2(&mut self, bits: usize) -> &mut 
mul_pow5			            pub fn mul_pow5(&mut self, mut e: usize) -> &mut 
mul_small			            pub fn mul_small(&mut self, other: 
mul_with_overflow			    pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);
multibyte_char_range_at			    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) 
multibyte_char_range_at_reverse			        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange 
nan			    fn nan() -> f32 { NAN }
nan			    fn nan() -> f64 { NAN }
nan			    fn nan() -> Self;
ne			            fn ne(&self, other: &
ne			            fn ne(&self, other: &
ne			                fn ne(&self, other: &
ne			        fn ne(&self, _other: &()) -> bool { false }
ne			        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }
ne			        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }
ne			        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }
ne			    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }
ne			    fn ne<I>(mut self, other: I) -> bool where
ne			    fn ne(&self, other: &[B]) -> bool 
ne			        fn ne(&self, other: &str) -> bool { !(*self).eq(other) }
ne			                fn ne(&self, other: &(
nearbyintf32			    pub fn nearbyintf32(x: f32) -> f32;
nearbyintf64			    pub fn nearbyintf64(x: f64) -> f64;
needs_drop			    pub fn needs_drop<T>() -> bool;
neg			            fn neg(self) -> 
neg			    fn neg(self) -> Self::Output;
neg_infinity			    fn neg_infinity() -> f32 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> f64 { NEG_INFINITY }
neg_infinity			    fn neg_infinity() -> Self;
neg_zero			    fn neg_zero() -> f32 { -0.0 }
neg_zero			    fn neg_zero() -> f64 { -0.0 }
neg_zero			    fn neg_zero() -> Self;
new			    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRef<'b>> 
new			    fn new(borrow: &'b Cell<BorrowFlag>) -> Option<BorrowRefMut<'b>> 
new			    fn new(fmt: &'a mut fmt::Formatter<'b>) -> PadAdapter<'a, 'b> 
new			    pub fn new<'b, T>(x: &'b T,
new			    fn new(base: u8) -> Radix 
new			    pub fn new() -> SipHasher 
new			    pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> 
new			    pub fn new(sig: u64, k: i16) -> Self 
new			    pub unsafe fn new(ptr: *mut T) -> Self 
new			    fn new(haystack: &'a str, needle: &'b str) -> StrSearcher<'a, 'b> 
new			    fn new(needle: &[u8], end: usize) -> TwoWaySearcher 
new_v1			    pub fn new_v1(pieces: &'a [&'a str],
new_v1_formatted			    pub fn new_v1_formatted(pieces: &'a [&'a str],
new_with_keys			    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher 
next			    fn next(&mut self) -> Option<char> 
next			            fn next(&mut self) -> Option<A> { None }
next			    fn next(&mut self) -> Option<(A::Item, B::Item)> 
next			    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> 
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }
next			    fn next(&mut self) -> Option<<I as Iterator>::Item> 
next			    fn next(&mut self) -> Option<A::Item> 
next			    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }
next			    fn next(&mut self) -> Option<A> 
next			    fn next(&mut self) -> Option<B> 
next			    fn next(&mut self) -> Option<I::Item> { (**self).next() }
next			    fn next(&mut self) -> Option<I::Item> 
next			    fn next(&mut self) -> Option<Self::Item>;
next			    fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<U::Item> 
next			            fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<&'a A> { self.inner.next() }
next			    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }
next			    fn next(&mut self) -> Option<A> { self.inner.next() }
next			    fn next(&mut self) -> Option<A> 
next			            fn next(&mut self) -> Option<T> 
next			    fn next(&mut self) -> Option<&'a T> { self.inner.take() }
next			    fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }
next			    fn next(&mut self) -> Option<T> { self.inner.take() }
next			            fn next(&mut self) -> Option<
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a [T]> 
next			    fn next(&mut self) -> Option<&'a mut [T]> 
next			    fn next(&mut self) -> Option<T> 
next			            fn next(&mut self) -> Option<
next			    fn next(&mut self) -> Option<&'a str> 
next			    fn next(&mut self) -> Option<(usize, &'a str)> 
next			    fn next(&mut self) -> Option<(usize, char)> 
next			    fn next(&mut self) -> Option<char> 
next			    fn next(&mut self) -> Option<u8> 
next			        fn next(&mut self) -> SearchStep 
next			    fn next(&mut self) -> SearchStep 
next			    fn next(&mut self) -> SearchStep;
next			    fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)
next_back			    fn next_back(&mut self) -> Option<(A::Item, B::Item)> 
next_back			    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> 
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }
next_back			    fn next_back(&mut self) -> Option<<I as Iterator>::Item> 
next_back			    fn next_back(&mut self) -> Option<A::Item> 
next_back			    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<B> 
next_back			    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }
next_back			    fn next_back(&mut self) -> Option<I::Item> 
next_back			    fn next_back(&mut self) -> Option<Self::Item>;
next_back			    fn next_back(&mut self) -> Option<T> 
next_back			    fn next_back(&mut self) -> Option<U::Item> 
next_back			    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<A> 
next_back			    fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }
next_back			    fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }
next_back			    fn next_back(&mut self) -> Option<T> { self.inner.take() }
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a [T]> 
next_back			    fn next_back(&mut self) -> Option<&'a mut [T]> 
next_back			            fn next_back(&mut self) -> Option<
next_back			    fn next_back(&mut self) -> Option<&'a str> 
next_back			    fn next_back(&mut self) -> Option<&'a str>
next_back			    fn next_back(&mut self) -> Option<(usize, &'a str)>
next_back			    fn next_back(&mut self) -> Option<(usize, char)> 
next_back			    fn next_back(&mut self) -> Option<char> 
next_back			    fn next_back(&mut self) -> Option<u8> 
next_back			        fn next_back(&mut self) -> SearchStep 
next_back			    fn next_back(&mut self) -> SearchStep 
next_back			    fn next_back(&mut self) -> SearchStep;
next_back			    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)
next_code_point			pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> 
next_code_point_reverse			fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> 
next_float			pub fn next_float<T: RawFloat>(x: T) -> T 
next_match			        fn next_match(&mut self) -> Option<(usize, usize)> 
next_match			    fn next_match(&mut self) -> Option<(usize, usize)> 
next_match_back			        fn next_match_back(&mut self) -> Option<(usize, usize)> 
next_match_back			    fn next_match_back(&mut self) -> Option<(usize, usize)> 
next_match_back			    fn next_match_back(&mut self) -> Option<(usize, usize)>
next_power_of_two			        pub fn next_power_of_two(self) -> Self 
next_reject			        fn next_reject(&mut self) -> Option<(usize, usize)> 
next_reject			    fn next_reject(&mut self) -> Option<(usize, usize)> 
next_reject_back			        fn next_reject_back(&mut self) -> Option<(usize, usize)> 
next_reject_back			    fn next_reject_back(&mut self) -> Option<(usize, usize)>
nonzero			pub mod nonzero;
normalize			    pub fn normalize(&self) -> Fp 
normalize_to			    pub fn normalize_to(&self, e: i16) -> Fp 
not			            fn not(self) -> Wrapping<
not			            fn not(self) -> 
not			    fn not(self) -> Self::Output;
nth			    fn nth(&mut self, n: usize) -> Option<char> 
nth			    fn nth(&mut self, mut n: usize) -> Option<A::Item> 
nth			    fn nth(&mut self, mut n: usize) -> Option<Self::Item> where Self: Sized 
nth			    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> 
nth			    fn nth(&mut self, n: usize) -> Option<I::Item> 
nth			            fn nth(&mut self, n: usize) -> Option<
nth			    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> 
nth			    fn nth(&mut self, n: usize) -> Option<Self::Item> 
nth			    fn nth(&mut self, n: usize) -> Option<Self::Item> 
num			mod num;
num			pub mod num;
num			mod num;
of			    pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId 
offset			    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;
offset			    pub unsafe fn offset(self, count: isize) -> *const T where T: Sized 
offset			    pub unsafe fn offset(self, count: isize) -> *mut T where T: Sized 
ok			    pub fn ok(self) -> Option<T> 
ok_or			    pub fn ok_or<E>(self, err: E) -> Result<T, E> 
ok_or_else			    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> 
once			pub fn once<T>(value: T) -> Once<T> 
one			    fn one() -> f32 { 1.0 }
one			    fn one() -> f64 { 1.0 }
one			            fn one() -> Self { 1 }
one			            fn one() -> Self { 1.0 }
one			    fn one() -> Self;
only_ascii			    fn only_ascii(&self) -> bool { (*self as u32) < 128 }
only_ascii			    fn only_ascii(&self) -> bool { false }
only_ascii			    fn only_ascii(&self) -> bool 
only_ascii			    fn only_ascii(&self) -> bool;
ops			impl<A: Step> ops::Range<A> 
ops			pub mod ops;
ops			impl<T> ops::Index<RangeFull> for [T] 
ops			impl<T> ops::Index<ops::Range<usize>> for [T] 
ops			impl<T> ops::Index<ops::RangeFrom<usize>> for [T] 
ops			impl<T> ops::Index<ops::RangeTo<usize>> for [T] 
ops			impl<T> ops::Index<usize> for [T] 
ops			impl<T> ops::IndexMut<RangeFull> for [T] 
ops			impl<T> ops::IndexMut<ops::Range<usize>> for [T] 
ops			impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] 
ops			impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] 
ops			impl<T> ops::IndexMut<usize> for [T] 
ops			    impl ops::Index<ops::Range<usize>> for str 
ops			    impl ops::Index<ops::RangeFrom<usize>> for str 
ops			    impl ops::Index<ops::RangeTo<usize>> for str 
ops			    impl ops::IndexMut<ops::Range<usize>> for str 
ops			    impl ops::IndexMut<ops::RangeFrom<usize>> for str 
ops			    impl ops::IndexMut<ops::RangeTo<usize>> for str 
ops::Index for str			    impl ops::Index<ops::RangeFull> for str 
ops::IndexMut for str			    impl ops::IndexMut<ops::RangeFull> for str 
option			pub mod option;
or			    pub fn or(self, optb: Option<T>) -> Option<T> 
or			    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> 
or_else			    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> 
or_else			    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> 
overflowing_add			    pub fn overflowing_add<T>(a: T, b: T) -> T;
overflowing_add			        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) 
overflowing_add			            fn overflowing_add(self, rhs: 
overflowing_add			    fn overflowing_add(self, rhs: Self) -> (Self, bool);
overflowing_div			        pub fn overflowing_div(self, rhs: Self) -> (Self, bool) 
overflowing_div			            fn overflowing_div(self, rhs: 
overflowing_div			    fn overflowing_div(self, rhs: Self) -> (Self, bool);
overflowing_mul			    pub fn overflowing_mul<T>(a: T, b: T) -> T;
overflowing_mul			        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) 
overflowing_mul			            fn overflowing_mul(self, rhs: 
overflowing_mul			    fn overflowing_mul(self, rhs: Self) -> (Self, bool);
overflowing_neg			        pub fn overflowing_neg(self) -> (Self, bool) 
overflowing_neg			            fn overflowing_neg(self) -> (
overflowing_neg			    fn overflowing_neg(self) -> (Self, bool);
overflowing_rem			        pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) 
overflowing_rem			            fn overflowing_rem(self, rhs: 
overflowing_rem			    fn overflowing_rem(self, rhs: Self) -> (Self, bool);
overflowing_shl			        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) 
overflowing_shl			            fn overflowing_shl(self, rhs: u32) -> (
overflowing_shl			    fn overflowing_shl(self, rhs: u32) -> (Self, bool);
overflowing_shr			        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) 
overflowing_shr			            fn overflowing_shr(self, rhs: u32) -> (
overflowing_shr			    fn overflowing_shr(self, rhs: u32) -> (Self, bool);
overflowing_sub			    pub fn overflowing_sub<T>(a: T, b: T) -> T;
overflowing_sub			        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) 
overflowing_sub			            fn overflowing_sub(self, rhs: 
overflowing_sub			    fn overflowing_sub(self, rhs: Self) -> (Self, bool);
pad			    pub fn pad(&mut self, s: &str) -> Result 
pad_formatted_parts			    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result 
pad_integral			    pub fn pad_integral(&mut self,
panic			pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! 
panic_bounds_check			fn panic_bounds_check(file_line: &(&'static str, u32),
panic_fmt			pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! 
panic_impl			        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32) -> !;
panicking			pub mod panicking;
parse			pub mod parse;
parse			    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }
parse			    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;
parse_decimal			pub fn parse_decimal(s: &str) -> ParseResult 
parse_exp			fn parse_exp<'a>(integral: &'a [u8], fractional: &'a [u8], rest: &'a [u8]) -> ParseResult<'a> 
partial_cmp			                fn partial_cmp(&self, other: &[T; 
partial_cmp			                fn partial_cmp(&self, other: &
partial_cmp			        fn partial_cmp(&self, _: &()) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &bool) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;
partial_cmp			    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where
partial_cmp			            fn partial_cmp(&self, _other: &
partial_cmp			            fn partial_cmp(&self, other: &
partial_cmp			            fn partial_cmp(&self, other: &Self) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &str) -> Option<Ordering> 
partial_cmp			                fn partial_cmp(&self, other: &(
partition			    fn partition<B, F>(self, mut f: F) -> (B, B) where
pattern			pub mod pattern;
peek			    pub fn peek(&mut self) -> Option<&I::Item> 
peekable			    fn peekable(self) -> Peekable<Self> where Self: Sized 
pfe_empty			fn pfe_empty() -> ParseFloatError 
pfe_invalid			fn pfe_invalid() -> ParseFloatError 
platform			    mod platform 
pointer			    fn pointer(&mut self) -> *mut Data;
position			    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where
possibly_round			    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,
pow			        pub fn pow(self, mut exp: u32) -> Self 
power_of_ten			fn power_of_ten(e: i16) -> Fp 
powf32			    pub fn powf32(a: f32, x: f32) -> f32;
powf64			    pub fn powf64(a: f64, x: f64) -> f64;
powi			    fn powi(self, n: i32) -> f32 
powi			    fn powi(self, n: i32) -> f64 
powi			    fn powi(self, n: i32) -> Self;
powif32			    pub fn powif32(a: f32, x: i32) -> f32;
powif64			    pub fn powif64(a: f64, x: i32) -> f64;
precision			    pub fn precision(&self) -> Option<usize> { self.precision }
pref_align_of			    pub fn pref_align_of<T>() -> usize;
prefix			            fn prefix(&self) -> &'static str { 
prefix			    fn prefix(&self) -> &'static str 
prelude			pub mod prelude;
prev_float			pub fn prev_float<T: RawFloat>(x: T) -> T 
product			    fn product<P>(self) -> P where
ptr			pub mod ptr;
quick_start			fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) 
radix			pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> 
range_inclusive			pub fn range_inclusive<A>(start: A, stop: A) -> RangeInclusive<A>
raw			pub mod raw;
rawfp			pub mod rawfp;
read			pub unsafe fn read<T>(src: *const T) -> T 
read_and_drop			pub unsafe fn read_and_drop<T>(dest: *mut T) -> T 
read_volatile			pub unsafe fn read_volatile<T>(src: *const T) -> T 
recip			    fn recip(self) -> f32 { 1.0 \/ self }
recip			    fn recip(self) -> f64 { 1.0 \/ self }
recip			    fn recip(self) -> Self;
rejecting			    fn rejecting(_a: usize, _b: usize) -> Self::Output { None }
rejecting			    fn rejecting(a: usize, b: usize) -> Self::Output { SearchStep::Reject(a, b) }
rejecting			    fn rejecting(usize, usize) -> Self::Output;
rem			            fn rem(self, other: Wrapping<
rem			            fn rem(self, other: 
rem			    fn rem(self, rhs: RHS) -> Self::Output;
rem_assign			            fn rem_assign(&mut self, other: Wrapping<
rem_assign			            fn rem_assign(&mut self, other: 
rem_assign			    fn rem_assign(&mut self, Rhs);
repeat			pub fn repeat<T: Clone>(elt: T) -> Repeat<T> 
replace			pub fn replace<T>(dest: &mut T, mut src: T) -> T 
replace			pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T 
repr			    fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }
reset			    fn reset(&mut self) 
result			pub mod result;
return_address			    pub fn return_address() -> *const u8;
rev			    fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator 
reverse			    pub fn reverse(self) -> Ordering 
reverse			    fn reverse(&mut self) 
reverse			    fn reverse(&mut self);
reverse_maximal_suffix			    fn reverse_maximal_suffix(arr: &[u8], known_period: usize,
rfind			    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>
rintf32			    pub fn rintf32(x: f32) -> f32;
rintf64			    pub fn rintf64(x: f64) -> f64;
rmatch_indices			    fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>
rmatches			    fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>
rotate_left			        pub fn rotate_left(self, n: u32) -> Self 
rotate_right			        pub fn rotate_right(self, n: u32) -> Self 
round_and_weed			    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,
round_by_remainder			fn round_by_remainder<T: RawFloat>(v: Big, r: Big, q: u64, z: T) -> T 
round_normal			pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked 
round_up			pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> 
roundf32			    pub fn roundf32(x: f32) -> f32;
roundf64			    pub fn roundf64(x: f64) -> f64;
rposition			    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where
rsplit			    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>
rsplit_terminator			    fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>
rsplitn			    fn rsplitn<P>(&self,  n: usize, pred: P) -> RSplitN<Self::Item, P>
rsplitn			    fn rsplitn<P>(&self, n: usize, pred: P) -> RSplitN<T, P> where
rsplitn			    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>
rsplitn_mut			    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>
rsplitn_mut			    fn rsplitn_mut<P>(&mut self, n: usize, pred: P) -> RSplitNMut<T, P> where
rt			pub mod rt 
run			    fn run(&mut self, arg: &rt::v1::Argument) -> Result 
run_utf8_validation			fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> 
saturating_add			        pub fn saturating_add(self, other: Self) -> Self 
saturating_mul			        pub fn saturating_mul(self, other: Self) -> Self 
saturating_sub			        pub fn saturating_sub(self, other: Self) -> Self 
scan			    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>
select_fold1			fn select_fold1<I,B, FProj, FCmp>(mut it: I,
set			    pub fn set(&self, value: T) 
set_memory			        fn set_memory(&mut self, value: u8) 
set_memory			        fn set_memory(&mut self, value: u8);
shift_max			mod shift_max 
shl			            fn shl(self, other: 
shl			            fn shl(self, other: 
shl			    fn shl(self, rhs: RHS) -> Self::Output;
shl_assign			            fn shl_assign(&mut self, other: 
shl_assign			            fn shl_assign(&mut self, other: 
shl_assign			    fn shl_assign(&mut self, Rhs);
short_fast_pow10			    fn short_fast_pow10(e: usize) -> Self 
short_fast_pow10			    fn short_fast_pow10(e: usize) -> Self;
show_usize			    fn show_usize(x: &usize, f: &mut Formatter) -> Result 
shr			            fn shr(self, other: 
shr			            fn shr(self, other: 
shr			    fn shr(self, rhs: RHS) -> Self::Output;
shr_assign			            fn shr_assign(&mut self, other: 
shr_assign			            fn shr_assign(&mut self, other: 
shr_assign			    fn shr_assign(&mut self, Rhs);
sig_bits			    fn sig_bits() -> u8 
sig_bits			    fn sig_bits() -> u8;
sign_aware_zero_pad			    pub fn sign_aware_zero_pad(&self) -> bool 
sign_minus			    pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }
sign_plus			    pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }
signum			    fn signum(self) -> f32 
signum			    fn signum(self) -> f64 
signum			        pub fn signum(self) -> Self 
signum			    fn signum(self) -> Self;
simplify			fn simplify(decimal: &mut Decimal) 
sinf32			    pub fn sinf32(x: f32) -> f32;
sinf64			    pub fn sinf64(x: f64) -> f64;
sip			mod sip;
size_from_ptr			fn size_from_ptr<T>(_: *const T) -> usize 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			            fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>)
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			            fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_of			    pub fn size_of<T>() -> usize;
size_of			pub fn size_of<T>() -> usize 
size_of_val			    pub fn size_of_val<T: ?Sized>(_: &T) -> usize;
size_of_val			pub fn size_of_val<T: ?Sized>(val: &T) -> usize 
skip			    fn skip(self, n: usize) -> Skip<Self> where Self: Sized 
skip_while			    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where
slice			pub mod slice;
slice_error_fail			fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! 
slice_index_len_fail			fn slice_index_len_fail(index: usize, len: usize) -> ! 
slice_index_order_fail			fn slice_index_order_fail(index: usize, end: usize) -> ! 
slice_mut_unchecked			    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str 
slice_mut_unchecked			    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str;
slice_shift_char			    fn slice_shift_char(&self) -> Option<(char, &str)> 
slice_shift_char			    fn slice_shift_char(&self) -> Option<(char, &str)>;
slice_unchecked			    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str 
slice_unchecked			    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str;
split			    fn split<P>(&self, pred: P) -> Split<Self::Item, P>
split			    fn split<P>(&self, pred: P) -> Split<T, P> where P: FnMut(&T) -> bool 
split			    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> 
split			    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;
split_at			    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);
split_at			    fn split_at(&self, mid: usize) -> (&[T], &[T]) 
split_at			    fn split_at(&self, mid: usize) -> (&str, &str) 
split_at			    fn split_at(&self, mid: usize) -> (&str, &str);
split_at_mut			    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);
split_at_mut			    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) 
split_at_mut			    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) 
split_at_mut			    fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);
split_first			    fn split_first(&self) -> Option<(&Self::Item, &[Self::Item])>;
split_first			    fn split_first(&self) -> Option<(&T, &[T])> 
split_first_mut			    fn split_first_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;
split_first_mut			    fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> 
split_last			    fn split_last(&self) -> Option<(&Self::Item, &[Self::Item])>;
split_last			    fn split_last(&self) -> Option<(&T, &[T])> 
split_last_mut			    fn split_last_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;
split_last_mut			    fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> 
split_mut			    fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>
split_mut			    fn split_mut<P>(&mut self, pred: P) -> SplitMut<T, P> where P: FnMut(&T) -> bool 
split_terminator			    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> 
split_terminator			    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;
splitn			    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>
splitn			    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P> where
splitn			    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> 
splitn			    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;
splitn_mut			    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>
splitn_mut			    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P> where
sqrtf32			    pub fn sqrtf32(x: f32) -> f32;
sqrtf64			    pub fn sqrtf64(x: f64) -> f64;
starts_with			    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;
starts_with			    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq 
starts_with			    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool 
starts_with			    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;
step			            fn step(&self, by: &
step			    fn step(&self, by: &Self) -> Option<Self>;
step_by			    pub fn step_by(self, by: A) -> StepBy<A, Self> 
steps_between			            fn steps_between(_a: &
steps_between			            fn steps_between(start: &
steps_between			    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;
store			    pub fn store(&self, ptr: *mut T, order: Ordering) 
store			    pub fn store(&self, val: bool, order: Ordering) 
store			    pub fn store(&self, val: isize, order: Ordering) 
store			    pub fn store(&self, val: usize, order: Ordering) 
str			pub mod str;
strategy			pub mod strategy 
strongest_failure_ordering			fn strongest_failure_ordering(order: Ordering) -> Ordering 
sub			            pub fn sub<'a>(&'a mut self, other: &
sub			            fn sub(self, other: Wrapping<
sub			            fn sub(self, other: 
sub			    fn sub(self, rhs: RHS) -> Self::Output;
sub_assign			            fn sub_assign(&mut self, other: Wrapping<
sub_assign			            fn sub_assign(&mut self, other: 
sub_assign			    fn sub_assign(&mut self, Rhs);
sub_with_overflow			    pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);
sum			    fn sum<S>(self) -> S where
swap			pub fn swap<T>(x: &mut T, y: &mut T) 
swap			pub unsafe fn swap<T>(x: *mut T, y: *mut T) 
swap			    fn swap(&mut self, a: usize, b: usize) 
swap			    fn swap(&mut self, a: usize, b: usize);
swap			    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T 
swap			    pub fn swap(&self, val: bool, order: Ordering) -> bool 
swap			    pub fn swap(&self, val: isize, order: Ordering) -> isize 
swap			    pub fn swap(&self, val: usize, order: Ordering) -> usize 
swap_bytes			        pub fn swap_bytes(self) -> Self 
sync			pub mod sync;
table			mod table;
take			    fn take(self, n: usize) -> Take<Self> where Self: Sized, 
take			    pub fn take(&mut self) -> Option<T> 
take_while			    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where
tests			pub mod tests 
to_be			        pub fn to_be(self) -> Self { \/\/ or not to be?
to_degrees			    fn to_degrees(self) -> f32 { self * (180.0f32 \/ consts::PI) }
to_degrees			    fn to_degrees(self) -> f64 { self * (180.0f64 \/ consts::PI) }
to_degrees			    fn to_degrees(self) -> Self;
to_digit			    fn to_digit(self, radix: u32) -> Option<u32> 
to_digit			    fn to_digit(self, radix: u32) -> Option<u32>;
to_exact_exp_str			pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,
to_exact_fixed_str			pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,
to_le			        pub fn to_le(self) -> Self 
to_radians			    fn to_radians(self) -> f32 
to_radians			    fn to_radians(self) -> f64 
to_radians			    fn to_radians(self) -> Self;
to_shortest_exp_str			pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,
to_shortest_str			pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,
to_u32			        fn to_u32(&self) -> u32 { *self as u32 }
to_u32			    fn to_u32(&self) -> u32;
to_u64			        fn to_u64(&self) -> u64 { *self as u64 }
to_u64			    fn to_u64(&self) -> u64;
to_u64			pub fn to_u64(x: &Big) -> u64 
to_u8			        fn to_u8(&self) -> u8 { *self as u8 }
to_u8			    fn to_u8(&self) -> u8;
trailing_zeros			        pub fn trailing_zeros(self) -> u32 
traits			mod traits 
transmute			    pub fn transmute<T, U>(e: T) -> U;
transmute			    fn transmute(self) -> u64 
transmute			    fn transmute(self) -> u64;
transmute_copy			pub unsafe fn transmute_copy<T, U>(src: &T) -> U 
trim_left_matches			    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str 
trim_left_matches			    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;
trim_matches			    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str
trim_right_matches			    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str
trivial_cases			fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> 
truncf32			    pub fn truncf32(x: f32) -> f32;
truncf64			    pub fn truncf64(x: f64) -> f64;
try			    pub fn try(f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32;
tuple			mod tuple;
type_id			    pub fn type_id<T: ?Sized + 'static>() -> u64;
type_name			    pub fn type_name<T: ?Sized>() -> &'static str;
u16			impl u16 
u32			impl u32 
u64			impl u64 
u8			impl u8 
uint_macros			mod uint_macros;
unchecked_div			    pub fn unchecked_div<T>(x: T, y: T) -> T;
unchecked_rem			    pub fn unchecked_rem<T>(x: T, y: T) -> T;
underflow			fn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T 
uninit			    pub fn uninit<T>() -> T;
uninitialized			pub unsafe fn uninitialized<T>() -> T 
unpack			    fn unpack(self) -> Unpacked 
unpack			    fn unpack(self) -> Unpacked;
unreachable			    pub fn unreachable() -> !;
unwrap			    pub fn unwrap(self) -> T 
unwrap			    pub fn unwrap(self) -> T 
unwrap_err			    pub fn unwrap_err(self) -> E 
unwrap_failed			fn unwrap_failed<E: fmt::Debug>(msg: &str, error: E) -> ! 
unwrap_or			    pub fn unwrap_or(self, def: T) -> T 
unwrap_or			    pub fn unwrap_or(self, optb: T) -> T 
unwrap_or_0			fn unwrap_or_0(opt: Option<&u8>) -> u8 
unwrap_or_default			    pub fn unwrap_or_default(self) -> T 
unwrap_or_else			    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T 
unwrap_or_else			    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T 
unzip			    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where
use_early_reject			    fn use_early_reject() -> bool { false }
use_early_reject			    fn use_early_reject() -> bool { true }
use_early_reject			    fn use_early_reject() -> bool;
usize			impl usize 
utf8_acc_cont_byte			fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }
utf8_first_byte			fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }
utf8_is_cont_byte			fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }
v1			    pub mod v1;
v1			pub mod v1;
valid_up_to			    pub fn valid_up_to(&self) -> usize { self.valid_up_to }
volatile_copy_memory			    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);
volatile_copy_nonoverlapping_memory			    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,
volatile_load			    pub fn volatile_load<T>(src: *const T) -> T;
volatile_set_memory			    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);
volatile_store			    pub fn volatile_store<T>(dst: *mut T, val: T);
width			    pub fn width(&self) -> Option<usize> { self.width }
windows			    fn windows(&self, size: usize) -> Windows<Self::Item>;
windows			    fn windows(&self, size: usize) -> Windows<T> 
with_padding			    fn with_padding<F>(&mut self, padding: usize, default: Alignment,
wrapping			pub mod wrapping;
wrapping_add			        pub fn wrapping_add(self, rhs: Self) -> Self 
wrapping_div			        pub fn wrapping_div(self, rhs: Self) -> Self 
wrapping_mul			        pub fn wrapping_mul(self, rhs: Self) -> Self 
wrapping_neg			        pub fn wrapping_neg(self) -> Self 
wrapping_rem			        pub fn wrapping_rem(self, rhs: Self) -> Self 
wrapping_shl			        pub fn wrapping_shl(self, rhs: u32) -> Self 
wrapping_shr			        pub fn wrapping_shr(self, rhs: u32) -> Self 
wrapping_sub			        pub fn wrapping_sub(self, rhs: Self) -> Self 
write			pub fn write(output: &mut Write, args: Arguments) -> Result 
write			    fn write(&mut self, bytes: &[u8]);
write			    fn write(&mut self, msg: &[u8]) 
write			    pub fn write(&self, out: &mut [u8]) -> Option<usize> 
write			pub unsafe fn write<T>(dst: *mut T, src: T) 
write_bytes			        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result 
write_bytes			    pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);
write_char			            fn write_char(&mut self, c: char) -> Result 
write_char			    fn write_char(&mut self, c: char) -> Result 
write_fmt			            fn write_fmt(&mut self, args: Arguments) -> Result 
write_fmt			    fn write_fmt(&mut self, args: Arguments) -> Result 
write_fmt			    pub fn write_fmt(&mut self, fmt: Arguments) -> Result 
write_formatted_parts			    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result 
write_i16			    fn write_i16(&mut self, i: i16) 
write_i32			    fn write_i32(&mut self, i: i32) 
write_i64			    fn write_i64(&mut self, i: i64) 
write_i8			    fn write_i8(&mut self, i: i8) 
write_isize			    fn write_isize(&mut self, i: isize) 
write_str			    fn write_str(&mut self, mut s: &str) -> fmt::Result 
write_str			            fn write_str(&mut self, s: &str) -> Result 
write_str			    fn write_str(&mut self, s: &str) -> Result 
write_str			    fn write_str(&mut self, s: &str) -> Result;
write_str			    pub fn write_str(&mut self, data: &str) -> Result 
write_u16			    fn write_u16(&mut self, i: u16) 
write_u32			    fn write_u32(&mut self, i: u32) 
write_u64			    fn write_u64(&mut self, i: u64) 
write_u8			    fn write_u8(&mut self, i: u8) 
write_usize			    fn write_usize(&mut self, i: usize) 
write_volatile			pub unsafe fn write_volatile<T>(dst: *mut T, src: T) 
zero			    fn zero() -> f32 { 0.0 }
zero			    fn zero() -> f64 { 0.0 }
zero			            fn zero() -> Self { 0 }
zero			            fn zero() -> Self { 0.0 }
zero			    fn zero() -> Self;
zero_cutoff			    fn zero_cutoff() -> i64 
zero_cutoff			    fn zero_cutoff() -> i64;
zeroed			pub unsafe fn zeroed<T>() -> T 
zip			    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where
