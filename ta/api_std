::marker::Sync for Key			    unsafe impl<T> ::marker::Sync for Key<T> { }
::marker::Sync for KeyInner			    unsafe impl<T> ::marker::Sync for KeyInner<T> { }
A			    struct A;
ADDRESS64			pub struct ADDRESS64 
ADDRESS_MODE			pub enum ADDRESS_MODE 
ADDRINFOA			pub struct ADDRINFOA 
AcquireSRWLockExclusive			    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> () 
AcquireSRWLockShared			    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () 
Adaptor			        struct Adaptor<'a, T: ?Sized + 'a> 
Add for Duration			impl Add for Duration 
Add for Instant			impl Add<Duration> for Instant 
Add for SystemTime			impl Add<Duration> for SystemTime 
AddVectoredExceptionHandler			    pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,
AddrParseError			pub struct AddrParseError(());
AdjustTokenPrivileges			    pub fn AdjustTokenPrivileges(TokenHandle: HANDLE,
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe(FileDesc);
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe 
Answer			    pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);
Args			pub struct Args { inner: ArgsOs }
Args			pub struct Args 
Args			pub struct Args 
ArgsOs			pub struct ArgsOs { inner: os_imp::Args }
AsInner			pub trait AsInner<Inner: ?Sized> 
AsInner for Child			impl AsInner<imp::Process> for Child 
AsInner for ChildStderr			impl AsInner<AnonPipe> for ChildStderr 
AsInner for ChildStdin			impl AsInner<AnonPipe> for ChildStdin 
AsInner for ChildStdout			impl AsInner<AnonPipe> for ChildStdout 
AsInner for Command			impl AsInner<imp::Command> for Command 
AsInner for DirEntry			impl AsInner<fs_imp::DirEntry> for DirEntry 
AsInner for ExitStatus			impl AsInner<imp::ExitStatus> for ExitStatus 
AsInner for File			impl AsInner<fs_imp::File> for File 
AsInner for FileAttr			impl AsInner<raw::stat> for FileAttr 
AsInner for FileDesc			impl AsInner<c_int> for FileDesc 
AsInner for FileType			impl AsInner<fs_imp::FileType> for FileType 
AsInner for Ipv4Addr			impl AsInner<c::in_addr> for Ipv4Addr 
AsInner for Ipv6Addr			impl AsInner<c::in6_addr> for Ipv6Addr 
AsInner for JoinHandle			impl<T> AsInner<imp::Thread> for JoinHandle<T> 
AsInner for Metadata			impl AsInner<fs_imp::FileAttr> for Metadata 
AsInner for OsStr			impl AsInner<Slice> for OsStr 
AsInner for Permissions			impl AsInner<fs_imp::FilePermissions> for Permissions 
AsInner for Socket			impl AsInner<c_int> for Socket 
AsInner for Socket			impl AsInner<c::SOCKET> for Socket 
AsInner for TcpListener			impl AsInner<net_imp::TcpListener> for TcpListener 
AsInner for TcpStream			impl AsInner<net_imp::TcpStream> for TcpStream 
AsInner for UdpSocket			impl AsInner<net_imp::UdpSocket> for UdpSocket 
AsInner for Wtf8			impl AsInner<[u8]> for Wtf8 
AsInnerMut			pub trait AsInnerMut<Inner: ?Sized> 
AsInnerMut for Command			impl AsInnerMut<imp::Command> for Command 
AsInnerMut for DirBuilder			impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder 
AsInnerMut for OpenOptions			impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions 
AsRawFd			pub trait AsRawFd 
AsRawFd for fs			impl AsRawFd for fs::File 
AsRawFd for net			impl AsRawFd for net::TcpListener 
AsRawFd for net			impl AsRawFd for net::TcpStream 
AsRawFd for net			impl AsRawFd for net::UdpSocket 
AsRawFd for process			impl AsRawFd for process::ChildStderr 
AsRawFd for process			impl AsRawFd for process::ChildStdin 
AsRawFd for process			impl AsRawFd for process::ChildStdout 
AsRawHandle			pub trait AsRawHandle 
AsRawHandle for fs			impl AsRawHandle for fs::File 
AsRawHandle for process			impl AsRawHandle for process::Child 
AsRawHandle for process			impl AsRawHandle for process::ChildStderr 
AsRawHandle for process			impl AsRawHandle for process::ChildStdin 
AsRawHandle for process			impl AsRawHandle for process::ChildStdout 
AsRawHandle for thread			impl<T> AsRawHandle for thread::JoinHandle<T> 
AsRawSocket			pub trait AsRawSocket 
AsRawSocket for net			impl AsRawSocket for net::TcpListener 
AsRawSocket for net			impl AsRawSocket for net::TcpStream 
AsRawSocket for net			impl AsRawSocket for net::UdpSocket 
AsRef for CStr			impl AsRef<CStr> for CStr 
AsRef for CString			impl AsRef<CStr> for CString 
AsRef for Component			impl<'a> AsRef<OsStr> for Component<'a> 
AsRef for Components			impl<'a> AsRef<OsStr> for Components<'a> 
AsRef for Components			impl<'a> AsRef<Path> for Components<'a> 
AsRef for Iter			impl<'a> AsRef<OsStr> for Iter<'a> 
AsRef for Iter			impl<'a> AsRef<Path> for Iter<'a> 
AsRef for OsStr			impl AsRef<OsStr> for OsStr 
AsRef for OsStr			impl AsRef<Path> for OsStr 
AsRef for OsString			impl AsRef<OsStr> for OsString 
AsRef for OsString			impl AsRef<Path> for OsString 
AsRef for Path			impl AsRef<OsStr> for Path 
AsRef for Path			impl AsRef<Path> for Path 
AsRef for PathBuf			impl AsRef<OsStr> for PathBuf 
AsRef for PathBuf			impl AsRef<Path> for PathBuf 
AsRef for String			impl AsRef<OsStr> for String 
AsRef for String			impl AsRef<Path> for String 
AsRef for str			impl AsRef<OsStr> for str 
AsRef for str			impl AsRef<Path> for str 
AsciiExt			impl AsciiExt for [u8] 
AsciiExt			pub trait AsciiExt 
AsciiExt for Wtf8			impl AsciiExt for Wtf8 
AsciiExt for char			impl AsciiExt for char 
AsciiExt for str			impl AsciiExt for str 
AsciiExt for u8			impl AsciiExt for u8 
AssertRecoverSafe			impl<T> AssertRecoverSafe<T> 
AssertRecoverSafe			pub struct AssertRecoverSafe<T>(T);
B			    struct B;
BY_HANDLE_FILE_INFORMATION			pub struct BY_HANDLE_FILE_INFORMATION 
Barrier			impl Barrier 
Barrier			pub struct Barrier 
BarrierState			struct BarrierState 
BarrierWaitResult			impl BarrierWaitResult 
BarrierWaitResult			pub struct BarrierWaitResult(bool);
BitAnd			impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>
BitOr			impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>
BitXor			impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>
Blocker			enum Blocker 
Borrow for CString			impl Borrow<CStr> for CString 
Borrow for OsString			impl Borrow<OsStr> for OsString 
Borrow for PathBuf			impl Borrow<Path> for PathBuf 
Broadcast			pub struct Broadcast<T, U> 
Bucket			impl<K, V, M> Bucket<K, V, M> 
Bucket			pub struct Bucket<K, V, M> 
BucketState			impl<K, V, M> BucketState<K, V, M> 
BucketState			pub enum BucketState<K, V, M> 
Buf			impl Buf 
Buf			pub struct Buf 
Buf			impl Buf 
Buf			pub struct Buf 
BufRead			impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B 
BufRead			impl<'a> BufRead for &'a [u8] 
BufRead			pub trait BufRead: Read 
BufRead for Box			impl<B: BufRead + ?Sized> BufRead for Box<B> 
BufRead for BufReader			impl<R: Read> BufRead for BufReader<R> 
BufRead for Cursor			impl<T> BufRead for Cursor<T> where T: AsRef<[u8]> 
BufRead for Empty			impl BufRead for Empty 
BufRead for StdinLock			impl<'a> BufRead for StdinLock<'a> 
BufRead for Take			impl<T: BufRead> BufRead for Take<T> 
BufReader			impl<R: Read> BufReader<R> 
BufReader			pub struct BufReader<R> 
BufWriter			impl<W: Write> BufWriter<W> 
BufWriter			pub struct BufWriter<W: Write> 
Buffer			impl<T> Buffer<T> 
Buffer			struct Buffer<T> 
BuildHasher for RandomState			impl BuildHasher for RandomState 
Builder			impl Builder 
Builder			pub struct Builder 
Bytes			pub struct Bytes<R> 
CONDITION_VARIABLE			pub struct CONDITION_VARIABLE { pub ptr: LPVOID }
CONSOLE_SCREEN_BUFFER_INFO			pub struct CONSOLE_SCREEN_BUFFER_INFO 
CONTEXT			pub struct CONTEXT 
COORD			pub struct COORD 
CRITICAL_SECTION			pub struct CRITICAL_SECTION 
CStr			impl CStr 
CStr			pub struct CStr 
CString			impl CString 
CString			pub struct CString 
Chain			pub struct Chain<T, U> 
Chars			pub struct Chars<R> 
CharsError			pub enum CharsError 
Child			impl Child 
Child			pub struct Child 
ChildStderr			pub struct ChildStderr 
ChildStdin			pub struct ChildStdin 
ChildStdout			pub struct ChildStdout 
Cleanup			struct Cleanup 
Clone for Bucket			impl<K,V,M:Copy> Clone for Bucket<K,V,M> 
Clone for DefaultState			impl<H> Clone for DefaultState<H> 
Clone for Difference			impl<'a, T, S> Clone for Difference<'a, T, S> 
Clone for Dropable			    impl Clone for Dropable 
Clone for Intersection			impl<'a, T, S> Clone for Intersection<'a, T, S> 
Clone for Ipv4Addr			impl Clone for Ipv4Addr 
Clone for Ipv6Addr			impl Clone for Ipv6Addr 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Iter			impl<'a, K> Clone for Iter<'a, K> 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Keys			impl<'a, K, V> Clone for Keys<'a, K, V> 
Clone for RawBucket			impl<K,V> Clone for RawBucket<K,V> 
Clone for RawBuckets			impl<'a, K, V> Clone for RawBuckets<'a, K, V> 
Clone for RawTable			impl<K: Clone, V: Clone> Clone for RawTable<K, V> 
Clone for Sender			impl<T> Clone for Sender<T> 
Clone for SocketAddrV4			impl Clone for SocketAddrV4 
Clone for SocketAddrV6			impl Clone for SocketAddrV6 
Clone for SymmetricDifference			impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> 
Clone for SyncSender			impl<T> Clone for SyncSender<T> 
Clone for Union			impl<'a, T, S> Clone for Union<'a, T, S> 
Clone for Values			impl<'a, K, V> Clone for Values<'a, K, V> 
Clone for WIN32_FIND_DATAW			impl Clone for WIN32_FIND_DATAW 
CloseHandle			    pub fn CloseHandle(hObject: HANDLE) -> BOOL;
CodePoint			impl CodePoint 
CodePoint			pub struct CodePoint 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
CommandExt			pub trait CommandExt 
CommandExt for process			impl CommandExt for process::Command 
CommandLineToArgvW			    pub fn CommandLineToArgvW(lpCmdLine: *mut LPCWSTR,
Component			impl<'a> Component<'a> 
Component			pub enum Component<'a> 
Components			impl<'a> Components<'a> 
Components			pub struct Components<'a> 
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: Box<StaticCondvar> }
Condvar			impl Condvar 
Condvar			pub struct Condvar(imp::Condvar);
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<c::CONDITION_VARIABLE> }
Context			    struct Context<'a> 
Copy for Bucket			impl<K,V,M:Copy> Copy for Bucket<K,V,M> {}
Copy for RawBucket			impl<K,V> Copy for RawBucket<K,V> {}
CopyFileExW			    pub fn CopyFileExW(lpExistingFileName: LPCWSTR,
CreateDirectoryW			    pub fn CreateDirectoryW(lpPathName: LPCWSTR,
CreateFileW			    pub fn CreateFileW(lpFileName: LPCWSTR,
CreateHardLinkW			    pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,
CreatePipe			    pub fn CreatePipe(hReadPipe: LPHANDLE,
CreateProcessW			    pub fn CreateProcessW(lpApplicationName: LPCWSTR,
CreateSymbolicLinkW			    pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,
CreateThread			    pub fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,
CryptAcquireContextA			    pub fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,
CryptGenRandom			    pub fn CryptGenRandom(hProv: HCRYPTPROV,
CryptReleaseContext			    pub fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;
Cursor			impl<T> Cursor<T> 
Cursor			pub struct Cursor<T> 
Custom			struct Custom 
DISPATCHER_CONTEXT			pub struct DISPATCHER_CONTEXT 
Debug for Buf			impl Debug for Buf 
Debug for Buf			impl Debug for Buf 
Debug for HashMap			impl<K, V, S> Debug for HashMap<K, V, S>
Debug for OsStr			impl Debug for OsStr 
Debug for OsString			impl Debug for OsString 
Debug for Slice			impl Debug for Slice 
Debug for Slice			impl Debug for Slice 
Default for DefaultState			impl<H> Default for DefaultState<H> 
Default for HashMap			impl<K, V, S> Default for HashMap<K, V, S>
Default for HashSet			impl<T, S> Default for HashSet<T, S>
Default for RandomState			impl Default for RandomState 
DefaultResizePolicy			impl DefaultResizePolicy 
DefaultResizePolicy			struct DefaultResizePolicy;
DefaultState			pub struct DefaultState<H>(marker::PhantomData<H>);
DeleteCriticalSection			    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
DeleteFileW			    pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;
Deref for AssertRecoverSafe			impl<T> Deref for AssertRecoverSafe<T> 
Deref for Handle			impl Deref for Handle 
Deref for MutexGuard			impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> 
Deref for ReentrantMutexGuard			impl<'mutex, T> Deref for ReentrantMutexGuard<'mutex, T> 
Deref for RwLockReadGuard			impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> 
Deref for RwLockWriteGuard			impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> 
DerefMut for AssertRecoverSafe			impl<T> DerefMut for AssertRecoverSafe<T> 
DerefMut for MutexGuard			impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> 
DerefMut for RwLockWriteGuard			impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> 
DeviceIoControl			    pub fn DeviceIoControl(hDevice: HANDLE,
Difference			pub struct Difference<'a, T: 'a, S: 'a> 
Dir			struct Dir(*mut libc::DIR);
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder 
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder { mode: mode_t }
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder;
DirBuilderExt			pub trait DirBuilderExt 
DirBuilderExt for fs			impl DirBuilderExt for fs::DirBuilder 
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry(fs_imp::DirEntry);
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
DirEntryExt			pub trait DirEntryExt 
DirEntryExt for fs			impl DirEntryExt for fs::DirEntry 
Display			pub struct Display<'a> 
Display for StringError			        impl Display for StringError 
Div for Duration			impl Div<u32> for Duration 
Dl_info			    struct Dl_info 
DoubleEndedIterator for Components			impl<'a> DoubleEndedIterator for Components<'a> 
DoubleEndedIterator for EscapeDefault			impl DoubleEndedIterator for EscapeDefault 
DoubleEndedIterator for Iter			impl<'a> DoubleEndedIterator for Iter<'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drain			pub struct Drain<'a, K: 'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drop for Answer			    impl<'a> Drop for Answer<'a> 
Drop for Args			impl Drop for Args 
Drop for BufWriter			impl<W: Write> Drop for BufWriter<W> 
Drop for Cleanup			impl Drop for Cleanup 
Drop for Condvar			impl Drop for Condvar 
Drop for Dir			impl Drop for Dir 
Drop for Drain			impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> 
Drop for Dropable			    impl Drop for Dropable 
Drop for DynamicLibrary			impl Drop for DynamicLibrary 
Drop for Env			impl Drop for Env 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FindNextFileHandle			impl Drop for FindNextFileHandle 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			    impl Drop for Foo 
Drop for Guard			        impl<'a> Drop for Guard<'a> 
Drop for Handle			impl<'rx, T: Send> Drop for Handle<'rx, T> 
Drop for Handle			impl Drop for Handle 
Drop for Handler			impl Drop for Handler 
Drop for Key			impl Drop for Key 
Drop for LookupHost			impl Drop for LookupHost 
Drop for Mutex			impl<T: ?Sized> Drop for Mutex<T> 
Drop for MutexGuard			impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> 
Drop for NoClose			impl Drop for NoClose 
Drop for OsRng			    impl Drop for OsRng 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Queue			impl<T> Drop for Queue<T> 
Drop for Queue			impl<T> Drop for Queue<T> 
Drop for RawTable			impl<K, V> Drop for RawTable<K, V> 
Drop for Receiver			impl<T> Drop for Receiver<T> 
Drop for ReentrantMutex			impl<T> Drop for ReentrantMutex<T> 
Drop for ReentrantMutexGuard			impl<'a, T> Drop for ReentrantMutexGuard<'a, T> 
Drop for Reset			                impl<'a, T> Drop for Reset<'a, T> 
Drop for RwLock			impl<T: ?Sized> Drop for RwLock<T> 
Drop for RwLockReadGuard			impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> 
Drop for RwLockWriteGuard			impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> 
Drop for S1			        impl Drop for S1 
Drop for S2			        impl Drop for S2 
Drop for Select			impl Drop for Select 
Drop for SemaphoreGuard			impl<'a> Drop for SemaphoreGuard<'a> 
Drop for Sender			impl<T> Drop for Sender<T> 
Drop for Socket			impl Drop for Socket 
Drop for SyncSender			impl<T> Drop for SyncSender<T> 
Drop for TempDir			    impl Drop for TempDir 
Drop for Thread			impl Drop for Thread 
Drop for Unwinder			            impl Drop for Unwinder 
Drop for Unwinder			            impl Drop for Unwinder 
Dropable			    impl Dropable 
Dropable			    struct Dropable 
Dummy			struct Dummy(UnsafeCell<()>);
Dummy			struct Dummy(UnsafeCell<()>);
DuplicateHandle			    pub fn DuplicateHandle(hSourceProcessHandle: HANDLE,
Duration			impl Duration 
Duration			pub struct Duration 
DwarfReader			impl DwarfReader 
DwarfReader			pub struct DwarfReader 
DynamicLibrary			impl DynamicLibrary 
DynamicLibrary			pub struct DynamicLibrary 
EHContext			pub struct EHContext 
EXCEPTION_DISPOSITION			pub enum EXCEPTION_DISPOSITION 
EXCEPTION_POINTERS			pub struct EXCEPTION_POINTERS 
EXCEPTION_RECORD			pub struct EXCEPTION_RECORD 
Empty			pub struct Empty { _priv: () }
EmptyBucket			impl<K, V, M> EmptyBucket<K, V, M> 
EmptyBucket			pub struct EmptyBucket<K, V, M> 
EncodeWide			pub struct EncodeWide<'a> 
EnterCriticalSection			    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
Entry			impl<'a, K, V> Entry<'a, K, V> 
Entry			pub enum Entry<'a, K: 'a, V: 'a> 
Env			pub struct Env 
Env			pub struct Env 
Eq for CStr			impl Eq for CStr {}
Eq for Foo			        impl Eq for Foo {}
Eq for HashMap			impl<K, V, S> Eq for HashMap<K, V, S>
Eq for HashSet			impl<T, S> Eq for HashSet<T, S>
Eq for Ipv4Addr			impl Eq for Ipv4Addr {}
Eq for Ipv6Addr			impl Eq for Ipv6Addr {}
Eq for OsStr			impl Eq for OsStr {}
Eq for OsString			impl Eq for OsString {}
Eq for SocketAddrV4			impl Eq for SocketAddrV4 {}
Eq for SocketAddrV6			impl Eq for SocketAddrV6 {}
Eq for SystemTime			    impl Eq for SystemTime {}
Eq for SystemTime			impl Eq for SystemTime {}
Eq for Timespec			    impl Eq for Timespec {}
Error			impl Error + 'static + Send + Sync 
Error			impl Error + 'static + Send 
Error			impl Error + 'static 
Error			impl Error + Send + Sync 
Error			impl Error + Send 
Error			impl Error 
Error			pub trait Error: Debug + Display + Reflect 
Error			impl Error 
Error			pub struct Error 
Error for A			    impl Error for A 
Error for AddrParseError			impl Error for AddrParseError 
Error for B			    impl Error for B 
Error for IntoStringError			impl Error for IntoStringError 
Error for JoinPathsError			impl Error for JoinPathsError 
Error for NulError			impl Error for NulError 
Error for PoisonError			impl<T: Send + Reflect> Error for PoisonError<T> 
Error for StringError			        impl Error for StringError 
Error for StripPrefixError			impl Error for StripPrefixError 
Error for SystemTimeError			impl Error for SystemTimeError 
Error for TryLockError			impl<T: Send + Reflect> Error for TryLockError<T> 
Error for VarError			impl Error for VarError 
Error for num			impl Error for num::ParseFloatError 
Error for num			impl Error for num::ParseIntError 
Error for str			impl Error for str::ParseBoolError 
Error for str			impl Error for str::Utf8Error 
Error for string			impl Error for string::FromUtf16Error 
Error for string			impl Error for string::FromUtf8Error 
ErrorKind			pub enum ErrorKind 
ErrorRepeat			    struct ErrorRepeat 
EscapeDefault			pub struct EscapeDefault 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for ArgsOs			impl ExactSizeIterator for ArgsOs 
ExactSizeIterator for Drain			impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
ExactSizeIterator for Drain			impl<'a, K> ExactSizeIterator for Drain<'a, K> 
ExactSizeIterator for Drain			impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
ExactSizeIterator for EscapeDefault			impl ExactSizeIterator for EscapeDefault {}
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> 
ExactSizeIterator for IntoIter			impl<K> ExactSizeIterator for IntoIter<K> 
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> 
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
ExactSizeIterator for Iter			impl<'a, K> ExactSizeIterator for Iter<'a, K> 
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
ExactSizeIterator for Keys			impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> 
ExactSizeIterator for Values			impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> 
Exception			struct Exception 
ExitProcess			    pub fn ExitProcess(uExitCode: c_uint) -> !;
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(imp::ExitStatus);
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(c_int);
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(c::DWORD);
ExitStatusExt			pub trait ExitStatusExt 
ExitStatusExt for process			impl ExitStatusExt for process::ExitStatus 
Extend for HashMap			impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>
Extend for HashMap			impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>
Extend for HashSet			impl<'a, T, S> Extend<&'a T> for HashSet<T, S>
Extend for HashSet			impl<T, S> Extend<T> for HashSet<T, S>
Extend for Wtf8Buf			impl Extend<CodePoint> for Wtf8Buf 
FILETIME			pub struct FILETIME 
FILE_END_OF_FILE_INFO			pub struct FILE_END_OF_FILE_INFO 
FILE_INFO_BY_HANDLE_CLASS			pub enum FILE_INFO_BY_HANDLE_CLASS 
FLOATING_SAVE_AREA			pub struct FLOATING_SAVE_AREA 
FailFlushWriter			        struct FailFlushWriter;
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
File			impl File 
File			pub struct File 
File			impl File 
File			pub struct File(FileDesc);
File			impl File 
File			pub struct File { handle: Handle }
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr 
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { mode: mode_t }
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { attrs: c::DWORD }
FileType			impl FileType 
FileType			pub struct FileType(fs_imp::FileType);
FileType			impl FileType 
FileType			pub struct FileType { mode: mode_t }
FileType			impl FileType 
FileType			pub enum FileType 
FileTypeExt			pub trait FileTypeExt 
FileTypeExt for fs			impl FileTypeExt for fs::FileType 
FindClose			    pub fn FindClose(findFile: HANDLE) -> BOOL;
FindFirstFileW			    pub fn FindFirstFileW(fileName: LPCWSTR,
FindNextFileHandle			struct FindNextFileHandle(c::HANDLE);
FindNextFileW			    pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW)
Flag			impl Flag 
Flag			pub struct Flag { failed: Cell<bool> }
Flavor			enum Flavor<T> 
FlushFileBuffers			    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;
Foo			        struct Foo(&'static str, i32);
Foo			        struct Foo(Arc<AtomicUsize>);
Foo			        struct Foo(Arc<AtomicUsize>);
Foo			        struct Foo;
Foo			    struct Foo(Sender<()>);
FormatMessageW			    pub fn FormatMessageW(flags: DWORD,
FreeEnvironmentStringsW			    pub fn FreeEnvironmentStringsW(env_ptr: LPWCH) -> BOOL;
FreeLibrary			    pub fn FreeLibrary(handle: HMODULE) -> BOOL;
From			impl<W> From<IntoInnerError<W>> for Error 
From			impl<T> From<PoisonError<T>> for TryLockError<T> 
From for Box			impl From<String> for Box<Error + Send + Sync> 
From for Box			impl From<String> for Box<Error> 
From for Box			impl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a> 
From for Box			impl<'a, E: Error + 'a> From<E> for Box<Error + 'a> 
From for Box			impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<Error + Send + Sync + 'a> 
From for Box			impl<'a> From<&'a str> for Box<Error> 
From for CString			impl<'a> From<&'a CStr> for CString 
From for Cow			impl<'a> From<&'a Path> for Cow<'a, Path> 
From for Cow			impl<'a> From<PathBuf> for Cow<'a, Path> 
From for Ipv4Addr			impl From<u32> for Ipv4Addr 
From for OsString			impl From<String> for OsString 
From for PathBuf			impl From<OsString> for PathBuf 
From for PathBuf			impl From<String> for PathBuf 
From for Vec			impl From<CString> for Vec<u8> 
From for io			impl From<NulError> for io::Error 
From for u32			impl From<Ipv4Addr> for u32 
FromInner			pub trait FromInner<Inner> 
FromInner for File			impl FromInner<fs_imp::File> for File 
FromInner for File			impl FromInner<c_int> for File 
FromInner for File			impl FromInner<c::HANDLE> for File 
FromInner for FilePermissions			impl FromInner<raw::mode_t> for FilePermissions 
FromInner for Ipv4Addr			impl FromInner<c::in_addr> for Ipv4Addr 
FromInner for Ipv6Addr			impl FromInner<c::in6_addr> for Ipv6Addr 
FromInner for OsString			impl FromInner<Buf> for OsString 
FromInner for Permissions			impl FromInner<fs_imp::FilePermissions> for Permissions 
FromInner for Socket			impl FromInner<c_int> for Socket 
FromInner for Socket			impl FromInner<c::SOCKET> for Socket 
FromInner for SocketAddrV4			impl FromInner<c::sockaddr_in> for SocketAddrV4 
FromInner for SocketAddrV6			impl FromInner<c::sockaddr_in6> for SocketAddrV6 
FromInner for Stdio			impl FromInner<imp::RawStdio> for Stdio 
FromInner for TcpListener			impl FromInner<net_imp::TcpListener> for TcpListener 
FromInner for TcpListener			impl FromInner<Socket> for TcpListener 
FromInner for TcpStream			impl FromInner<net_imp::TcpStream> for TcpStream 
FromInner for TcpStream			impl FromInner<Socket> for TcpStream 
FromInner for UdpSocket			impl FromInner<net_imp::UdpSocket> for UdpSocket 
FromInner for UdpSocket			impl FromInner<Socket> for UdpSocket 
FromIterator for HashMap			impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>
FromIterator for HashSet			impl<T, S> FromIterator<T> for HashSet<T, S>
FromIterator for Wtf8Buf			impl FromIterator<CodePoint> for Wtf8Buf 
FromRawFd			pub trait FromRawFd 
FromRawFd for fs			impl FromRawFd for fs::File 
FromRawFd for net			impl FromRawFd for net::TcpListener 
FromRawFd for net			impl FromRawFd for net::TcpStream 
FromRawFd for net			impl FromRawFd for net::UdpSocket 
FromRawFd for process			impl FromRawFd for process::Stdio 
FromRawHandle			pub trait FromRawHandle 
FromRawHandle for fs			impl FromRawHandle for fs::File 
FromRawHandle for process			impl FromRawHandle for process::Stdio 
FromRawSocket			pub trait FromRawSocket 
FromRawSocket for net			impl FromRawSocket for net::TcpListener 
FromRawSocket for net			impl FromRawSocket for net::TcpStream 
FromRawSocket for net			impl FromRawSocket for net::UdpSocket 
FromStr for IpAddr			impl FromStr for IpAddr 
FromStr for Ipv4Addr			impl FromStr for Ipv4Addr 
FromStr for Ipv6Addr			impl FromStr for Ipv6Addr 
FromStr for SocketAddr			impl FromStr for SocketAddr 
FromStr for SocketAddrV4			impl FromStr for SocketAddrV4 
FromStr for SocketAddrV6			impl FromStr for SocketAddrV6 
FullBucket			impl<K, V, M> FullBucket<K, V, M> 
FullBucket			pub struct FullBucket<K, V, M> 
GET_FILEEX_INFO_LEVELS			pub enum GET_FILEEX_INFO_LEVELS 
GUID			pub struct GUID 
GapThenFull			pub struct GapThenFull<K, V, M> 
GetCommandLineW			    pub fn GetCommandLineW() -> *mut LPCWSTR;
GetConsoleMode			    pub fn GetConsoleMode(hConsoleHandle: HANDLE,
GetCurrentDirectoryW			    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
GetCurrentProcess			    pub fn GetCurrentProcess() -> HANDLE;
GetCurrentProcessId			    pub fn GetCurrentProcessId() -> DWORD;
GetCurrentThread			    pub fn GetCurrentThread() -> HANDLE;
GetEnvironmentStringsW			    pub fn GetEnvironmentStringsW() -> LPWCH;
GetEnvironmentVariableW			    pub fn GetEnvironmentVariableW(n: LPCWSTR, v: LPWSTR, nsize: DWORD) -> DWORD;
GetExitCodeProcess			    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;
GetFileAttributesExW			    pub fn GetFileAttributesExW(lpFileName: LPCWSTR,
GetFileInformationByHandle			    pub fn GetFileInformationByHandle(hFile: HANDLE,
GetFinalPathNameByHandleW			    pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,
GetLastError			    pub fn GetLastError() -> DWORD;
GetModuleFileNameW			    pub fn GetModuleFileNameW(hModule: HMODULE,
GetModuleHandleExW			    pub fn GetModuleHandleExW(dwFlags: DWORD, name: LPCWSTR,
GetModuleHandleW			    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
GetProcAddress			    pub fn GetProcAddress(handle: HMODULE,
GetProcessId			    pub fn GetProcessId(handle: HANDLE) -> DWORD;
GetStdHandle			    pub fn GetStdHandle(which: DWORD) -> HANDLE;
GetSystemTimeAsFileTime			    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
GetTempPathW			    pub fn GetTempPathW(nBufferLength: DWORD,
GetUserProfileDirectoryW			    pub fn GetUserProfileDirectoryW(hToken: HANDLE,
Guard			    struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }
Guard			pub struct Guard 
Handle			impl<'rx, T: Send> Handle<'rx, T> 
Handle			pub struct Handle<'rx, T:Send+'rx> 
Handle			impl Handle 
Handle			pub struct Handle(RawHandle);
Handler			enum Handler 
Handler			impl Handler 
Handler			pub struct Handler 
Handler			impl Handler 
Handler			pub struct Handler;
Hash for CodePoint			impl Hash for CodePoint 
Hash for OsStr			impl Hash for OsStr 
Hash for OsString			impl Hash for OsString 
Hash for Path			impl Hash for Path 
Hash for PathBuf			impl Hash for PathBuf 
Hash for PrefixComponent			impl<'a> Hash for PrefixComponent<'a> 
Hash for Wtf8			impl Hash for Wtf8 
Hash for Wtf8Buf			impl Hash for Wtf8Buf 
HashMap			impl<K, V, S> HashMap<K, V, S>
HashMap			impl<K: Hash + Eq, V> HashMap<K, V, RandomState> 
HashMap			pub struct HashMap<K, V, S = RandomState> 
HashSet			impl<T, S> HashSet<T, S>
HashSet			impl<T: Hash + Eq> HashSet<T, RandomState> 
HashSet			pub struct HashSet<T, S = RandomState> 
HashState for DefaultState			impl<H: Default + hash::Hasher> HashState for DefaultState<H> 
IMAGEHLP_LINE64			pub struct IMAGEHLP_LINE64 
Incoming			pub struct Incoming<'a> { listener: &'a TcpListener }
Index for HashMap			impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>
InitializeCriticalSection			    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
Inner			struct Inner 
Inner			struct Inner 
Instant			    impl Instant 
Instant			    pub struct Instant 
Instant			impl Instant 
Instant			pub struct Instant 
Instant			impl Instant 
Instant			pub struct Instant(time::Instant);
Intersection			pub struct Intersection<'a, T: 'a, S: 'a> 
Into for PathBuf			impl Into<OsString> for PathBuf 
IntoCow			impl<'a> IntoCow<'a, Path> for &'a Path 
IntoCow for PathBuf			impl IntoCow<'static, Path> for PathBuf 
IntoInner			impl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr 
IntoInner			pub trait IntoInner<Inner> 
IntoInner for Child			impl IntoInner<imp::Process> for Child 
IntoInner for ChildStderr			impl IntoInner<AnonPipe> for ChildStderr 
IntoInner for ChildStdin			impl IntoInner<AnonPipe> for ChildStdin 
IntoInner for ChildStdout			impl IntoInner<AnonPipe> for ChildStdout 
IntoInner for File			impl IntoInner<fs_imp::File> for File 
IntoInner for JoinHandle			impl<T> IntoInner<imp::Thread> for JoinHandle<T> 
IntoInner for OsString			impl IntoInner<Buf> for OsString 
IntoInner for Socket			impl IntoInner<c_int> for Socket 
IntoInner for Socket			impl IntoInner<c::SOCKET> for Socket 
IntoInner for TcpListener			impl IntoInner<net_imp::TcpListener> for TcpListener 
IntoInner for TcpStream			impl IntoInner<net_imp::TcpStream> for TcpStream 
IntoInner for UdpSocket			impl IntoInner<net_imp::UdpSocket> for UdpSocket 
IntoInnerError			impl<W> IntoInnerError<W> 
IntoInnerError			pub struct IntoInnerError<W>(W, Error);
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<K> 
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<T> 
IntoIterator			impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>
IntoIterator			impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>
IntoIterator			impl<'a, T, S> IntoIterator for &'a HashSet<T, S>
IntoIterator			impl<'a> IntoIterator for &'a Path 
IntoIterator			impl<'a> IntoIterator for &'a PathBuf 
IntoIterator			impl<'a, T> IntoIterator for &'a Receiver<T> 
IntoIterator for HashMap			impl<K, V, S> IntoIterator for HashMap<K, V, S>
IntoIterator for HashSet			impl<T, S> IntoIterator for HashSet<T, S>
IntoIterator for Receiver			impl <T> IntoIterator for Receiver<T> 
IntoRawFd			pub trait IntoRawFd 
IntoRawFd for fs			impl IntoRawFd for fs::File 
IntoRawFd for net			impl IntoRawFd for net::TcpListener 
IntoRawFd for net			impl IntoRawFd for net::TcpStream 
IntoRawFd for net			impl IntoRawFd for net::UdpSocket 
IntoRawFd for process			impl IntoRawFd for process::ChildStderr 
IntoRawFd for process			impl IntoRawFd for process::ChildStdin 
IntoRawFd for process			impl IntoRawFd for process::ChildStdout 
IntoRawHandle			pub trait IntoRawHandle 
IntoRawHandle for fs			impl IntoRawHandle for fs::File 
IntoRawHandle for process			impl IntoRawHandle for process::Child 
IntoRawHandle for process			impl IntoRawHandle for process::ChildStderr 
IntoRawHandle for process			impl IntoRawHandle for process::ChildStdin 
IntoRawHandle for process			impl IntoRawHandle for process::ChildStdout 
IntoRawHandle for thread			impl<T> IntoRawHandle for thread::JoinHandle<T>  
IntoRawSocket			pub trait IntoRawSocket 
IntoRawSocket for net			impl IntoRawSocket for net::TcpListener 
IntoRawSocket for net			impl IntoRawSocket for net::TcpStream 
IntoRawSocket for net			impl IntoRawSocket for net::UdpSocket 
IntoStringError			impl IntoStringError 
IntoStringError			pub struct IntoStringError 
IpAddr			pub enum IpAddr 
Ipv4Addr			impl Ipv4Addr 
Ipv4Addr			pub struct Ipv4Addr 
Ipv6Addr			impl Ipv6Addr 
Ipv6Addr			pub struct Ipv6Addr 
Ipv6MulticastScope			pub enum Ipv6MulticastScope 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			pub struct Iter<'a, K: 'a> 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			impl<'a> Iter<'a> 
Iter			pub struct Iter<'a> 
Iter			pub struct Iter<'a, T: 'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for ArgsOs			impl Iterator for ArgsOs 
Iterator for Bytes			impl<R: Read> Iterator for Bytes<R> 
Iterator for Chars			impl<R: Read> Iterator for Chars<R> 
Iterator for Components			impl<'a> Iterator for Components<'a> 
Iterator for Difference			impl<'a, T, S> Iterator for Difference<'a, T, S>
Iterator for Drain			impl<'a, K, V> Iterator for Drain<'a, K, V> 
Iterator for Drain			impl<'a, K> Iterator for Drain<'a, K> 
Iterator for Drain			impl<'a, K, V> Iterator for Drain<'a, K, V> 
Iterator for EncodeWide			impl<'a> Iterator for EncodeWide<'a> 
Iterator for Env			impl Iterator for Env 
Iterator for Env			impl Iterator for Env 
Iterator for EscapeDefault			impl Iterator for EscapeDefault 
Iterator for Incoming			impl<'a> Iterator for Incoming<'a> 
Iterator for Intersection			impl<'a, T, S> Iterator for Intersection<'a, T, S>
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<K> Iterator for IntoIter<K> 
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a, K> Iterator for Iter<'a, K> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a> Iterator for Iter<'a> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for Keys			impl<'a, K, V> Iterator for Keys<'a, K, V> 
Iterator for Lines			impl<B: BufRead> Iterator for Lines<B> 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for Packets			impl Iterator for Packets 
Iterator for RawBuckets			impl<'a, K, V> Iterator for RawBuckets<'a, K, V> 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for RevMoveBuckets			impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> 
Iterator for Split			impl<B: BufRead> Iterator for Split<B> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SymmetricDifference			impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>
Iterator for Union			impl<'a, T, S> Iterator for Union<'a, T, S>
Iterator for Values			impl<'a, K, V> Iterator for Values<'a, K, V> 
Iterator for Vars			impl Iterator for Vars 
Iterator for VarsOs			impl Iterator for VarsOs 
Iterator for WalkDir			impl Iterator for WalkDir 
Iterator for Wtf8CodePoints			impl<'a> Iterator for Wtf8CodePoints<'a> 
JoinHandle			impl<T> JoinHandle<T> 
JoinHandle			pub struct JoinHandle<T>(JoinInner<T>);
JoinHandleExt			pub trait JoinHandleExt 
JoinHandleExt for JoinHandle			impl<T> JoinHandleExt for JoinHandle<T> 
JoinInner			impl<T> JoinInner<T> 
JoinInner			struct JoinInner<T> 
JoinPathsError			pub struct JoinPathsError 
JoinPathsError			pub struct JoinPathsError;
JoinPathsError			pub struct JoinPathsError;
Juju			        struct Juju;
KDHELP64			pub struct KDHELP64 
Key			impl Key 
Key			pub struct Key 
Key			    impl<T: 'static> Key<T> 
Key			    impl<T> Key<T> 
Key			    pub struct Key<T> 
KeyInner			    impl<T> KeyInner<T> 
KeyInner			    pub struct KeyInner<T> { inner: Cell<*mut T> }
KeyInner			    pub struct KeyInner<T> 
Keys			pub struct Keys<'a, K: 'a, V: 'a> 
Kind			enum Kind 
LUID			pub struct LUID 
LUID_AND_ATTRIBUTES			pub struct LUID_AND_ATTRIBUTES 
Lazy			impl<T: Send + Sync + 'static> Lazy<T> 
Lazy			pub struct Lazy<T> 
LeaveCriticalSection			    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
LineWriter			impl<W: Write> LineWriter<W> 
LineWriter			pub struct LineWriter<W: Write> 
Lines			pub struct Lines<B> 
LoadLibraryW			    pub fn LoadLibraryW(name: LPCWSTR) -> HMODULE;
LocalFree			    pub fn LocalFree(ptr: *mut c_void);
LocalKey			impl<T: 'static> LocalKey<T> 
LocalKey			pub struct LocalKey<T: 'static> 
LocalKeyState			pub enum LocalKeyState 
Location			impl<'a> Location<'a> 
Location			pub struct Location<'a> 
LookupHost			pub struct LookupHost(net_imp::LookupHost);
LookupHost			pub struct LookupHost 
LookupPrivilegeValueW			    pub fn LookupPrivilegeValueW(lpSystemName: LPCWSTR,
M128A			pub struct M128A 
Maybe			enum Maybe<T> 
Message			enum Message<T> 
Metadata			impl Metadata 
Metadata			pub struct Metadata(fs_imp::FileAttr);
MetadataExt			pub trait MetadataExt 
MetadataExt			impl MetadataExt for ::fs::Metadata 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for fs			impl MetadataExt for fs::Metadata 
MoveFileExW			    pub fn MoveFileExW(lpExistingFileName: LPCWSTR,
Mul for Duration			impl Mul<u32> for Duration 
Mutex			impl<T: ?Sized> Mutex<T> 
Mutex			impl<T> Mutex<T> 
Mutex			pub struct Mutex<T: ?Sized> 
Mutex			impl Mutex 
Mutex			pub struct Mutex(imp::Mutex);
Mutex			impl Mutex 
Mutex			pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }
Mutex			impl Mutex 
Mutex			pub struct Mutex 
MutexGuard			impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> 
MutexGuard			pub struct MutexGuard<'a, T: ?Sized + 'a> 
MyUpgrade			enum MyUpgrade<T> 
NetInt			trait NetInt 
NewThread			pub trait NewThread 
NoClose			impl NoClose 
NoClose			pub struct NoClose(Option<Handle>);
Node			impl<T> Node<T> 
Node			struct Node<T> 
Node			impl<T> Node<T> 
Node			struct Node<T> 
Node			struct Node 
NonCopy			    struct NonCopy(i32);
NonCopy			    struct NonCopy(i32);
NulError			impl NulError 
NulError			pub struct NulError(usize, Vec<u8>);
OVERLAPPED			pub struct OVERLAPPED 
OccupiedEntry			impl<'a, K, V> OccupiedEntry<'a, K, V> 
OccupiedEntry			pub struct OccupiedEntry<'a, K: 'a, V: 'a> 
Once			impl Once 
Once			pub struct Once 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions(fs_imp::OpenOptions);
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenProcessToken			    pub fn OpenProcessToken(ProcessHandle: HANDLE,
Ord for CStr			impl Ord for CStr 
Ord for Ipv4Addr			impl Ord for Ipv4Addr 
Ord for Ipv6Addr			impl Ord for Ipv6Addr 
Ord for OsStr			impl Ord for OsStr 
Ord for OsString			impl Ord for OsString 
Ord for SystemTime			    impl Ord for SystemTime 
Ord for SystemTime			impl Ord for SystemTime 
Ord for Timespec			    impl Ord for Timespec 
OsRng			    impl OsRng 
OsRng			    pub struct OsRng 
OsRngInner			    enum OsRngInner 
OsStr			impl OsStr 
OsStr			pub struct OsStr 
OsStrExt			pub trait OsStrExt 
OsStrExt			pub trait OsStrExt 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsString			impl OsString 
OsString			pub struct OsString 
OsStringExt			pub trait OsStringExt 
OsStringExt			pub trait OsStringExt 
OsStringExt for OsString			impl OsStringExt for OsString 
OsStringExt for OsString			impl OsStringExt for OsString 
Output			pub struct Output 
Output			impl Output 
Output			pub enum Output 
PROCESS_INFORMATION			pub struct PROCESS_INFORMATION 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			pub trait Packet 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);
Packet			struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);
Packets			struct Packets { cur: *mut Handle<'static, ()> }
PanicData			struct PanicData 
PanicInfo			impl<'a> PanicInfo<'a> 
PanicInfo			pub struct PanicInfo<'a> 
Parser			impl<'a> Parser<'a> 
Parser			struct Parser<'a> 
PartialEq			        impl<'a, 'b> PartialEq<
PartialEq			        impl<'a, 'b> PartialEq<
PartialEq for CStr			impl PartialEq for CStr 
PartialEq for Foo			        impl PartialEq for Foo 
PartialEq for HashMap			impl<K, V, S> PartialEq for HashMap<K, V, S>
PartialEq for HashSet			impl<T, S> PartialEq for HashSet<T, S>
PartialEq for Ipv4Addr			impl PartialEq for Ipv4Addr 
PartialEq for Ipv6Addr			impl PartialEq for Ipv6Addr 
PartialEq for OsStr			impl PartialEq for OsStr 
PartialEq for OsStr			impl PartialEq<str> for OsStr 
PartialEq for OsString			impl PartialEq for OsString 
PartialEq for OsString			impl PartialEq<str> for OsString 
PartialEq for SocketAddrV4			impl PartialEq for SocketAddrV4 
PartialEq for SocketAddrV6			impl PartialEq for SocketAddrV6 
PartialEq for SystemTime			    impl PartialEq for SystemTime 
PartialEq for SystemTime			impl PartialEq for SystemTime 
PartialEq for Timespec			    impl PartialEq for Timespec 
PartialEq for str			impl PartialEq<OsStr> for str 
PartialEq for str			impl PartialEq<OsString> for str 
PartialOrd for CStr			impl PartialOrd for CStr 
PartialOrd for Ipv4Addr			impl PartialOrd for Ipv4Addr 
PartialOrd for Ipv6Addr			impl PartialOrd for Ipv6Addr 
PartialOrd for OsStr			impl PartialOrd for OsStr 
PartialOrd for OsStr			impl PartialOrd<str> for OsStr 
PartialOrd for OsString			impl PartialOrd for OsString 
PartialOrd for OsString			impl PartialOrd<str> for OsString 
PartialOrd for SystemTime			    impl PartialOrd for SystemTime 
PartialOrd for SystemTime			impl PartialOrd for SystemTime 
PartialOrd for Timespec			    impl PartialOrd for Timespec 
Path			impl Path 
Path			pub struct Path 
PathBuf			impl PathBuf 
PathBuf			pub struct PathBuf 
Permissions			impl Permissions 
Permissions			pub struct Permissions(fs_imp::FilePermissions);
PermissionsExt			pub trait PermissionsExt 
PermissionsExt for Permissions			impl PermissionsExt for Permissions 
PoisonError			impl<T> PoisonError<T> 
PoisonError			pub struct PoisonError<T> 
PopResult			pub enum PopResult<T> 
PositionReader			        struct PositionReader 
Prefix			impl<'a> Prefix<'a> 
Prefix			pub enum Prefix<'a> 
PrefixComponent			impl<'a> PrefixComponent<'a> 
PrefixComponent			pub struct PrefixComponent<'a> 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
QueryPerformanceCounter			    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER)
QueryPerformanceFrequency			    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;
Queue			impl<T> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl<T> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl Queue 
Queue			struct Queue 
R			        struct R;
REPARSE_DATA_BUFFER			pub struct REPARSE_DATA_BUFFER 
REPARSE_MOUNTPOINT_DATA_BUFFER			pub struct REPARSE_MOUNTPOINT_DATA_BUFFER 
RUNTIME_FUNCTION			pub struct RUNTIME_FUNCTION 
RWLock			impl RWLock 
RWLock			pub struct RWLock(imp::RWLock);
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<libc::pthread_rwlock_t> }
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<c::SRWLOCK> }
RaiseException			    pub fn RaiseException(dwExceptionCode: DWORD,
RandomState			impl RandomState 
RandomState			pub struct RandomState 
RawBucket			impl<K, V> RawBucket<K, V> 
RawBucket			struct RawBucket<K, V> 
RawBuckets			struct RawBuckets<'a, K, V> 
RawHandle			impl RawHandle 
RawHandle			pub struct RawHandle(c::HANDLE);
RawTable			impl<K, V> RawTable<K, V> 
RawTable			pub struct RawTable<K, V> 
Read			impl<'a> Read for &'a File 
Read			impl<'a, R: Read + ?Sized> Read for &'a mut R 
Read			impl<'a> Read for &'a [u8] 
Read			pub trait Read 
Read			impl<'a> Read for &'a TcpStream 
Read for Box			impl<R: Read + ?Sized> Read for Box<R> 
Read for BufReader			impl<R: Read> Read for BufReader<R> 
Read for Chain			impl<T: Read, U: Read> Read for Chain<T, U> 
Read for ChildStderr			impl Read for ChildStderr 
Read for ChildStdout			impl Read for ChildStdout 
Read for Cursor			impl<T> Read for Cursor<T> where T: AsRef<[u8]> 
Read for Empty			impl Read for Empty 
Read for ErrorRepeat			    impl Read for ErrorRepeat 
Read for File			impl Read for File 
Read for PositionReader			        impl Read for PositionReader 
Read for R			        impl Read for R 
Read for Repeat			impl Read for Repeat 
Read for ShortReader			    impl Read for ShortReader 
Read for Stdin			impl Read for Stdin 
Read for StdinLock			impl<'a> Read for StdinLock<'a> 
Read for StdinRaw			impl Read for StdinRaw 
Read for Take			impl<T: Read> Read for Take<T> 
Read for TcpStream			impl Read for TcpStream 
Read for Tee			impl<R: Read, W: Write> Read for Tee<R, W> 
ReadConsoleW			    pub fn ReadConsoleW(hConsoleInput: HANDLE,
ReadDir			pub struct ReadDir(fs_imp::ReadDir);
ReadDir			pub struct ReadDir 
ReadDir			pub struct ReadDir 
ReadFile			    pub fn ReadFile(hFile: HANDLE,
ReaderRng			impl<R: Read> ReaderRng<R> 
ReaderRng			pub struct ReaderRng<R> 
Receiver			impl<T> Receiver<T> 
Receiver			pub struct Receiver<T> 
Recover			trait Recover<Q: ?Sized> 
RecoverSafe			impl RecoverSafe for .. {}
RecoverSafe			impl<'a, T: RefRecoverSafe + ?Sized> RecoverSafe for &'a T {}
RecoverSafe			impl<T: RefRecoverSafe + ?Sized> RecoverSafe for *const T {}
RecoverSafe			impl<T: RefRecoverSafe + ?Sized> RecoverSafe for *mut T {}
RecoverSafe			pub trait RecoverSafe {}
RecoverSafe for Arc			impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Arc<T> {}
RecoverSafe for AssertRecoverSafe			impl<T> RecoverSafe for AssertRecoverSafe<T> {}
RecoverSafe for Mutex			impl<T: ?Sized> RecoverSafe for Mutex<T> {}
RecoverSafe for Rc			impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Rc<T> {}
RecoverSafe for RwLock			impl<T: ?Sized> RecoverSafe for RwLock<T> {}
RecoverSafe for Shared			impl<T: RefRecoverSafe + ?Sized> RecoverSafe for Shared<T> {}
RecoverSafe for Unique			impl<T: RecoverSafe> RecoverSafe for Unique<T> {}
RecvError			pub struct RecvError;
ReentrantMutex			impl<T> ReentrantMutex<T> 
ReentrantMutex			pub struct ReentrantMutex<T> 
ReentrantMutex			impl ReentrantMutex 
ReentrantMutex			pub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }
ReentrantMutex			impl ReentrantMutex 
ReentrantMutex			pub struct ReentrantMutex { inner: UnsafeCell<c::CRITICAL_SECTION> }
ReentrantMutexGuard			impl<'mutex, T> ReentrantMutexGuard<'mutex, T> 
ReentrantMutexGuard			pub struct ReentrantMutexGuard<'a, T: 'a> 
RefRecoverSafe			impl RefRecoverSafe for .. {}
RefRecoverSafe			pub trait RefRecoverSafe {}
RefRecoverSafe for AssertRecoverSafe			impl<T> RefRecoverSafe for AssertRecoverSafe<T> {}
ReleaseSRWLockExclusive			    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) -> () 
ReleaseSRWLockShared			    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () 
RemoveDirectoryW			    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;
Repeat			pub struct Repeat { byte: u8 }
Repr			enum Repr 
Reset			        struct Reset<'a, T: 'a> 
RevMoveBuckets			struct RevMoveBuckets<'a, K, V> 
Rng for OsRng			    impl Rng for OsRng 
Rng for ReaderRng			impl<R: Read> Rng for ReaderRng<R> 
Rng for StdRng			impl Rng for StdRng 
Rng for ThreadRng			impl Rng for ThreadRng 
RtlCaptureContext			    pub fn RtlCaptureContext(ctx: *mut CONTEXT);
RtlUnwindEx			    pub fn RtlUnwindEx(TargetFrame: LPVOID,
RwLock			impl<T: ?Sized> RwLock<T> 
RwLock			impl<T> RwLock<T> 
RwLock			pub struct RwLock<T: ?Sized> 
RwLockReadGuard			impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> 
RwLockReadGuard			pub struct RwLockReadGuard<'a, T: ?Sized + 'a> 
RwLockWriteGuard			impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> 
RwLockWriteGuard			pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> 
S1			        struct S1(Sender<()>);
S1			        struct S1;
S2			        struct S2;
SECURITY_ATTRIBUTES			pub struct SECURITY_ATTRIBUTES 
SMALL_RECT			pub struct SMALL_RECT 
SOCKADDR			pub struct SOCKADDR 
SOCKADDR_STORAGE_LH			pub struct SOCKADDR_STORAGE_LH 
SRWLOCK			pub struct SRWLOCK { pub ptr: LPVOID }
STACKFRAME64			pub struct STACKFRAME64 
STARTUPINFO			pub struct STARTUPINFO 
SYMBOLIC_LINK_REPARSE_BUFFER			pub struct SYMBOLIC_LINK_REPARSE_BUFFER 
SYMBOL_INFO			pub struct SYMBOL_INFO 
SafeHash			impl SafeHash 
SafeHash			pub struct SafeHash 
ScopedKey			impl<T> ScopedKey<T> 
ScopedKey			pub struct ScopedKey<T:'static> { inner: fn() -> &'static imp::KeyInner<T> }
SearchResult			enum SearchResult<K, V, M> 
SearchResult			impl<K, V, M> SearchResult<K, V, M> 
SecRandom			    enum SecRandom {}
SecRandomCopyBytes			        fn SecRandomCopyBytes(rnd: *const SecRandom,
SeedableRng for StdRng			impl<'a> SeedableRng<&'a [usize]> for StdRng 
Seek			impl<'a> Seek for &'a File 
Seek			impl<'a, S: Seek + ?Sized> Seek for &'a mut S 
Seek			pub trait Seek 
Seek for Box			impl<S: Seek + ?Sized> Seek for Box<S> 
Seek for BufReader			impl<R: Seek> Seek for BufReader<R> 
Seek for BufWriter			impl<W: Write + Seek> Seek for BufWriter<W> 
Seek for File			impl Seek for File 
Seek for PositionReader			        impl Seek for PositionReader 
SeekFrom			pub enum SeekFrom 
Select			impl Select 
Select			pub struct Select 
SelectInner			struct SelectInner 
SelectionResult			pub enum SelectionResult<T> 
SelectionResult			pub enum SelectionResult<T> 
Semaphore			impl Semaphore 
Semaphore			pub struct Semaphore 
SemaphoreGuard			pub struct SemaphoreGuard<'a> 
Send for Condvar			unsafe impl Send for Condvar {}
Send for Condvar			unsafe impl Send for Condvar {}
Send for Dir			unsafe impl Send for Dir {}
Send for Drain			unsafe impl<'a, K: Send, V: Send> Send for Drain<'a, K, V> {}
Send for FindNextFileHandle			unsafe impl Send for FindNextFileHandle {}
Send for Flag			unsafe impl Send for Flag {}
Send for Inner			unsafe impl Send for Inner {}
Send for IntoIter			unsafe impl<K: Send, V: Send> Send for IntoIter<K, V> {}
Send for Iter			unsafe impl<'a, K: Sync, V: Sync> Send for Iter<'a, K, V> {}
Send for IterMut			unsafe impl<'a, K: Send, V: Send> Send for IterMut<'a, K, V> {}
Send for LookupHost			unsafe impl Send for LookupHost {}
Send for Mutex			unsafe impl<T: ?Sized + Send> Send for Mutex<T> { }
Send for Mutex			unsafe impl Send for Mutex {}
Send for Mutex			unsafe impl Send for Mutex {}
Send for Node			unsafe impl Send for Node {}
Send for Packet			unsafe impl<T: Send> Send for Packet<T> { }
Send for Packet			    unsafe impl<T: Send> Send for Packet<T> {}
Send for Packet			unsafe impl<T: Send> Send for Packet<T> {}
Send for Queue			unsafe impl<T: Send> Send for Queue<T> { }
Send for Queue			unsafe impl<T: Send> Send for Queue<T> { }
Send for RWLock			unsafe impl Send for RWLock {}
Send for RWLock			unsafe impl Send for RWLock {}
Send for RawHandle			unsafe impl Send for RawHandle {}
Send for RawTable			unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}
Send for Receiver			unsafe impl<T: Send> Send for Receiver<T> { }
Send for ReentrantMutex			unsafe impl<T: Send> Send for ReentrantMutex<T> {}
Send for ReentrantMutex			unsafe impl Send for ReentrantMutex {}
Send for ReentrantMutex			unsafe impl Send for ReentrantMutex {}
Send for RwLock			unsafe impl<T: ?Sized + Send + Sync> Send for RwLock<T> {}
Send for Sender			unsafe impl<T: Send> Send for Sender<T> { }
Send for State			unsafe impl<T: Send> Send for State<T> {}
Send for SyncSender			unsafe impl<T: Send> Send for SyncSender<T> {}
Send for Thread			unsafe impl Send for Thread {}
SendError			pub struct SendError<T>(#[stable(feature = "rust1", since = "1.0.0")] pub T);
Sender			impl<T> Sender<T> 
Sender			pub struct Sender<T> 
SetCurrentDirectoryW			    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;
SetEnvironmentVariableW			    pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;
SetErrorMode			    pub fn SetErrorMode(uMode: c_uint) -> c_uint;
SetFileAttributesW			    pub fn SetFileAttributesW(lpFileName: LPCWSTR,
SetFileInformationByHandle			    pub fn SetFileInformationByHandle(_hFile: HANDLE,
SetFilePointerEx			    pub fn SetFilePointerEx(hFile: HANDLE,
SetHandleInformation			    pub fn SetHandleInformation(hObject: HANDLE,
SetLastError			    pub fn SetLastError(dwErrCode: DWORD);
SetThreadErrorMode			    pub fn SetThreadErrorMode(_dwNewMode: DWORD,
SetThreadStackGuarantee			    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL 
ShortReader			    pub struct ShortReader 
Shutdown			pub enum Shutdown 
SignalToken			impl SignalToken 
SignalToken			pub struct SignalToken 
Sink			pub struct Sink { _priv: () }
Sleep			    pub fn Sleep(dwMilliseconds: DWORD);
SleepConditionVariableSRW			    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,
Slice			impl Slice 
Slice			pub struct Slice 
Slice			impl Slice 
Slice			pub struct Slice 
Socket			impl Socket 
Socket			pub struct Socket(FileDesc);
Socket			impl Socket 
Socket			pub struct Socket(c::SOCKET);
SocketAddr			impl SocketAddr 
SocketAddr			pub enum SocketAddr 
SocketAddrV4			impl SocketAddrV4 
SocketAddrV4			pub struct SocketAddrV4 { inner: c::sockaddr_in }
SocketAddrV6			impl SocketAddrV6 
SocketAddrV6			pub struct SocketAddrV6 { inner: c::sockaddr_in6 }
Split			pub struct Split<B> 
SplitPaths			pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }
SplitPaths			pub struct SplitPaths<'a> 
SplitPaths			pub struct SplitPaths<'a> 
StartResult			pub enum StartResult 
State			enum State 
State			struct State<T> 
StaticCondvar			impl StaticCondvar 
StaticCondvar			pub struct StaticCondvar 
StaticKey			impl StaticKey 
StaticKey			pub struct StaticKey 
StaticMutex			impl StaticMutex 
StaticMutex			pub struct StaticMutex 
StaticRwLock			impl StaticRwLock 
StaticRwLock			pub struct StaticRwLock 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdRng			impl StdRng 
StdRng			pub struct StdRng 
Stderr			impl Stderr 
Stderr			pub struct Stderr 
Stderr			impl Stderr 
Stderr			pub struct Stderr(());
Stderr			impl Stderr 
Stderr			pub struct Stderr(Output);
StderrLock			pub struct StderrLock<'a> 
StderrRaw			struct StderrRaw(stdio::Stderr);
Stdin			impl Stdin 
Stdin			pub struct Stdin 
Stdin			impl Stdin 
Stdin			pub struct Stdin(());
Stdin			impl Stdin 
Stdin			pub struct Stdin 
StdinLock			pub struct StdinLock<'a> 
StdinRaw			struct StdinRaw(stdio::Stdin);
Stdio			impl Stdio 
Stdio			pub struct Stdio(StdioImp);
Stdio			pub enum Stdio 
Stdio			impl Stdio 
Stdio			pub enum Stdio 
StdioImp			enum StdioImp 
Stdout			impl Stdout 
Stdout			pub struct Stdout 
Stdout			impl Stdout 
Stdout			pub struct Stdout(());
Stdout			impl Stdout 
Stdout			pub struct Stdout(Output);
StdoutLock			pub struct StdoutLock<'a> 
StdoutRaw			struct StdoutRaw(stdio::Stdout);
StringError			        struct StringError(String);
StripPrefixError			pub struct StripPrefixError(());
Sub			impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>
Sub for Duration			impl Sub for Duration 
Sub for Instant			impl Sub<Duration> for Instant 
Sub for SystemTime			impl Sub<Duration> for SystemTime 
SwitchToThread			    pub fn SwitchToThread() -> BOOL;
SymmetricDifference			pub struct SymmetricDifference<'a, T: 'a, S: 'a> 
Sync for Condvar			unsafe impl Sync for Condvar {}
Sync for Condvar			unsafe impl Sync for Condvar {}
Sync for Dir			unsafe impl Sync for Dir {}
Sync for Drain			unsafe impl<'a, K: Sync, V: Sync> Sync for Drain<'a, K, V> {}
Sync for Dummy			unsafe impl Sync for Dummy {}
Sync for Dummy			unsafe impl Sync for Dummy {}
Sync for FindNextFileHandle			unsafe impl Sync for FindNextFileHandle {}
Sync for Flag			unsafe impl Sync for Flag {}
Sync for Inner			unsafe impl Sync for Inner {}
Sync for IntoIter			unsafe impl<K: Sync, V: Sync> Sync for IntoIter<K, V> {}
Sync for Iter			unsafe impl<'a, K: Sync, V: Sync> Sync for Iter<'a, K, V> {}
Sync for IterMut			unsafe impl<'a, K: Sync, V: Sync> Sync for IterMut<'a, K, V> {}
Sync for Lazy			unsafe impl<T> Sync for Lazy<T> {}
Sync for LookupHost			unsafe impl Sync for LookupHost {}
Sync for Mutex			unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Packet			unsafe impl<T: Send> Sync for Packet<T> { }
Sync for Packet			    unsafe impl<T> Sync for Packet<T> {}
Sync for Packet			unsafe impl<T: Sync> Sync for Packet<T> {}
Sync for Queue			unsafe impl<T: Send> Sync for Queue<T> { }
Sync for Queue			unsafe impl<T: Send> Sync for Queue<T> { }
Sync for RWLock			unsafe impl Sync for RWLock {}
Sync for RWLock			unsafe impl Sync for RWLock {}
Sync for RawHandle			unsafe impl Sync for RawHandle {}
Sync for RawTable			unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}
Sync for ReentrantMutex			unsafe impl<T: Send> Sync for ReentrantMutex<T> {}
Sync for ReentrantMutex			unsafe impl Sync for ReentrantMutex {}
Sync for ReentrantMutex			unsafe impl Sync for ReentrantMutex {}
Sync for RwLock			unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}
Sync for Thread			unsafe impl Sync for Thread {}
SyncSender			impl<T> SyncSender<T> 
SyncSender			pub struct SyncSender<T> 
SystemTime			    impl SystemTime 
SystemTime			    pub struct SystemTime 
SystemTime			impl SystemTime 
SystemTime			pub struct SystemTime 
SystemTime			impl SystemTime 
SystemTime			pub struct SystemTime(time::SystemTime);
SystemTimeError			impl SystemTimeError 
SystemTimeError			pub struct SystemTimeError(Duration);
TOKEN_PRIVILEGES			pub struct TOKEN_PRIVILEGES 
Take			impl<T> Take<T> 
Take			pub struct Take<T> 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener(net_imp::TcpListener);
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream(net_imp::TcpStream);
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
Tee			pub struct Tee<R, W> 
TempDir			    impl TempDir 
TempDir			    pub struct TempDir(PathBuf);
TerminateProcess			    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;
TestError			        struct TestError;
Thread			impl Thread 
Thread			pub struct Thread 
Thread			impl Thread 
Thread			pub struct Thread 
Thread			impl Thread 
Thread			pub struct Thread 
ThreadInfo			impl ThreadInfo 
ThreadInfo			struct ThreadInfo 
ThreadRng			pub struct ThreadRng 
ThreadRngReseeder			struct ThreadRngReseeder;
Timespec			    impl Timespec 
Timespec			    struct Timespec 
TlsAlloc			    pub fn TlsAlloc() -> DWORD;
TlsFree			    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
TlsGetValue			    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
TlsSetValue			    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
ToOwned for CStr			impl ToOwned for CStr 
ToOwned for OsStr			impl ToOwned for OsStr 
ToOwned for Path			impl ToOwned for Path 
ToSocketAddrs			impl ToSocketAddrs for (IpAddr, u16) 
ToSocketAddrs			impl ToSocketAddrs for (Ipv4Addr, u16) 
ToSocketAddrs			impl ToSocketAddrs for (Ipv6Addr, u16) 
ToSocketAddrs			impl<'a, T: ToSocketAddrs + ?Sized> ToSocketAddrs for &'a T 
ToSocketAddrs			impl<'a> ToSocketAddrs for (&'a str, u16) 
ToSocketAddrs			pub trait ToSocketAddrs 
ToSocketAddrs for SocketAddr			impl ToSocketAddrs for SocketAddr 
ToSocketAddrs for SocketAddrV4			impl ToSocketAddrs for SocketAddrV4 
ToSocketAddrs for SocketAddrV6			impl ToSocketAddrs for SocketAddrV6 
ToSocketAddrs for str			impl ToSocketAddrs for str 
TryAcquireSRWLockExclusive			    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN 
TryAcquireSRWLockShared			    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN 
TryEnterCriticalSection			    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;
TryLockError			pub enum TryLockError<T> 
TryRecvError			pub enum TryRecvError 
TrySendError			pub enum TrySendError<T> 
UNWIND_HISTORY_TABLE			pub enum UNWIND_HISTORY_TABLE {}
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket(net_imp::UdpSocket);
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
Unaligned			struct Unaligned<T>(T);
Union			pub struct Union<'a, T: 'a, S: 'a> 
UnsafeFlavor			trait UnsafeFlavor<T> 
UnsafeFlavor for Receiver			impl<T> UnsafeFlavor<T> for Receiver<T> 
UnsafeFlavor for Sender			impl<T> UnsafeFlavor<T> for Sender<T> 
Unwinder			            struct Unwinder 
Unwinder			            struct Unwinder 
UpgradeResult			pub enum UpgradeResult 
UpgradeResult			pub enum UpgradeResult 
VacantEntry			impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> 
VacantEntry			pub struct VacantEntry<'a, K: 'a, V: 'a> 
VacantEntryState			enum VacantEntryState<K, V, M> 
Value			    struct Value<T: 'static> 
Values			pub struct Values<'a, K: 'a, V: 'a> 
VarError			pub enum VarError 
Vars			pub struct Vars { inner: VarsOs }
VarsOs			pub struct VarsOs { inner: os_imp::Env }
WEXITSTATUS			    pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }
WEXITSTATUS			    pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }
WIFEXITED			    pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }
WIFEXITED			    pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }
WIN32_FILE_ATTRIBUTE_DATA			pub struct WIN32_FILE_ATTRIBUTE_DATA 
WIN32_FIND_DATAW			pub struct WIN32_FIND_DATAW 
WSACleanup			    pub fn WSACleanup() -> c_int;
WSADATA			pub struct WSADATA 
WSADuplicateSocketW			    pub fn WSADuplicateSocketW(s: SOCKET,
WSAGetLastError			    pub fn WSAGetLastError() -> c_int;
WSANETWORKEVENTS			pub struct WSANETWORKEVENTS 
WSAPROTOCOLCHAIN			pub struct WSAPROTOCOLCHAIN 
WSAPROTOCOL_INFO			pub struct WSAPROTOCOL_INFO 
WSASocketW			    pub fn WSASocketW(af: c_int,
WSAStartup			    pub fn WSAStartup(wVersionRequested: WORD,
WTERMSIG			    pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }
WTERMSIG			    pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }
WaitForSingleObject			    pub fn WaitForSingleObject(hHandle: HANDLE,
WaitTimeoutResult			impl WaitTimeoutResult 
WaitTimeoutResult			pub struct WaitTimeoutResult(bool);
WaitToken			impl WaitToken 
WaitToken			pub struct WaitToken 
WakeAllConditionVariable			    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE)
WakeConditionVariable			    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE)
WalkDir			pub struct WalkDir 
Write			impl<'a> Write for &'a File 
Write			impl<'a, W: Write + ?Sized> Write for &'a mut W 
Write			impl<'a> Write for &'a mut [u8] 
Write			pub trait Write 
Write			impl<'a> Write for &'a TcpStream 
Write for Box			impl<W: Write + ?Sized> Write for Box<W> 
Write for Broadcast			impl<T: Write, U: Write> Write for Broadcast<T, U> 
Write for BufWriter			impl<W: Write> Write for BufWriter<W> 
Write for ChildStdin			impl Write for ChildStdin 
Write for Cursor			impl Write for Cursor<Box<[u8]>> 
Write for Cursor			impl Write for Cursor<Vec<u8>> 
Write for Cursor			impl<'a> Write for Cursor<&'a mut [u8]> 
Write for FailFlushWriter			        impl Write for FailFlushWriter 
Write for File			impl Write for File 
Write for LineWriter			impl<W: Write> Write for LineWriter<W> 
Write for Sink			impl Write for Sink 
Write for Stderr			impl Write for Stderr 
Write for StderrLock			impl<'a> Write for StderrLock<'a> 
Write for StderrRaw			impl Write for StderrRaw 
Write for Stdout			impl Write for Stdout 
Write for StdoutLock			impl<'a> Write for StdoutLock<'a> 
Write for StdoutRaw			impl Write for StdoutRaw 
Write for TcpStream			impl Write for TcpStream 
Write for Vec			impl Write for Vec<u8> 
WriteConsoleW			    pub fn WriteConsoleW(hConsoleOutput: HANDLE,
WriteFile			    pub fn WriteFile(hFile: HANDLE,
Wtf8			impl Wtf8 
Wtf8			pub struct Wtf8 
Wtf8Buf			impl Wtf8Buf 
Wtf8Buf			pub struct Wtf8Buf 
Wtf8CodePoints			pub struct Wtf8CodePoints<'a> 
_NSGetArgc			        fn _NSGetArgc() -> *mut c_int;
_NSGetArgv			        fn _NSGetArgv() -> *mut *mut *mut c_char;
_NSGetExecutablePath			        fn _NSGetExecutablePath(buf: *mut libc::c_char,
_Unwind_Action			pub enum _Unwind_Action 
_Unwind_Backtrace			        pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,
_Unwind_Context			pub enum _Unwind_Context {}
_Unwind_Context			    pub enum _Unwind_Context {}
_Unwind_DeleteException			    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);
_Unwind_Exception			pub struct _Unwind_Exception 
_Unwind_FindEnclosingFunction			        pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_FindEnclosingFunction			    pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)
_Unwind_GetIP			    pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t 
_Unwind_GetIPInfo			        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,
_Unwind_GetIPInfo			    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,
_Unwind_RaiseException			    pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)
_Unwind_RaiseException			pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)
_Unwind_Reason_Code			pub enum _Unwind_Reason_Code 
_Unwind_Reason_Code			    pub enum _Unwind_Reason_Code 
_Unwind_Resume			    pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;
_Unwind_SjLj_RaiseException			    fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception)
_Unwind_State			pub enum _Unwind_State 
_Unwind_VRS_DataRepresentation			        enum _Unwind_VRS_DataRepresentation 
_Unwind_VRS_Get			            fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,
_Unwind_VRS_RegClass			        enum _Unwind_VRS_RegClass 
_Unwind_VRS_Result			        enum _Unwind_VRS_Result 
__deregister_frame_info			        fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);
__gcc_personality_sj0			        fn __gcc_personality_sj0(version: c_int,
__gcc_personality_v0			        fn __gcc_personality_v0(state: uw::_Unwind_State,
__gcc_personality_v0			        fn __gcc_personality_v0(version: c_int,
__getit			        unsafe fn __getit() -> 
__init			        fn __init() -> 
__rand			pub mod __rand 
__register_frame_info			        fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);
__rust_try_filter			extern fn __rust_try_filter(eh_ptrs: *mut c::EXCEPTION_POINTERS,
_assert_both			    fn _assert_both<T: Send + Sync>() {}
_assert_error_is_sync_send			fn _assert_error_is_sync_send() 
_assert_sync_and_send			fn _assert_sync_and_send() 
_create			    fn _create(&self, path: &Path) -> io::Result<()> 
_ends_with			    fn _ends_with(&self, child: &Path) -> bool 
_from_bytes			    fn _from_bytes(vec: Vec<u8>) -> Option<OsString> 
_getit			        fn _getit() -> &'static 
_is_sync_send			    fn _is_sync_send<T: Sync+Send>() {}
_join			    fn _join(&self, path: &Path) -> PathBuf 
_new			    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> 
_new			    fn _new(kind: ErrorKind, error: Box<error::Error+Send+Sync>) -> Error 
_open			    fn _open(&self, path: &Path) -> io::Result<File> 
_print			pub fn _print(args: fmt::Arguments) 
_push			    fn _push(&mut self, path: &Path) 
_remove_dir_all			fn _remove_dir_all(path: &Path) -> io::Result<()> 
_remove_var			fn _remove_var(k: &OsStr) 
_set_extension			    fn _set_extension(&mut self, extension: &OsStr) -> bool 
_set_file_name			    fn _set_file_name(&mut self, file_name: &OsStr) 
_set_var			fn _set_var(k: &OsStr, v: &OsStr) 
_starts_with			    fn _starts_with(&self, base: &Path) -> bool 
_strip_prefix			    fn _strip_prefix<'a>(&'a self, base: &'a Path)
_tlv_atexit			            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),
_var			fn _var(key: &OsStr) -> Result<String, VarError> 
_var_os			fn _var_os(key: &OsStr) -> Option<OsString> 
_walk_dir			fn _walk_dir(path: &Path) -> io::Result<WalkDir> 
_with_extension			    fn _with_extension(&self, extension: &OsStr) -> PathBuf 
_with_file_name			    fn _with_file_name(&self, file_name: &OsStr) -> PathBuf 
abort			pub fn abort(args: fmt::Arguments) -> ! 
abort_selection			    fn abort_selection(&self) -> bool 
abort_selection			    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> 
abort_selection			    fn abort_selection(&self) -> bool;
abort_selection			    pub fn abort_selection(&mut self, _was_upgrade: bool) -> bool 
abort_selection			    pub fn abort_selection(&mut self,
abort_selection			    pub fn abort_selection(&self) -> bool 
abs			    pub fn abs(self) -> f32 { num::Float::abs(self) }
abs			    pub fn abs(self) -> f64 { num::Float::abs(self) }
abs_sub			    pub fn abs_sub(self, other: f32) -> f32 
abs_sub			    pub fn abs_sub(self, other: f64) -> f64 
accept			    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> 
accept			    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> 
accept			    pub fn accept(&self, storage: *mut libc::sockaddr,
accept			    pub fn accept(socket: SOCKET,
accept			    pub fn accept(&self, storage: *mut c::SOCKADDR,
access			    pub fn access(&self) -> SemaphoreGuard 
accessed			    pub fn accessed(&self) -> u64 { self.to_u64(&self.data.ftLastAccessTime) }
acos			    pub fn acos(self) -> f32 
acos			        pub fn acos(n: c_double) -> c_double;
acos			    pub fn acos(self) -> f64 
acosf			        pub fn acosf(n: c_float) -> c_float;
acosf			        pub unsafe fn acosf(n: c_float) -> c_float 
acosh			    pub fn acosh(self) -> f32 
acosh			    pub fn acosh(self) -> f64 
acquire			    pub fn acquire(&self) 
acquire_send_slot			    fn acquire_send_slot(&self) -> MutexGuard<State<T>> 
add			    pub unsafe fn add(&mut self) 
add			    fn add() 
add			    fn add(self, rhs: Duration) -> Duration 
add			    fn add(self, dur: Duration) -> SystemTime 
add			    fn add(self, other: Duration) -> Instant 
add_duration			        fn add_duration(&self, other: &Duration) -> Timespec 
add_duration			        pub fn add_duration(&self, other: &Duration) -> Instant 
add_duration			        pub fn add_duration(&self, other: &Duration) -> SystemTime 
add_duration			    pub fn add_duration(&self, other: &Duration) -> Instant 
add_duration			    pub fn add_duration(&self, other: &Duration) -> SystemTime 
addr			mod addr;
alloc			    unsafe fn alloc(&self) -> *mut Node<T> 
anon_pipe			pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> 
anon_pipe			pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> 
append			    pub fn append(&mut self, append: bool) -> &mut OpenOptions 
append			    pub fn append(&mut self, append: bool) 
append			    pub fn append(&mut self, append: bool) { self.append = append; }
append_arg			    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) 
append_to_string			fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>
arch			mod arch 
arch			mod arch 
arch			mod arch 
arch			mod arch 
arg			    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command 
arg			    pub fn arg(&mut self, arg: &OsStr) 
arg			    pub fn arg(&mut self, arg: &OsStr) 
args			pub fn args() -> Args 
args			    pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command 
args			pub mod args;
args			pub fn args() -> Args 
args			    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) 
args			pub fn args() -> Args 
args			    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) 
args_os			pub fn args_os() -> ArgsOs 
as_bytes			    pub fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8];
as_bytes_with_nul			    pub fn as_bytes_with_nul(&self) -> &[u8] 
as_inner			    fn as_inner(&self) -> &Slice 
as_inner			    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::File { &self.inner }
as_inner			    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::FileType { &self.0 }
as_inner			    fn as_inner(&self) -> &c::in6_addr { &self.inner }
as_inner			    fn as_inner(&self) -> &c::in_addr { &self.inner }
as_inner			    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }
as_inner			    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }
as_inner			    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }
as_inner			    fn as_inner(&self) -> &AnonPipe { &self.inner }
as_inner			    fn as_inner(&self) -> &imp::Command { &self.inner }
as_inner			    fn as_inner(&self) -> &imp::ExitStatus { &self.0 }
as_inner			    fn as_inner(&self) -> &imp::Process { &self.handle }
as_inner			    fn as_inner(&self) -> &Inner;
as_inner			    fn as_inner(&self) -> &[u8] { &self.bytes }
as_inner			    fn as_inner(&self) -> &c_int { &self.fd }
as_inner			    fn as_inner(&self) -> &raw::stat { &self.stat }
as_inner			    fn as_inner(&self) -> &c_int { self.0.as_inner() }
as_inner			    fn as_inner(&self) -> &c::SOCKET { &self.0 }
as_inner			    fn as_inner(&self) -> &imp::Thread { self.0.native.as_ref().unwrap() }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut fs_imp::DirBuilder 
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut Inner;
as_mut_vec			    fn as_mut_vec(&mut self) -> &mut Vec<u8> 
as_os_str			    pub fn as_os_str(&self) -> &OsStr 
as_os_str			    pub fn as_os_str(&self) -> &'a OsStr 
as_os_str			    pub fn as_os_str(&self) -> &OsStr 
as_os_str			    pub fn as_os_str(self) -> &'a OsStr 
as_path			    pub fn as_path(&self) -> &'a Path 
as_path			    pub fn as_path(&self) -> &Path 
as_pthread_t			    fn as_pthread_t(&self) -> RawPthread 
as_pthread_t			    fn as_pthread_t(&self) -> RawPthread;
as_ptr			    pub fn as_ptr(&self) -> *const c_char 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd;
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle 
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle;
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle 
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle 
as_raw_socket			    fn as_raw_socket(&self) -> RawSocket 
as_raw_socket			    fn as_raw_socket(&self) -> RawSocket;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat { &self.as_inner().stat }
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_ref			    fn as_ref(&self) -> &CStr 
as_ref			    fn as_ref(&self) -> &OsStr 
as_ref			    fn as_ref(&self) -> &OsStr 
as_ref			    fn as_ref(&self) -> &Path 
as_secs			    pub fn as_secs(&self) -> u64 { self.secs }
as_slice			    pub fn as_slice(&self) -> &Wtf8 
as_slice			    pub fn as_slice(&self) -> &Slice 
as_slice			    pub fn as_slice(&self) -> &Slice 
as_str			    pub fn as_str(&self) -> Option<&str> 
as_u8_slice			    fn as_u8_slice(&self) -> &[u8] 
ascii			pub mod ascii;
ascii_byte_at			    pub fn ascii_byte_at(&self, position: usize) -> u8 
asin			    pub fn asin(self) -> f32 
asin			        pub fn asin(n: c_double) -> c_double;
asin			    pub fn asin(self) -> f64 
asinf			        pub fn asinf(n: c_float) -> c_float;
asinf			        pub unsafe fn asinf(n: c_float) -> c_float 
asinh			    pub fn asinh(self) -> f32 
asinh			    pub fn asinh(self) -> f64 
assert_all_eq			    fn assert_all_eq(buf: &[u8], value: u8) 
assert_send			    fn assert_send<T: Send>() {}
assert_sync			    fn assert_sync<T: Sync>() {}
at_exit			pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> 
at_exit_imp			pub mod at_exit_imp;
at_index			    pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> 
atan			    pub fn atan(self) -> f32 
atan			        pub fn atan(n: c_double) -> c_double;
atan			    pub fn atan(self) -> f64 
atan2			    pub fn atan2(self, other: f32) -> f32 
atan2			        pub fn atan2(a: c_double, b: c_double) -> c_double;
atan2			    pub fn atan2(self, other: f64) -> f64 
atan2f			        pub fn atan2f(a: c_float, b: c_float) -> c_float;
atan2f			        pub unsafe fn atan2f(n: c_float, b: c_float) -> c_float 
atanf			        pub fn atanf(n: c_float) -> c_float;
atanf			        pub unsafe fn atanf(n: c_float) -> c_float 
atanh			    pub fn atanh(self) -> f32 
atanh			    pub fn atanh(self) -> f64 
atime			    fn atime(&self) -> raw::time_t { self.as_raw_stat().st_atime }
atime			    fn atime(&self) -> raw::time_t;
atime_nsec			    fn atime_nsec(&self) -> c_long { self.as_raw_stat().st_atime_nsec as c_long }
atime_nsec			    fn atime_nsec(&self) -> c_long;
attrs			    pub fn attrs(&self) -> u32 { self.data.dwFileAttributes as u32 }
avoid_copying_the_body			    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Box<Fn() + Send>) 
backtrace			pub mod backtrace;
backtrace			        fn backtrace(buf: *mut *mut libc::c_void,
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace_create_state			        fn backtrace_create_state(filename: *const libc::c_char,
backtrace_pcinfo			        fn backtrace_pcinfo(state: *mut backtrace_state,
backtrace_state			    enum backtrace_state {}
backtrace_syminfo			        fn backtrace_syminfo(state: *mut backtrace_state,
barrier			mod barrier;
base_port			fn base_port() -> u16 
begin_unwind			pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! 
begin_unwind_fmt			pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, u32)) -> ! 
begin_unwind_inner			fn begin_unwind_inner(msg: Box<Any + Send>,
bench			mod bench;
bench			mod bench 
bench_buffered_reader			    fn bench_buffered_reader(b: &mut test::Bencher) 
bench_buffered_writer			    fn bench_buffered_writer(b: &mut test::Bencher) 
bench_pow_function			    fn bench_pow_function(b: &mut Bencher) 
bench_read_slice			    fn bench_read_slice(b: &mut test::Bencher) 
bench_read_to_end			    fn bench_read_to_end(b: &mut test::Bencher) 
bench_read_vec			    fn bench_read_vec(b: &mut test::Bencher) 
bench_uninitialized			    fn bench_uninitialized(b: &mut test::Bencher) 
bench_write_slice			    fn bench_write_slice(b: &mut test::Bencher) 
bench_write_vec			    fn bench_write_vec(b: &mut test::Bencher) 
binary_file			    fn binary_file() 
bind			    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> 
bind			    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> 
bind			    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> 
bind			    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> 
bind			    pub fn bind(socket: SOCKET, address: *const SOCKADDR,
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bitand			    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
bitor			    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
bitxor			    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
blksize			    fn blksize(&self) -> raw::blksize_t 
blksize			    fn blksize(&self) -> raw::blksize_t;
blocking			mod blocking;
blocks			    fn blocks(&self) -> raw::blkcnt_t 
blocks			    fn blocks(&self) -> raw::blkcnt_t;
borrow			    fn borrow(&self) -> &CStr { self }
borrow			    fn borrow(&self) -> &OsStr { &self[..] }
borrow			    fn borrow(&self) -> &Path 
borrow			    pub fn borrow(&self) -> LockResult<Guard> 
borrowed			    fn borrowed() 
both_ready			    fn both_ready() 
broadcast			    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W>
broadcast			    fn broadcast() 
buffered			mod buffered;
build_hasher			    fn build_hasher(&self) -> SipHasher 
build_with_zero1			    fn build_with_zero1() 
build_with_zero2			    fn build_with_zero2() 
build_with_zero3			    fn build_with_zero3() 
builtin			pub mod builtin 
bump			    fn bump(&mut self, amt: isize) -> isize 
bump			    fn bump(&mut self, amt: isize) -> isize 
by_ref			    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }
bytes			    fn bytes(&self) -> &[u8] 
bytes			    fn bytes(self) -> Bytes<Self> where Self: Sized 
bytes_to_path			    fn bytes_to_path(b: &[u8]) -> PathBuf 
c			        fn c<T: Clone>(t: &T) -> T { t.clone() }
c			            fn c(value: &u32) -> CodePoint { CodePoint::from_u32(*value).unwrap() }
c			        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }
c			pub mod c;
c_str			mod c_str;
c_to_rust			    fn c_to_rust() 
c_void			pub enum c_void 
calculate_allocation			fn calculate_allocation(hash_size: usize, hash_align: usize,
calculate_offsets			fn calculate_offsets(hashes_size: usize,
call_once			    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() 
can_alias_safehash_as_u64			fn can_alias_safehash_as_u64() 
can_recv			    fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    fn can_recv(&self) -> bool;
can_recv			    pub fn can_recv(&mut self) -> bool 
can_recv			    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> 
can_recv			    pub fn can_recv(&self) -> bool 
cannot			                         enum cannot be exhaustively matched against",
canonicalize			pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> 
canonicalize			    pub fn canonicalize(&self) -> io::Result<PathBuf> 
canonicalize			pub fn canonicalize(p: &Path) -> io::Result<PathBuf> 
canonicalize			pub fn canonicalize(p: &Path) -> io::Result<PathBuf> 
canonicalize_works_simple			    fn canonicalize_works_simple() 
cap			    fn cap(&self) -> usize { self.buf.len() }
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
cast_from_usize			    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken 
cast_to_usize			    pub unsafe fn cast_to_usize(self) -> usize 
catch_panic			pub fn catch_panic<F, R>(f: F) -> Result<R>
cause			    fn cause(&self) -> Option<&Error> { None }
cause			    fn cause(&self) -> Option<&Error> 
cause			    fn cause(&self) -> Option<&error::Error> 
cause			    fn cause(&self) -> Option<&std_error::Error> 
cause			    fn cause(&self) -> Option<&error::Error> 
cause			    fn cause(&self) -> Option<&Error> 
cbrt			    pub fn cbrt(self) -> f32 
cbrt			        pub fn cbrt(n: c_double) -> c_double;
cbrt			    pub fn cbrt(self) -> f64 
cbrtf			        pub fn cbrtf(n: c_float) -> c_float;
ceil			    pub fn ceil(self) -> f32 
ceil			    pub fn ceil(self) -> f64 
cell_allowed			    fn cell_allowed() 
chain			    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized 
chan_gone_concurrent			    fn chan_gone_concurrent() 
channel			pub fn channel<T>() -> (Sender<T>, Receiver<T>) 
chars			    fn chars(self) -> Chars<Self> where Self: Sized 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
check			        fn check(m: &HashMap<isize, ()>) 
check			        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,
check			        fn check(str_addr: &str, unspec: bool, loopback: bool,
check_for_errors_in			    pub fn check_for_errors_in<T, F>(_f: F) -> Result<T, String>
check_for_errors_in			    pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where
check_parse			        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool 
child_after_fork			    unsafe fn child_after_fork(cfg: &Command,
child_no			        fn child_no(x: u32) -> Box<Fn() + Send> 
chmod_works			    fn chmod_works() 
circular			    fn circular() 
classify			    pub fn classify(self) -> FpCategory { num::Float::classify(self) }
classify			    pub fn classify(self) -> FpCategory { num::Float::classify(self) }
cleanup			    pub fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { imp::cleanup() }
cleanup			pub fn cleanup() 
cleanup			pub fn cleanup() 
cleanup			pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> 
cleanup			pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> 
cleanup			pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() {}
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) { self.map.clear() }
clone			        fn clone(&self) -> Dropable 
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> Keys<'a, K, V> 
clone			    fn clone(&self) -> Values<'a, K, V> 
clone			    fn clone(&self) -> Difference<'a, T, S> 
clone			    fn clone(&self) -> Intersection<'a, T, S> 
clone			    fn clone(&self) -> Iter<'a, K> { Iter { iter: self.iter.clone() } }
clone			    fn clone(&self) -> SymmetricDifference<'a, T, S> 
clone			    fn clone(&self) -> Union<'a, T, S> { Union { iter: self.iter.clone() } }
clone			    fn clone(&self) -> DefaultState<H> { DefaultState(marker::PhantomData) }
clone			    fn clone(&self) -> Bucket<K,V,M> { *self }
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> RawBucket<K, V> { *self }
clone			    fn clone(&self) -> RawBuckets<'a, K, V> 
clone			    fn clone(&self) -> RawTable<K, V> 
clone			    fn clone(&self) -> SocketAddrV4 { *self }
clone			    fn clone(&self) -> SocketAddrV6 { *self }
clone			    fn clone(&self) -> Ipv4Addr { *self }
clone			    fn clone(&self) -> Ipv6Addr { *self }
clone			    fn clone(&self) -> Sender<T> 
clone			    fn clone(&self) -> SyncSender<T> 
clone			    pub fn clone() -> Option<Vec<Vec<u8>>> 
clone			pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }
clone			    fn clone(&self) -> Self { *self }
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_chan			    pub fn clone_chan(&mut self) 
clone_chan			    pub fn clone_chan(&self) 
clone_while_reading			    fn clone_while_reading() 
cloning			    fn cloning() 
cloning2			    fn cloning2() 
cloning3			    fn cloning3() 
close			    pub unsafe fn close(_handle: *mut u8) { }
close			    pub unsafe fn close(handle: *mut u8) 
close_read_wakes_up			    fn close_read_wakes_up() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
closed			    fn closed() 
closesocket			    pub fn closesocket(socket: SOCKET) -> c_int;
cmath			mod cmath 
cmath			mod cmath 
cmp			    fn cmp(&self, other: &CStr) -> Ordering 
cmp			    fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }
cmp			    fn cmp(&self, other: &OsString) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Ipv4Addr) -> Ordering 
cmp			    fn cmp(&self, other: &Ipv6Addr) -> Ordering 
cmp			    fn cmp(&self, other: &Components<'a>) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Path) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &PathBuf) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &PrefixComponent<'a>) -> cmp::Ordering 
cmp			        fn cmp(&self, other: &SystemTime) -> Ordering 
cmp			        fn cmp(&self, other: &Timespec) -> Ordering 
cmp			    fn cmp(&self, other: &SystemTime) -> Ordering 
cmp::Eq for Components			impl<'a> cmp::Eq for Components<'a> {}
cmp::Eq for Path			impl cmp::Eq for Path {}
cmp::Eq for PathBuf			impl cmp::Eq for PathBuf {}
cmp::Ord for Components			impl<'a> cmp::Ord for Components<'a> 
cmp::Ord for Path			impl cmp::Ord for Path 
cmp::Ord for PathBuf			impl cmp::Ord for PathBuf 
cmp::Ord for PrefixComponent			impl<'a> cmp::Ord for PrefixComponent<'a> 
cmp::PartialEq for Components			impl<'a> cmp::PartialEq for Components<'a> 
cmp::PartialEq for Path			impl cmp::PartialEq for Path 
cmp::PartialEq for PathBuf			impl cmp::PartialEq for PathBuf 
cmp::PartialEq for PrefixComponent			impl<'a> cmp::PartialEq for PrefixComponent<'a> 
cmp::PartialOrd for Components			impl<'a> cmp::PartialOrd for Components<'a> 
cmp::PartialOrd for Path			impl cmp::PartialOrd for Path 
cmp::PartialOrd for PathBuf			impl cmp::PartialOrd for PathBuf 
cmp::PartialOrd for PrefixComponent			impl<'a> cmp::PartialOrd for PrefixComponent<'a> 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code_point_from_char			    fn code_point_from_char() 
code_point_from_u32			    fn code_point_from_u32() 
code_point_to_char			    fn code_point_to_char() 
code_point_to_char_lossy			    fn code_point_to_char_lossy() 
code_point_to_string			    fn code_point_to_string() 
code_point_to_u32			    fn code_point_to_u32() 
code_points			    pub fn code_points(&self) -> Wtf8CodePoints 
collections			pub mod collections;
combine			        fn combine(arr: &[u8]) -> i32 
components			    pub fn components(&self) -> Components 
condvar			mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
connect			        fn connect(i: usize, addr: SocketAddr) 
connect			    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> 
connect			    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> 
connect			    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int)
connect_error			    fn connect_error() 
connect_loopback			    fn connect_loopback() 
consts			pub mod consts 
consume			    fn consume(&mut self, amt: usize) 
consume			    fn consume(&mut self, amt: usize) { self.pos += amt as u64; }
consume			    fn consume(&mut self, amt: usize) { (**self).consume(amt) }
consume			    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }
consume			    fn consume(&mut self, amt: usize) 
consume			    fn consume(&mut self, amt: usize);
consume			    fn consume(&mut self, n: usize) { self.inner.consume(n) }
consume			    fn consume(&mut self, _n: usize) {}
contains			    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
contains_key			    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
contains_zero_byte			    fn contains_zero_byte(x: usize) -> bool 
copy			pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> 
copy			pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>
copy			pub fn copy(from: &Path, to: &Path) -> io::Result<u64> 
copy			pub fn copy(from: &Path, to: &Path) -> io::Result<u64> 
copy_copies			    fn copy_copies() 
copy_file_does_not_exist			    fn copy_file_does_not_exist() 
copy_file_dst_dir			    fn copy_file_dst_dir() 
copy_file_dst_exists			    fn copy_file_dst_exists() 
copy_file_ok			    fn copy_file_ok() 
copy_file_preserves_perm_bits			    fn copy_file_preserves_perm_bits() 
copy_file_preserves_streams			    fn copy_file_preserves_streams() 
copy_file_src_dir			    fn copy_file_src_dir() 
copy_src_does_not_exist			    fn copy_src_does_not_exist() 
cos			    pub fn cos(self) -> f32 
cos			    pub fn cos(self) -> f64 
cosh			    pub fn cosh(self) -> f32 
cosh			        pub fn cosh(n: c_double) -> c_double;
cosh			    pub fn cosh(self) -> f64 
coshf			        pub fn coshf(n: c_float) -> c_float;
coshf			        pub unsafe fn coshf(n: c_float) -> c_float 
cp			        fn cp(string: &Wtf8Buf) -> Vec<Option<char>> 
create			    pub fn create(&mut self, create: bool) -> &mut OpenOptions 
create			    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> 
create			    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> 
create			    pub fn create(&mut self, create: bool) 
create			pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
create			    pub fn create(&mut self, create: bool) { self.create = create; }
create			pub unsafe fn create(dtor: Option<Dtor>) -> Key 
create_dir			pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> 
create_dir_all			    fn create_dir_all(&self, path: &Path) -> io::Result<()> 
create_dir_all			pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> 
create_junction			    fn create_junction(src: &Path, dst: &Path) -> io::Result<()> 
create_path			    pub fn create_path(path: &[PathBuf]) -> OsString 
created			    pub fn created(&self) -> u64 { self.to_u64(&self.data.ftCreationTime) }
creation			    fn creation() 
creation_disposition			    fn creation_disposition(&mut self, access: u32) -> &mut OpenOptions 
creation_disposition			    fn creation_disposition(&mut self, val: u32) -> &mut Self;
creation_disposition			    pub fn creation_disposition(&mut self, val: u32) 
creation_time			    fn creation_time(&self) -> u64 { self.as_inner().created() }
creation_time			    fn creation_time(&self) -> u64;
cstr			fn cstr(path: &Path) -> io::Result<CString> 
ctime			    fn ctime(&self) -> raw::time_t { self.as_raw_stat().st_ctime }
ctime			    fn ctime(&self) -> raw::time_t;
ctime_nsec			    fn ctime_nsec(&self) -> c_long { self.as_raw_stat().st_ctime_nsec as c_long }
ctime_nsec			    fn ctime_nsec(&self) -> c_long;
current			    pub unsafe fn current() -> Option<usize> { None }
current			    pub unsafe fn current() -> Option<usize> 
current			    pub unsafe fn current() -> Option<usize> { None }
current			pub fn current() -> Thread 
current_dir			pub fn current_dir() -> io::Result<PathBuf> 
current_dir			    pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_thread			pub fn current_thread() -> Option<Thread> 
cursor			mod cursor;
cvt			pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> 
cvt			fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> 
cvt			pub fn cvt<T: One + Neg<Output=T> + PartialEq>(t: T) -> io::Result<T> 
cvt_gai			pub fn cvt_gai(err: c_int) -> io::Result<()> 
cvt_gai			pub fn cvt_gai(err: c_int) -> io::Result<()> 
cvt_r			pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
cvt_r			pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
datasync			    pub fn datasync(&self) -> io::Result<()> 
datasync			    pub fn datasync(&self) -> io::Result<()> { self.fsync() }
debug			    fn debug() 
debug			    fn debug() 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_surrogate			fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 
decode_surrogate_pair			fn decode_surrogate_pair(lead: u16, trail: u16) -> char 
decrement			    fn decrement(&mut self, token: SignalToken) -> StartResult 
decrement			    fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> 
default			    fn default() -> HashMap<K, V, S> 
default			    fn default() -> RandomState 
default			    fn default() -> HashSet<T, S> 
default			    fn default() -> DefaultState<H> { DefaultState(marker::PhantomData) }
default_handler			fn default_handler(info: &PanicInfo) 
delete_junction			    fn delete_junction(p: &Path) -> io::Result<()> 
demangle			    fn demangle() 
demangle			pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> 
demangle_dollars			    fn demangle_dollars() 
demangle_many_dollars			    fn demangle_many_dollars() 
demangle_windows			    fn demangle_windows() 
dequeue			    fn dequeue(&mut self) -> Option<SignalToken> 
dequeue			    fn dequeue(&mut self) -> T 
deref			    fn deref(&self) -> &CStr 
deref			    fn deref(&self) -> &OsStr 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &Path 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &Wtf8 
deref			    fn deref(&self) -> &RawHandle { &self.0 }
deref_mut			    fn deref_mut(&mut self) -> &mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
description			    fn description(&self) -> &str { self.inner.description() }
description			    fn description(&self) -> &str 
description			            fn description(&self) -> &str { &self.0 }
description			        fn description(&self) -> &str { "A-desc" }
description			    fn description(&self) -> &str { "failed to parse bool" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str;
description			    fn description(&self) -> &str { "nul byte found in data" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			            fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "prefix not found" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "failed to join paths" }
description			    fn description(&self) -> &str { "failed to join paths" }
description			    fn description(&self) -> &str { "other time was not earlier than self" }
desired_access			    fn desired_access(&mut self, access: u32) -> &mut OpenOptions 
desired_access			    fn desired_access(&mut self, access: u32) -> &mut Self;
desired_access			    pub fn desired_access(&mut self, val: u32) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&'static self) 
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy_upgraded_shared_port_when_sender_still_active			    fn destroy_upgraded_shared_port_when_sender_still_active() 
dev			    fn dev(&self) -> raw::dev_t { self.as_raw_stat().st_dev as raw::dev_t }
dev			    fn dev(&self) -> raw::dev_t;
difference			    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> 
dir_entry_methods			    fn dir_entry_methods() 
directory_junctions_are_directories			fn directory_junctions_are_directories() 
display			    pub fn display(&self) -> Display 
distance			    pub fn distance(&self) -> usize 
div			    fn div() 
div			    fn div(self, rhs: u32) -> Duration 
dl			mod dl 
dl			pub mod dl 
dladdr			        fn dladdr(addr: *const libc::c_void,
do_send			    fn do_send(&mut self, t: Message<T>) -> UpgradeResult 
done			    pub fn done(&self, guard: &Guard) 
dont_panic_in_drop_on_panicked_flush			    fn dont_panic_in_drop_on_panicked_flush() 
double_bind			    fn double_bind() 
downcast			    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Error>> 
downcast			    pub fn downcast<T: Error + 'static>(self: Box<Self>)
downcast_mut			    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> 
downcast_ref			    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> 
downcasting			    fn downcasting() 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drain			    pub fn drain(&mut self) -> Drain<T> 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) { (self.SymCleanup)(self.handle); }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&mut self) 
drop_chan			    pub fn drop_chan(&self) 
drop_full			    fn drop_full() 
drop_full			    fn drop_full() 
drop_full_shared			    fn drop_full_shared() 
drop_handler			    pub unsafe fn drop_handler(_handler: &mut super::Handler) 
drop_handler			    pub unsafe fn drop_handler(handler: &mut Handler) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&mut self) 
drop_port			    pub fn drop_port(&self) 
dtors_in_dtors_in_dtors			    fn dtors_in_dtors_in_dtors() 
dumb_print			pub fn dumb_print(args: fmt::Arguments) 
duplicate			    pub fn duplicate(&self) -> io::Result<TcpListener> 
duplicate			    pub fn duplicate(&self) -> io::Result<TcpStream> 
duplicate			    pub fn duplicate(&self) -> io::Result<UdpSocket> 
duplicate			    pub fn duplicate(&self) -> io::Result<Socket> 
duplicate			    pub fn duplicate(&self, access: c::DWORD, inherit: bool,
duplicate			    pub fn duplicate(&self) -> io::Result<Socket> 
dur2intervals			    fn dur2intervals(dur: &Duration) -> u64 
dur2intervals			fn dur2intervals(d: &Duration) -> i64 
dur2timeout			fn dur2timeout(dur: Duration) -> c::DWORD 
duration			    pub fn duration(&self) -> Duration 
duration			mod duration;
duration_from_earlier			    pub fn duration_from_earlier(&self, earlier: Instant) -> Duration 
duration_from_earlier			    pub fn duration_from_earlier(&self, earlier: SystemTime)
dwarf			pub mod dwarf;
dwarf_reader			fn dwarf_reader() 
dynamic_lib			pub mod dynamic_lib;
dynamic_tests			mod dynamic_tests 
e			        fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf 
eabi			pub mod eabi 
each_addr			fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>
each_ip			    fn each_ip(f: &mut FnMut(SocketAddr)) 
each_ip			    fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) 
eh			pub mod eh;
eh_frame_registry			pub mod eh_frame_registry 
elapsed			    pub fn elapsed(&self) -> Duration 
elapsed			    pub fn elapsed(&self) -> Result<Duration, SystemTimeError> 
elf			pub mod elf 
empty			pub fn empty() -> Empty { Empty { _priv: () } }
empty_reads			    fn empty_reads() 
encode_wide			    pub fn encode_wide(&self) -> EncodeWide 
encode_wide			    fn encode_wide(&self) -> EncodeWide 
encode_wide			    fn encode_wide(&self) -> EncodeWide;
ends_with			    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool 
enqueue			    fn enqueue(&mut self, node: &mut Node) -> WaitToken 
enqueue			    fn enqueue(&mut self, t: T) 
entry			    pub fn entry(&mut self, key: K) -> Entry<K, V> 
env			pub mod env;
env			    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env_clear			    pub fn env_clear(&mut self) -> &mut Command 
env_clear			    pub fn env_clear(&mut self) 
env_clear			    pub fn env_clear(&mut self) 
env_cmd			    pub fn env_cmd() -> Command 
env_remove			    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
environ			pub unsafe fn environ() -> *mut *const *const c_char 
envvar			    pub fn envvar() -> &'static str 
eq			    fn eq(&self, other: &HashMap<K, V, S>) -> bool 
eq			            fn eq(&self, other: &Self) -> bool 
eq			    fn eq(&self, other: &HashSet<T, S>) -> bool 
eq			    fn eq(a: Option<OsString>, b: Option<&str>) 
eq			    fn eq(&self, other: &CStr) -> bool 
eq			    fn eq(&self, other: &OsStr) -> bool 
eq			    fn eq(&self, other: &OsString) -> bool 
eq			    fn eq(&self, other: &str) -> bool 
eq			    fn eq(&self, other: &SocketAddrV4) -> bool 
eq			    fn eq(&self, other: &SocketAddrV6) -> bool 
eq			    fn eq(&self, other: &Ipv4Addr) -> bool 
eq			    fn eq(&self, other: &Ipv6Addr) -> bool 
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			    fn eq(&self, other: &Components<'a>) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &PathBuf) -> bool 
eq			    fn eq(&self, other: &PrefixComponent<'a>) -> bool 
eq			        fn eq(&self, other: &SystemTime) -> bool 
eq			        fn eq(&self, other: &Timespec) -> bool 
eq			    fn eq(&self, other: &SystemTime) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &char) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &u8) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool 
equal_hash			    fn equal_hash() 
erf			        pub fn erf(n: c_double) -> c_double;
erfc			        pub fn erfc(n: c_double) -> c_double;
erfcf			        pub fn erfcf(n: c_float) -> c_float;
erff			        pub fn erff(n: c_float) -> c_float;
errno			pub fn errno() -> i32 
errno			pub fn errno() -> i32 
errno_location			        fn errno_location() -> *const c_int;
error			    pub fn error(&self) -> &Error { &self.1 }
error			mod error;
error			pub mod error;
error::Error for Error			impl error::Error for Error 
error::Error for IntoInnerError			impl<W: Reflect + Send + fmt::Debug> error::Error for IntoInnerError<W> 
error::Error for RecvError			impl error::Error for RecvError 
error::Error for SendError			impl<T: Send + Reflect> error::Error for SendError<T> 
error::Error for TestError			        impl error::Error for TestError 
error::Error for TryRecvError			impl error::Error for TryRecvError 
error::Error for TrySendError			impl<T: Send + Reflect> error::Error for TrySendError<T> 
error_cb			    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,
error_repeat			    fn error_repeat(byte: u8, limit: u64) -> ErrorRepeat 
error_string			pub fn error_string(errno: i32) -> String 
error_string			pub fn error_string(errnum: i32) -> String 
escape_default			pub fn escape_default(c: u8) -> EscapeDefault 
exception_cleanup			    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,
exists			    pub fn exists(&self) -> bool 
exit			pub fn exit(code: i32) -> ! 
exit			pub fn exit(code: i32) -> ! 
exit			pub fn exit(code: i32) -> ! 
exit_reported_right			    fn exit_reported_right() 
exited			    fn exited(&self) -> bool 
exp			    pub fn exp(self) -> f32 
exp			    pub fn exp(self) -> f64 
exp2			    pub fn exp2(self) -> f32 
exp2			    pub fn exp2(self) -> f64 
exp_m1			    pub fn exp_m1(self) -> f32 
exp_m1			    pub fn exp_m1(self) -> f64 
expect_full			    pub fn expect_full(self) -> FullBucket<K, V, M> 
expm1			        pub fn expm1(n: c_double) -> c_double;
expm1f			        pub fn expm1f(n: c_float) -> c_float;
ext			pub mod ext;
ext			pub mod ext;
extend			    fn extend<T: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: T) 
extend			    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) 
extend			    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) 
extend			    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) 
extend			    fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) 
extend			    fn extend<T: IntoIterator<Item=CodePoint>>(&mut self, iterable: T) 
extension			    pub fn extension(&self) -> Option<&OsStr> 
f			        fn f(values: &[u32]) -> Wtf8Buf 
f			        fn f(i: i32, tx: Sender<()>) 
f32			impl f32 
f64			impl f64 
fail			        fn fail(output: &mut AnonPipe) -> ! 
fallback			mod fallback 
fallback			    unsafe fn fallback() -> Option<OsString> { None }
fallback			    unsafe fn fallback() -> Option<OsString> 
fast_rebind			    fn fast_rebind() 
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd			pub mod fd;
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd_set			pub fn fd_set(set: &mut fd_set, s: SOCKET) 
fd_set			pub struct fd_set 
fdim			        pub fn fdim(a: c_double, b: c_double) -> c_double;
fdimf			        pub fn fdimf(a: c_float, b: c_float) -> c_float;
ffi			pub mod ffi;
ffi			pub mod ffi;
ffi			pub mod ffi;
file			    pub fn file(&self) -> &str 
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_attributes			    fn file_attributes(&self) -> u32 { self.as_inner().attrs() }
file_attributes			    fn file_attributes(&self) -> u32;
file_name			    pub fn file_name(&self) -> OsString 
file_name			    pub fn file_name(&self) -> Option<&OsStr> 
file_name			    pub fn file_name(&self) -> OsString 
file_name			    pub fn file_name(&self) -> OsString 
file_size			    fn file_size(&self) -> u64 { self.as_inner().size() }
file_size			    fn file_size(&self) -> u64;
file_stem			    pub fn file_stem(&self) -> Option<&OsStr> 
file_test_directoryinfo_check_exists_before_and_after_mkdir			    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() 
file_test_directoryinfo_readdir			    fn file_test_directoryinfo_readdir() 
file_test_fileinfo_check_exists_before_and_after_file_creation			    fn file_test_fileinfo_check_exists_before_and_after_file_creation() 
file_test_fileinfo_false_when_checking_is_file_on_a_directory			    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() 
file_test_io_non_positional_read			    fn file_test_io_non_positional_read() 
file_test_io_seek_and_tell_smoke_test			    fn file_test_io_seek_and_tell_smoke_test() 
file_test_io_seek_and_write			    fn file_test_io_seek_and_write() 
file_test_io_seek_shakedown			    fn file_test_io_seek_shakedown() 
file_test_io_smoke_test			    fn file_test_io_smoke_test() 
file_test_iounlinking_invalid_path_should_raise_condition			    fn file_test_iounlinking_invalid_path_should_raise_condition() 
file_test_stat_is_correct_on_is_dir			    fn file_test_stat_is_correct_on_is_dir() 
file_test_stat_is_correct_on_is_file			    fn file_test_stat_is_correct_on_is_file() 
file_test_walk_dir			    fn file_test_walk_dir() 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }
fill_buf			    fn fill_buf(&mut self) -> Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> Result<&[u8]>;
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(&[]) }
fill_bytes			    fn fill_bytes(&mut self, bytes: &mut [u8]) 
fill_bytes			        fn fill_bytes(&mut self, v: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, mut v: &mut [u8]) 
fill_utf16_buf			fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>
final_lead_surrogate			    fn final_lead_surrogate(&self) -> Option<u16> 
find_existing			fn find_existing(b: &mut Bencher) 
find_landing_pad			pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext)
find_landing_pad			unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> 
find_nonexisting			fn find_nonexisting(b: &mut Bencher) 
find_zero_slice			                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) 
finished			    fn finished(&self) -> bool 
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			        fn first<A, B>((a, _): (A, B)) -> A { a }
first			    pub fn first(table: M) -> Bucket<K, V, M> 
first_bucket_raw			    fn first_bucket_raw(&self) -> RawBucket<K, V> 
flag			    fn flag(&mut self, bit: c_int, on: bool) 
flag_locked			    unsafe fn flag_locked(&self) -> bool 
flags_and_attributes			    fn flags_and_attributes(&mut self, access: u32) -> &mut OpenOptions 
flags_and_attributes			    fn flags_and_attributes(&mut self, val: u32) -> &mut Self;
flags_and_attributes			    pub fn flags_and_attributes(&mut self, val: u32) 
floor			    pub fn floor(self) -> f32 
floor			    pub fn floor(self) -> f64 
flowinfo			    pub fn flowinfo(&self) -> u32 { ntoh(self.inner.sin6_flowinfo) }
flush			    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }
flush			            fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { (**self).flush() }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> Result<()> 
flush			    fn flush(&mut self) -> Result<()>;
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush_buf			    fn flush_buf(&mut self) -> io::Result<()> 
fmax			        pub fn fmax(a: c_double, b: c_double) -> c_double;
fmaxf			        pub fn fmaxf(a: c_float, b: c_float) -> c_float;
fmin			        pub fn fmin(a: c_double, b: c_double) -> c_double;
fminf			        pub fn fminf(a: c_float, b: c_float) -> c_float;
fmod			        pub fn fmod(a: c_double, b: c_double) -> c_double;
fmodf			        pub fn fmodf(a: c_float, b: c_float) -> c_float;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for BufReader			impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug 
fmt::Debug for BufWriter			impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug 
fmt::Debug for CStr			impl fmt::Debug for CStr 
fmt::Debug for CString			impl fmt::Debug for CString 
fmt::Debug for CodePoint			impl fmt::Debug for CodePoint 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Display			impl<'a> fmt::Debug for Display<'a> 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for HashSet			impl<T, S> fmt::Debug for HashSet<T, S>
fmt::Debug for Instant			    impl fmt::Debug for Instant 
fmt::Debug for Instant			impl fmt::Debug for Instant 
fmt::Debug for Ipv4Addr			impl fmt::Debug for Ipv4Addr 
fmt::Debug for Ipv6Addr			impl fmt::Debug for Ipv6Addr 
fmt::Debug for LineWriter			impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug 
fmt::Debug for Mutex			impl<T: ?Sized + fmt::Debug + 'static> fmt::Debug for Mutex<T> 
fmt::Debug for Output			impl fmt::Debug for Output 
fmt::Debug for Path			impl fmt::Debug for Path 
fmt::Debug for PathBuf			impl fmt::Debug for PathBuf 
fmt::Debug for PoisonError			impl<T> fmt::Debug for PoisonError<T> 
fmt::Debug for ReentrantMutex			impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> 
fmt::Debug for Repr			impl fmt::Debug for Repr 
fmt::Debug for RwLock			impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> 
fmt::Debug for SendError			impl<T> fmt::Debug for SendError<T> 
fmt::Debug for SocketAddrV4			impl fmt::Debug for SocketAddrV4 
fmt::Debug for SocketAddrV6			impl fmt::Debug for SocketAddrV6 
fmt::Debug for SystemTime			    impl fmt::Debug for SystemTime 
fmt::Debug for SystemTime			impl fmt::Debug for SystemTime 
fmt::Debug for SystemTime			impl fmt::Debug for SystemTime 
fmt::Debug for TcpListener			impl fmt::Debug for TcpListener 
fmt::Debug for TcpListener			impl fmt::Debug for TcpListener 
fmt::Debug for TcpStream			impl fmt::Debug for TcpStream 
fmt::Debug for TcpStream			impl fmt::Debug for TcpStream 
fmt::Debug for Thread			impl fmt::Debug for Thread 
fmt::Debug for TryLockError			impl<T> fmt::Debug for TryLockError<T> 
fmt::Debug for TrySendError			impl<T> fmt::Debug for TrySendError<T> 
fmt::Debug for UdpSocket			impl fmt::Debug for UdpSocket 
fmt::Debug for UdpSocket			impl fmt::Debug for UdpSocket 
fmt::Debug for Wtf8			impl fmt::Debug for Wtf8 
fmt::Debug for Wtf8Buf			impl fmt::Debug for Wtf8Buf 
fmt::Display for A			    impl fmt::Display for A 
fmt::Display for AddrParseError			impl fmt::Display for AddrParseError 
fmt::Display for B			    impl fmt::Display for B 
fmt::Display for CharsError			impl fmt::Display for CharsError 
fmt::Display for Display			impl<'a> fmt::Display for Display<'a> 
fmt::Display for Error			impl fmt::Display for Error 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for IntoInnerError			impl<W> fmt::Display for IntoInnerError<W> 
fmt::Display for IntoStringError			impl fmt::Display for IntoStringError 
fmt::Display for IpAddr			impl fmt::Display for IpAddr 
fmt::Display for Ipv4Addr			impl fmt::Display for Ipv4Addr 
fmt::Display for Ipv6Addr			impl fmt::Display for Ipv6Addr 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for NulError			impl fmt::Display for NulError 
fmt::Display for PoisonError			impl<T> fmt::Display for PoisonError<T> 
fmt::Display for RecvError			impl fmt::Display for RecvError 
fmt::Display for SendError			impl<T> fmt::Display for SendError<T> 
fmt::Display for SocketAddr			impl fmt::Display for SocketAddr 
fmt::Display for SocketAddrV4			impl fmt::Display for SocketAddrV4 
fmt::Display for SocketAddrV6			impl fmt::Display for SocketAddrV6 
fmt::Display for StripPrefixError			impl fmt::Display for StripPrefixError 
fmt::Display for SystemTimeError			impl fmt::Display for SystemTimeError 
fmt::Display for TestError			        impl fmt::Display for TestError 
fmt::Display for TryLockError			impl<T: Send + Reflect> fmt::Display for TryLockError<T> 
fmt::Display for TryRecvError			impl fmt::Display for TryRecvError 
fmt::Display for TrySendError			impl<T> fmt::Display for TrySendError<T> 
fmt::Display for VarError			impl fmt::Display for VarError 
fmt::Write for Adaptor			        impl<'a, T: Write + ?Sized> fmt::Write for Adaptor<'a, T> 
fmt_subslice			                    fn fmt_subslice(segments: &[u16], fmt: &mut fmt::Formatter) -> fmt::Result 
foo			        fn foo() -> Foo 
formatted			    fn formatted() 
fract			    pub fn fract(self) -> f32 { self - self.trunc() }
fract			    pub fn fract(self) -> f64 { self - self.trunc() }
freeaddrinfo			    pub fn freeaddrinfo(res: *mut ADDRINFOA);
frequency			fn frequency() -> c::LARGE_INTEGER 
frexp			    pub fn frexp(self) -> (f32, isize) 
frexp			        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;
frexp			    pub fn frexp(self) -> (f64, isize) 
frexpf			        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;
frexpf			        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float 
frob			    fn frob() 
from			    fn from(err: &'a str) -> Box<Error> 
from			    fn from(err: &'b str) -> Box<Error + Send + Sync + 'a> 
from			    fn from(err: E) -> Box<Error + 'a> 
from			    fn from(err: E) -> Box<Error + Send + Sync + 'a> 
from			    fn from(err: String) -> Box<Error + Send + Sync> 
from			    fn from(str_err: String) -> Box<Error> 
from			    fn from(_: NulError) -> io::Error 
from			    fn from(s: &'a CStr) -> CString 
from			    fn from(s: CString) -> Vec<u8> 
from			    fn from(s: &'a T) -> OsString 
from			    fn from(s: String) -> OsString 
from			    fn from(iie: IntoInnerError<W>) -> Error { iie.1 }
from			    fn from(ip: Ipv4Addr) -> u32 
from			    fn from(ip: u32) -> Ipv4Addr 
from			    fn from(s: &'a Path) -> Cow<'a, Path> 
from			    fn from(s: &'a T) -> PathBuf 
from			    fn from(s: OsString) -> PathBuf 
from			    fn from(s: PathBuf) -> Cow<'a, Path> 
from			    fn from(s: String) -> PathBuf 
from			    fn from(err: PoisonError<T>) -> TryLockError<T> 
from_be			        fn from_be(i: Self) -> Self { <
from_be			    fn from_be(i: Self) -> Self;
from_bytes			    pub fn from_bytes<B>(bytes: B) -> Option<OsString> where B: Into<Vec<u8>> 
from_bytes			    fn from_bytes(slice: &[u8]) -> &OsStr 
from_bytes			    fn from_bytes(slice: &[u8]) -> &Self;
from_bytes_unchecked			    unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 
from_char			    pub fn from_char(value: char) -> CodePoint 
from_fd			    pub fn from_fd(fd: libc::c_int) -> AnonPipe 
from_inner			    fn from_inner(buf: Buf) -> OsString 
from_inner			    fn from_inner(inner: &Slice) -> &OsStr 
from_inner			    fn from_inner(f: fs_imp::File) -> File 
from_inner			    fn from_inner(f: fs_imp::FilePermissions) -> Permissions 
from_inner			    fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 
from_inner			    fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 
from_inner			    fn from_inner(addr: c::in6_addr) -> Ipv6Addr 
from_inner			    fn from_inner(addr: c::in_addr) -> Ipv4Addr 
from_inner			    fn from_inner(inner: net_imp::TcpListener) -> TcpListener 
from_inner			    fn from_inner(inner: net_imp::TcpStream) -> TcpStream { TcpStream(inner) }
from_inner			    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket { UdpSocket(inner) }
from_inner			    fn from_inner(inner: imp::RawStdio) -> Stdio 
from_inner			    fn from_inner(inner: Inner) -> Self;
from_inner			    fn from_inner(socket: Socket) -> TcpListener 
from_inner			    fn from_inner(socket: Socket) -> TcpStream 
from_inner			    fn from_inner(socket: Socket) -> UdpSocket 
from_inner			    fn from_inner(fd: c_int) -> File 
from_inner			    fn from_inner(mode: raw::mode_t) -> FilePermissions 
from_inner			    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }
from_inner			    fn from_inner(handle: c::HANDLE) -> File 
from_inner			    fn from_inner(sock: c::SOCKET) -> Socket { Socket(sock) }
from_intervals			    fn from_intervals(intervals: i64) -> SystemTime 
from_iter			    fn from_iter<T: IntoIterator<Item=(K, V)>>(iterable: T) -> HashMap<K, V, S> 
from_iter			    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> HashSet<T, S> 
from_iter			    fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf 
from_iter			    fn from_iter<T: IntoIterator<Item=CodePoint>>(iter: T) -> Wtf8Buf 
from_millis			    pub fn from_millis(millis: u64) -> Duration 
from_mode			    fn from_mode(mode: raw::mode_t) -> Permissions 
from_mode			    fn from_mode(mode: raw::mode_t) -> Self;
from_ptr			    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr 
from_raw			    pub unsafe fn from_raw(ptr: *mut c_char) -> CString 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> Self;
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> fs::File 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio 
from_raw_handle			    unsafe fn from_raw_handle(handle: RawHandle) -> Self;
from_raw_handle			    unsafe fn from_raw_handle(handle: RawHandle) -> fs::File 
from_raw_handle			    unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio 
from_raw_os_error			    pub fn from_raw_os_error(code: i32) -> Error 
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> Self;
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener 
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream 
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket 
from_secs			    pub fn from_secs(secs: u64) -> Duration 
from_seed			    fn from_seed(seed: &'a [usize]) -> StdRng 
from_str			    fn from_str(s: &str) -> Result<IpAddr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> 
from_str			    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> 
from_str			    pub fn from_str(str: &str) -> Wtf8Buf 
from_str			    pub fn from_str(value: &str) -> &Wtf8 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_string			    pub fn from_string(string: String) -> Wtf8Buf 
from_string			    pub fn from_string(s: String) -> Buf 
from_string			    pub fn from_string(s: String) -> Buf 
from_u32			    pub fn from_u32(value: u32) -> Option<CodePoint> 
from_u32_unchecked			    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint 
from_u8_slice			    unsafe fn from_u8_slice(s: &[u8]) -> &Path 
from_u8_slice			    fn from_u8_slice(s: &[u8]) -> &Slice 
from_vec			    fn from_vec(vec: Vec<u8>) -> OsString 
from_vec			    fn from_vec(vec: Vec<u8>) -> Self;
from_vec_unchecked			    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString 
from_wide			    pub fn from_wide(v: &[u16]) -> Wtf8Buf 
from_wide			    fn from_wide(wide: &[u16]) -> OsString 
from_wide			    fn from_wide(wide: &[u16]) -> Self;
fs			pub mod fs;
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs 
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fsync			    pub fn fsync(&self) -> io::Result<()> 
fsync			    pub fn fsync(&self) -> io::Result<()> 
full			    pub fn full(&self) -> &FullBucket<K, V, M> 
gap_peek			    pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> 
ge			    fn ge(&self, other: &OsStr) -> bool { self.bytes().ge(other.bytes()) }
ge			    fn ge(&self, other: &OsString) -> bool { &**self >= &**other }
get			    fn get(&self, key: &Q) -> Option<&K> 
get			    pub fn get(&self) -> &V 
get			    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
get			    fn get(&self, key: &Q) -> Option<&Self::Key>;
get			    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>
get			    pub fn get(&'static self) -> Option<Arc<T>> 
get			    pub fn get(&self) -> bool 
get			    pub fn get(&self) -> *mut u8 
get			    pub unsafe fn get(&self) -> *mut u8 { imp::get(self.key()) }
get			pub unsafe fn get(key: Key) -> *mut u8 
get			    fn get(&self) -> &Handle { self.0.as_ref().unwrap() }
get			pub fn get(handle: c::DWORD) -> io::Result<Output> 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> 
get			        pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }
get			        pub unsafe fn get(&self) -> *mut T { self.inner.get() }
get_creation_disposition			    fn get_creation_disposition(&self) -> c::DWORD 
get_desired_access			    fn get_desired_access(&self) -> c::DWORD 
get_flags_and_attributes			    fn get_flags_and_attributes(&self) -> c::DWORD 
get_global_ptr			    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> 
get_mode			        fn get_mode(_fd: c_int) -> Option<(bool, bool)> 
get_mode			        fn get_mode(fd: c_int) -> Option<(bool, bool)> 
get_mut			    pub fn get_mut(&mut self) -> &mut V 
get_mut			    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
get_mut			    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }
get_mut			    pub fn get_mut(&mut self) -> &mut T { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> Option<&mut (error::Error+Send+Sync+'static)> 
get_mut			    pub fn get_mut(&mut self) -> LockResult<&mut T> 
get_mut			    pub fn get_mut(&mut self) -> LockResult<&mut T> 
get_mut			    pub fn get_mut(&mut self) -> &mut T { &mut self.guard }
get_path			        fn get_path(_fd: c_int) -> Option<PathBuf> 
get_path			        fn get_path(fd: c_int) -> Option<PathBuf> 
get_path			fn get_path(f: &File) -> io::Result<PathBuf> 
get_ref			    pub fn get_ref(&self) -> &R { &self.inner }
get_ref			    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }
get_ref			    pub fn get_ref(&self) -> &W { self.inner.get_ref() }
get_ref			    pub fn get_ref(&self) -> &T { &self.inner }
get_ref			    pub fn get_ref(&self) -> Option<&(error::Error+Send+Sync+'static)> 
get_ref			    pub fn get_ref(&self) -> &T { &self.guard }
get_remove_insert			fn get_remove_insert(b: &mut Bencher) 
get_share_mode			    fn get_share_mode(&self) -> c::DWORD 
get_stack_start			    unsafe fn get_stack_start() -> Option<*mut libc::c_void> 
getaddrinfo			    pub fn getaddrinfo(node: *const c_char, service: *const c_char,
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getenv			pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> 
getenv			pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> 
getnameinfo			    pub fn getnameinfo(sa: *const SOCKADDR, salen: c_int,
getpeername			    pub fn getpeername(socket: SOCKET,
getrandom			    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }
getrandom			    fn getrandom(buf: &mut [u8]) -> libc::c_long 
getrandom_fill_bytes			    fn getrandom_fill_bytes(v: &mut [u8]) 
getrandom_next_u32			    fn getrandom_next_u32() -> u32 
getrandom_next_u64			    fn getrandom_next_u64() -> u64 
getsockname			    pub fn getsockname(socket: SOCKET,
getsockopt			pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,
getsockopt			    pub fn getsockopt(s: SOCKET,
gid			    fn gid(&self) -> raw::gid_t { self.as_raw_stat().st_gid as raw::gid_t }
gid			    fn gid(&self) -> raw::gid_t;
gid			    fn gid(&mut self, id: gid_t) -> &mut process::Command 
gid			    fn gid(&mut self, id: gid_t) -> &mut process::Command;
gnu			pub mod gnu;
grow_by_insertion			fn grow_by_insertion(b: &mut Bencher) 
gt			    fn gt(&self, other: &OsStr) -> bool { self.bytes().gt(other.bytes()) }
gt			    fn gt(&self, other: &OsString) -> bool { &**self > &**other }
guard			pub mod guard 
guard			pub mod guard 
guard_lock			pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex 
guard_poison			pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag 
handle			    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> 
handle			    pub fn handle(&self) -> &Handle { &self.handle }
handle			pub mod handle;
handle			    pub fn handle(&self) -> &Handle { &self.inner }
handle			    pub fn handle(&self) -> &Handle { &self.handle }
handle			    pub fn handle(&self) -> &Handle 
handle			    pub fn handle(&self) -> &Handle { &self.handle }
handle_ebadf			fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> 
hard_link			pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> 
has_implicit_root			    fn has_implicit_root(&self) -> bool 
has_physical_root			fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool 
has_root			    fn has_root(&self) -> bool 
has_root			    pub fn has_root(&self) -> bool 
hash			            fn hash<H: hash::Hasher>(&self, h: &mut H) 
hash			    pub fn hash(&self) -> SafeHash 
hash			mod hash;
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, s: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, s: &mut H) 
hash			        fn hash<T: Hash>(t: T) -> u64 
hash			    fn hash<H: Hasher>(&self, h: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash::Hash for Foo			        impl hash::Hash for Foo 
hash::Hash for Ipv4Addr			impl hash::Hash for Ipv4Addr 
hash::Hash for Ipv6Addr			impl hash::Hash for Ipv6Addr 
hash::Hash for SocketAddrV4			impl hash::Hash for SocketAddrV4 
hash::Hash for SocketAddrV6			impl hash::Hash for SocketAddrV6 
hash_map			pub mod hash_map 
hash_set			pub mod hash_set 
hash_state			pub mod hash_state 
hasher			    fn hasher(&self) -> H { Default::default() }
hashmap			    fn hashmap() 
hashmap_as_queue			fn hashmap_as_queue(b: &mut Bencher) 
hexify			    fn hexify(b: u8) -> u8 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
hton			fn hton<I: NetInt>(i: I) -> I { i.to_be() }
hypot			    pub fn hypot(self, other: f32) -> f32 
hypot			        pub fn hypot(x: c_double, y: c_double) -> c_double;
hypot			    pub fn hypot(self, other: f64) -> f64 
hypotf			        pub fn hypotf(x: c_float, y: c_float) -> c_float;
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> usize { self.id }
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> libc::pthread_t { self.id }
id			    pub fn id(&self) -> u32 
ilogb			        pub fn ilogb(n: c_double) -> c_int;
ilogbf			        pub fn ilogbf(n: c_float) -> c_int;
imp			mod imp 
imp			mod imp 
imp			pub mod imp;
imp			mod imp;
imp			mod imp;
imp			mod imp 
imp			mod imp 
impls			mod impls;
in6_addr			pub struct in6_addr 
in_addr			pub struct in_addr 
inc			        fn inc() 
include_cur_dir			    fn include_cur_dir(&self) -> bool 
incoming			    pub fn incoming(&self) -> Incoming 
index			    fn index(&self, index: &Q) -> &V 
index			    pub fn index(&self) -> usize 
index			    fn index(&self, _index: ops::RangeFull) -> &CStr 
index			    fn index(&self, _index: ops::RangeFull) -> &OsStr 
index			    fn index(&self, _range: ops::RangeFull) -> &Wtf8 
index			    fn index(&self, range: ops::Range<usize>) -> &Wtf8 
index			    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 
index			    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 
info			    fn info() -> &'static libc::mach_timebase_info 
inherit			    pub fn inherit() -> Stdio { Stdio(StdioImp::Inherit) }
inherit_blocker			    pub fn inherit_blocker(&mut self,
init			    unsafe fn init(&'static self) -> Arc<T> 
init			    pub unsafe fn init(_argc: isize, _argv: *const *const u8) 
init			    pub unsafe fn init(argc: isize, argv: *const *const u8) 
init			pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }
init			unsafe fn init() -> bool 
init			pub fn init() 
init			    pub unsafe fn init(&mut self) 
init			pub fn init() {}
init			    pub unsafe fn init() 
init			    pub unsafe fn init() -> Option<usize> { None }
init			    pub unsafe fn init() -> Option<usize> 
init			pub fn init() 
init			    pub unsafe fn init(&mut self) 
init			pub fn init() 
init			pub unsafe fn init() 
init			    pub unsafe fn init() -> Option<usize> { None }
init			    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T 
init_dtors			unsafe fn init_dtors() 
init_env_map			    fn init_env_map(&mut self) 
init_env_map			    fn init_env_map(&mut self)
init_frame			pub fn init_frame(frame: &mut c::STACKFRAME64,
init_state			    unsafe fn init_state() -> *mut backtrace_state 
init_vec_data			    fn init_vec_data() -> Vec<u8> 
initial_trail_surrogate			    fn initial_trail_surrogate(&self) -> Option<u16> 
inner			    unsafe fn inner<'a>(&'a self) -> &'a Flavor<T> 
inner			mod inner 
inner			    fn inner(s: &OsStr) -> io::Result<Vec<u16>> 
inner_mut			    unsafe fn inner_mut<'a>(&'a self) -> &'a mut Flavor<T> 
inner_try			    unsafe fn inner_try(f: fn(*mut u8), data: *mut u8)
inner_unsafe			    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> 
inner_unsafe			    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>>;
ino			    fn ino(&self) -> raw::ino_t { self.as_inner().ino() }
ino			    fn ino(&self) -> raw::ino_t { self.as_raw_stat().st_ino as raw::ino_t }
ino			    fn ino(&self) -> raw::ino_t;
ino			    pub fn ino(&self) -> raw::ino_t 
insert			    pub fn insert(&mut self, k: K, v: V) -> Option<V> 
insert			    pub fn insert(&mut self, mut value: V) -> V 
insert			    pub fn insert(self, value: V) -> &'a mut V 
insert			    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }
insert_hashed_nocheck			    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V 
insert_hashed_ordered			    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) 
insert_or_replace_with			    fn insert_or_replace_with<'a, F>(&'a mut self,
inspect			    pub fn inspect(&self) -> u64 { self.hash }
instant_duration_panic			    fn instant_duration_panic() 
instant_elapsed			    fn instant_elapsed() 
instant_math			    fn instant_math() 
instant_monotonic			    fn instant_monotonic() 
integer_decode			    pub fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }
intersection			    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> 
intervals			    fn intervals(&self) -> i64 
intervals2dur			fn intervals2dur(intervals: u64) -> Duration 
into			    fn into() 
into			    fn into(self) -> OsString 
into_bucket			    pub fn into_bucket(self) -> Bucket<K, V, M> 
into_bytes			    pub fn into_bytes(self) -> Vec<u8> 
into_bytes_with_nul			    pub fn into_bytes_with_nul(self) -> Vec<u8> 
into_cow			    fn into_cow() 
into_cow			    fn into_cow(self) -> Cow<'a, Path> 
into_cow			    fn into_cow(self) -> Cow<'static, Path> 
into_cstring			    pub fn into_cstring(self) -> CString 
into_fd			    pub fn into_fd(self) -> FileDesc { self.0 }
into_fd			    pub fn into_fd(self) -> FileDesc { self.0 }
into_handle			    pub fn into_handle(self) -> Handle { self.handle }
into_handle			    pub fn into_handle(self) -> Handle { self.inner }
into_handle			    pub fn into_handle(self) -> Handle { self.handle }
into_handle			    pub fn into_handle(self) -> Handle { self.handle }
into_id			    pub fn into_id(self) -> libc::pthread_t 
into_inner			    fn into_inner(self) -> Buf 
into_inner			    fn into_inner(self) -> fs_imp::File 
into_inner			    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> 
into_inner			    pub fn into_inner(self) -> W { self.0 }
into_inner			    pub fn into_inner(self) -> T { self.inner }
into_inner			    pub fn into_inner(self) -> Option<Box<error::Error+Send+Sync>> 
into_inner			    fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) 
into_inner			    fn into_inner(self) -> net_imp::TcpListener { self.0 }
into_inner			    fn into_inner(self) -> net_imp::TcpStream { self.0 }
into_inner			    fn into_inner(self) -> net_imp::UdpSocket { self.0 }
into_inner			    fn into_inner(self) -> AnonPipe { self.inner }
into_inner			    fn into_inner(self) -> imp::Process { self.handle }
into_inner			    pub fn into_inner(self) -> LockResult<T> where T: Sized 
into_inner			    pub fn into_inner(self) -> LockResult<T> where T: Sized 
into_inner			    fn into_inner(self) -> Inner;
into_inner			    pub fn into_inner(self) -> T { self.guard }
into_inner			    fn into_inner(self) -> c_int { self.0.into_raw() }
into_inner			    fn into_inner(self) -> c::SOCKET 
into_inner			    fn into_inner(self) -> imp::Thread { self.0.native.unwrap() }
into_iter			    fn into_iter(mut self) -> IterMut<'a, K, V> 
into_iter			    fn into_iter(self) -> IntoIter<K, V> 
into_iter			    fn into_iter(self) -> Iter<'a, K, V> 
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_iter			    fn into_iter(self) -> Iter<'a> { self.iter() }
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> { self.iter() }
into_mut			    pub fn into_mut(self) -> &'a mut V 
into_mut_refs			    pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) 
into_option			    fn into_option(self) -> Option<FullBucket<K, V, M>> 
into_os_string			    pub fn into_os_string(self) -> OsString 
into_pthread_t			    fn into_pthread_t(self) -> RawPthread 
into_pthread_t			    fn into_pthread_t(self) -> RawPthread;
into_raw			    pub fn into_raw(self) -> *mut c_char 
into_raw			    pub fn into_raw(self) -> c_int 
into_raw			    pub fn into_raw(self) -> c::HANDLE 
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_fd			    fn into_raw_fd(self) -> RawFd;
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_handle			    fn into_raw_handle(self) -> RawHandle 
into_raw_handle			    fn into_raw_handle(self) -> RawHandle;
into_raw_handle			    fn into_raw_handle(self) -> RawHandle 
into_raw_handle			    fn into_raw_handle(self) -> RawHandle 
into_raw_socket			    fn into_raw_socket(self) -> RawSocket 
into_raw_socket			    fn into_raw_socket(self) -> RawSocket;
into_refs			    pub fn into_refs(self) -> (&'t K, &'t V) 
into_socket			    pub fn into_socket(self) -> Socket { self.inner }
into_string			    pub fn into_string(self) -> Result<String, IntoStringError> 
into_string			    pub fn into_string(self) -> Result<String, OsString> 
into_string			    pub fn into_string(self) -> Result<String, Wtf8Buf> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string_lossy			    pub fn into_string_lossy(mut self) -> String 
into_table			    pub fn into_table(self) -> M 
into_vec			    pub fn into_vec(self) -> Vec<u8> { self.1 }
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8>;
invalid_encoding			fn invalid_encoding() -> io::Error 
invalid_path_raises			    fn invalid_path_raises() 
io			pub mod io;
io			pub mod io;
io			pub mod io;
io			pub mod io;
io::Read for Maybe			impl<R: io::Read> io::Read for Maybe<R> 
io::Seek for Cursor			impl<T> io::Seek for Cursor<T> where T: AsRef<[u8]> 
io::Write for Maybe			impl<W: io::Write> io::Write for Maybe<W> 
io::Write for Stderr			impl io::Write for Stderr 
io::Write for Stderr			impl io::Write for Stderr 
ip			    pub fn ip(&self) -> &Ipv4Addr 
ip			    pub fn ip(&self) -> &Ipv6Addr 
ip			    pub fn ip(&self) -> IpAddr 
ip			mod ip;
ipv4_properties			    fn ipv4_properties() 
ipv4_to_ipv6			    fn ipv4_to_ipv6() 
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr 
ipv6_addr_to_string			    fn ipv6_addr_to_string() 
ipv6_properties			    fn ipv6_properties() 
ipv6_to_ipv4			    fn ipv6_to_ipv4() 
is			    pub fn is<T: Error + 'static>(&self) -> bool 
is			    pub fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }
is_absolute			    pub fn is_absolute(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool { *self & 128 == 0 }
is_ascii			    fn is_ascii(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool;
is_ascii			    fn is_ascii(&self) -> bool 
is_block_device			    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }
is_block_device			    fn is_block_device(&self) -> bool;
is_broadcast			    pub fn is_broadcast(&self) -> bool 
is_char_device			    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }
is_char_device			    fn is_char_device(&self) -> bool;
is_code_point_boundary			pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool 
is_colon			    fn is_colon(b: &u8) -> bool { *b == b':' }
is_dir			    pub fn is_dir(&self) -> bool { self.0.is_dir() }
is_dir			    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }
is_dir			    pub fn is_dir(&self) -> bool 
is_dir			    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }
is_dir			    pub fn is_dir(&self) -> bool { *self == FileType::Dir }
is_disjoint			    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool 
is_documentation			    pub fn is_documentation(&self) -> bool 
is_drive			    fn is_drive(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.len() == 0 }
is_empty			    pub fn is_empty(&self) -> bool { self.map.is_empty() }
is_eof			    fn is_eof(&self) -> bool 
is_fifo			    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }
is_fifo			    fn is_fifo(&self) -> bool;
is_file			    pub fn is_file(&self) -> bool { self.0.is_file() }
is_file			    pub fn is_file(&self) -> bool { self.file_type().is_file() }
is_file			    pub fn is_file(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }
is_file			    pub fn is_file(&self) -> bool { *self == FileType::File }
is_finite			    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_finite			    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_getrandom_available			    fn is_getrandom_available() -> bool { false }
is_getrandom_available			    fn is_getrandom_available() -> bool 
is_global			    pub fn is_global(&self) -> bool 
is_infinite			    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_infinite			    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_leader			    pub fn is_leader(&self) -> bool { self.0 }
is_link_local			    pub fn is_link_local(&self) -> bool 
is_loopback			    pub fn is_loopback(&self) -> bool 
is_multicast			    pub fn is_multicast(&self) -> bool 
is_mutex			    fn is_mutex() 
is_nan			    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_nan			    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_negative			    pub fn is_negative(self) -> bool { num::Float::is_sign_negative(self) }
is_normal			    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_normal			    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_poisoned			    pub fn is_poisoned(&self) -> bool 
is_poisoned			    pub fn is_poisoned(&self) -> bool 
is_positive			    pub fn is_positive(self) -> bool { num::Float::is_sign_positive(self) }
is_private			    pub fn is_private(&self) -> bool 
is_relative			    pub fn is_relative(&self) -> bool 
is_reparse_point			    fn is_reparse_point(&self) -> bool 
is_sep_byte			    fn is_sep_byte(&self, b: u8) -> bool 
is_sep_byte			    pub fn is_sep_byte(b: u8) -> bool 
is_separator			pub fn is_separator(c: char) -> bool 
is_set			    pub fn is_set(&'static self) -> bool 
is_sign_negative			    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }
is_sign_negative			    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }
is_sign_positive			    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }
is_sign_positive			    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }
is_socket			    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }
is_socket			    fn is_socket(&self) -> bool;
is_subset			    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool 
is_superset			    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool 
is_symlink			    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }
is_symlink			    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }
is_symlink			    pub fn is_symlink(&self) -> bool 
is_unicast_global			    pub fn is_unicast_global(&self) -> bool 
is_unicast_link_local			    pub fn is_unicast_link_local(&self) -> bool 
is_unicast_site_local			    pub fn is_unicast_site_local(&self) -> bool 
is_unique_local			    pub fn is_unique_local(&self) -> bool 
is_unspecified			    pub fn is_unspecified(&self) -> bool 
is_verbatim			    pub fn is_verbatim(&self) -> bool 
is_verbatim_sep			    pub fn is_verbatim_sep(b: u8) -> bool 
issue_15761			    fn issue_15761() 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter(&self) -> Packets { Packets { cur: unsafe { &*self.inner.get() }.head } }
iter_after			fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I>
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
j0			        pub fn j0(n: c_double) -> c_double;
j1			        pub fn j1(n: c_double) -> c_double;
jn			        pub fn jn(i: c_int, n: c_double) -> c_double;
join			        fn join(&self, path: &str) -> PathBuf 
join			    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf 
join			    pub fn join(self) 
join			    pub fn join(self) 
join			    fn join(&mut self) -> Result<T> 
join			    pub fn join(mut self) -> Result<T> 
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths_unix			    fn join_paths_unix() 
join_paths_windows			    fn join_paths_windows() 
key			    unsafe fn key(&self) -> imp::Key 
keys			    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kill			    pub unsafe fn kill(&self) -> io::Result<()> 
kill			    pub unsafe fn kill(&self) -> io::Result<()> 
kind			    pub fn kind(&self) -> ErrorKind 
kind			    pub fn kind(&self) -> Prefix<'a> 
kind			fn kind() -> Kind 
lang_start			fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize 
last_access_time			    fn last_access_time(&self) -> u64 { self.as_inner().accessed() }
last_access_time			    fn last_access_time(&self) -> u64;
last_error			fn last_error() -> io::Error 
last_os_error			    pub fn last_os_error() -> Error 
last_two			        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }
last_write_time			    fn last_write_time(&self) -> u64 { self.as_inner().modified() }
last_write_time			    fn last_write_time(&self) -> u64;
lazy			mod lazy;
lazy_init			    unsafe fn lazy_init(&self) -> usize 
ldexp			    pub fn ldexp(x: f32, exp: isize) -> f32 
ldexp			        pub fn ldexp(x: c_double, n: c_int) -> c_double;
ldexp			    pub fn ldexp(x: f64, exp: isize) -> f64 
ldexpf			        pub fn ldexpf(x: c_float, n: c_int) -> c_float;
ldexpf			        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float 
le			    fn le(&self, other: &OsStr) -> bool { self.bytes().le(other.bytes()) }
le			    fn le(&self, other: &OsString) -> bool { &**self <= &**other }
len			    pub fn len(&self) -> usize { self.table.size() }
len			    fn len(&self) -> usize { self.iter.len() }
len			    pub fn len(&self) -> usize { self.map.len() }
len			    fn len(&self) -> usize { self.elems_left }
len			    fn len(&self) -> usize { self.table.size() }
len			    fn len(&self) -> usize { self.inner.len() }
len			    pub fn len(&self) -> u64 { self.0.size() }
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> usize 
len			    fn len(&self) -> usize { self.iter.len() }
len			    fn len(&self) -> usize { self.range.len() }
len_before_body			    fn len_before_body(&self) -> usize 
lgamma_r			        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;
lgammaf_r			        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;
libbacktrace			pub mod libbacktrace;
libunwind			pub mod libunwind;
limit			    pub fn limit(&self) -> u64 { self.limit }
line			    pub fn line(&self) -> u32 
lines			    fn lines() 
lines			    fn lines(self) -> Lines<Self> where Self: Sized 
link			pub fn link(src: &Path, dst: &Path) -> io::Result<()> 
link			pub fn link(src: &Path, dst: &Path) -> io::Result<()> 
links_work			    fn links_work() 
listen			    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;
listen_localhost			    fn listen_localhost() 
ln			    pub fn ln(self) -> f32 
ln			    pub fn ln(self) -> f64 
ln_1p			    pub fn ln_1p(self) -> f32 
ln_1p			    pub fn ln_1p(self) -> f64 
load			            fn load() -> usize 
local_addr			    pub fn local_addr(&self) -> io::Result<SocketAddr> 
local_addr			    pub fn local_addr(&self) -> io::Result<SocketAddr> 
location			    pub fn location(&self) -> Option<&Location> 
lock			    pub fn lock(&self) -> StderrLock 
lock			    pub fn lock(&self) -> StdinLock 
lock			    pub fn lock(&self) -> StdoutLock 
lock			    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> 
lock			    pub fn lock(&self) -> LockResult<MutexGuard<T>> 
lock			    pub unsafe fn lock(&self) { self.0.lock() }
lock			    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<T>> 
lock			    pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock(&self) 
log			    pub fn log(self, base: f32) -> f32 { self.ln() \/ base.ln() }
log			    pub fn log(self, base: f64) -> f64 { self.ln() \/ base.ln() }
log10			    pub fn log10(self) -> f32 
log10			    pub fn log10(self) -> f64 
log1p			        pub fn log1p(n: c_double) -> c_double;
log1pf			        pub fn log1pf(n: c_float) -> c_float;
log2			    pub fn log2(self) -> f32 
log2			    pub fn log2(self) -> f64 
log_enabled			pub fn log_enabled() -> bool 
logb			        pub fn logb(n: c_double) -> c_double;
logbf			        pub fn logbf(n: c_float) -> c_float;
lookup			pub fn lookup(module: &str, symbol: &str) -> Option<usize> 
lookup_addr			pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> 
lookup_addr			pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> 
lookup_host			pub fn lookup_host(host: &str) -> io::Result<LookupHost> 
lookup_host			pub fn lookup_host(host: &str) -> io::Result<LookupHost> 
lots_and_lots			    fn lots_and_lots() 
lstat			pub fn lstat(p: &Path) -> io::Result<FileAttr> 
lstat			pub fn lstat(p: &Path) -> io::Result<FileAttr> 
lt			    fn lt(&self, other: &OsStr) -> bool { self.bytes().lt(other.bytes()) }
lt			    fn lt(&self, other: &OsString) -> bool { &**self < &**other }
macros			mod macros;
make_argv			fn make_argv(prog: &CString, args: &[CString])
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) 
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self);
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) 
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self);
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }
make_command_line			fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> 
make_dirp			fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) 
make_envp			fn make_envp(env: Option<&HashMap<OsString, OsString>>)
make_envp			fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)
make_handler			    pub unsafe fn make_handler() -> Handler 
make_handler			    pub unsafe fn make_handler() -> super::Handler 
make_hash			    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash 
make_hash			pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash
make_rand_name			    fn make_rand_name() -> OsString 
map			pub mod map;
map			        fn map() -> RefCell<HashMap<i32, i32>> 
map_result			pub fn map_result<T, U, F>(result: LockResult<T>, f: F)
marker::Sync for KeyInner			    unsafe impl<T> marker::Sync for KeyInner<T> { }
matches_begin			    fn matches_begin() 
matches_begin_reversed			    fn matches_begin_reversed() 
matches_end			    fn matches_end() 
matches_end_reversed			    fn matches_end_reversed() 
matches_nul			    fn matches_nul() 
matches_nul_reversed			    fn matches_nul_reversed() 
matches_one			    fn matches_one() 
matches_one_reversed			    fn matches_one_reversed() 
matches_past_nul			    fn matches_past_nul() 
matches_past_nul_reversed			    fn matches_past_nul_reversed() 
max			    pub fn max(self, other: f32) -> f32 
max			    pub fn max(self, other: f64) -> f64 
memchr			mod memchr;
memchr			    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> 
memchr			pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> 
memchr_specific			    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> 
memrchr			    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> 
memrchr			pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> 
memrchr_specific			    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> 
metadata			    pub fn metadata(&self) -> io::Result<Metadata> 
metadata			pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> 
metadata			    pub fn metadata(&self) -> io::Result<fs::Metadata> 
metadata			    pub fn metadata(&self) -> io::Result<FileAttr> 
metadata			    pub fn metadata(&self) -> io::Result<FileAttr> 
min			    pub fn min(self, other: f32) -> f32 
min			    pub fn min(self, other: f64) -> f64 
min_capacity			    fn min_capacity(&self, usable_size: usize) -> usize 
min_stack			pub fn min_stack() -> usize 
min_stack_size			fn min_stack_size(_: *const libc::pthread_attr_t) -> usize 
min_stack_size			fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize 
mk_key			fn mk_key(s: &OsStr) -> OsString 
mkdir			    pub fn mkdir(&self, p: &Path) -> io::Result<()> 
mkdir			    pub fn mkdir(&self, p: &Path) -> io::Result<()> 
mkdir_path_already_exists_error			    fn mkdir_path_already_exists_error() 
mkdir_trailing_slash			    fn mkdir_trailing_slash() 
mode			    fn mode(&mut self, mode: raw::mode_t) -> &mut OpenOptions 
mode			    fn mode(&mut self, mode: raw::mode_t) -> &mut Self;
mode			    fn mode(&mut self, mode: raw::mode_t) -> &mut fs::DirBuilder 
mode			    fn mode(&self) -> raw::mode_t { self.as_inner().mode() }
mode			    fn mode(&self) -> raw::mode_t { self.as_raw_stat().st_mode as raw::mode_t }
mode			    fn mode(&self) -> raw::mode_t;
mode			    pub fn mode(&mut self, mode: raw::mode_t) 
mode			    pub fn mode(&self) -> raw::mode_t { self.mode }
modf			        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;
modff			        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;
modified			    pub fn modified(&self) -> u64 { self.to_u64(&self.data.ftLastWriteTime) }
mpsc			pub mod mpsc;
mpsc_queue			mod mpsc_queue;
mtime			    fn mtime(&self) -> raw::time_t { self.as_raw_stat().st_mtime }
mtime			    fn mtime(&self) -> raw::time_t;
mtime_nsec			    fn mtime_nsec(&self) -> c_long { self.as_raw_stat().st_mtime_nsec as c_long }
mtime_nsec			    fn mtime_nsec(&self) -> c_long;
mul			    fn mul() 
mul			    fn mul(self, rhs: u32) -> Duration 
mul_add			    pub fn mul_add(self, a: f32, b: f32) -> f32 
mul_add			    pub fn mul_add(self, a: f64, b: f64) -> f64 
mul_div_u64			pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 
multicast_scope			    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> 
multiple_connect_interleaved_greedy_schedule			    fn multiple_connect_interleaved_greedy_schedule() 
multiple_connect_interleaved_lazy_schedule			    fn multiple_connect_interleaved_lazy_schedule() 
multiple_connect_serial			    fn multiple_connect_serial() 
mutex			mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
naive_pow			        fn naive_pow<T: Mul<Output=T> + One + Copy>(base: T, exp: usize) -> T 
name			    pub fn name(&self) -> Option<&str> 
name			    pub fn name(mut self, name: String) -> Builder 
name_bytes			    fn name_bytes(&self) -> &[u8] 
nanos			    fn nanos() 
net			pub mod net;
net			pub mod net;
net			pub mod net;
net			pub mod net;
netc			pub mod netc 
new			        fn new(k: usize) -> Dropable 
new			    fn new() -> DefaultResizePolicy 
new			    pub fn new() -> HashMap<K, V, RandomState> 
new			    pub fn new() -> RandomState 
new			    pub fn new() -> HashSet<T, RandomState> 
new			    pub fn new(capacity: usize) -> RawTable<K, V> 
new			    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> 
new			    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> 
new			    pub fn new() -> OsString 
new			    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr 
new			    pub fn new() -> DirBuilder 
new			    pub fn new() -> OpenOptions 
new			    pub fn new(inner: R) -> BufReader<R> 
new			    pub fn new(inner: W) -> BufWriter<W> 
new			    pub fn new(inner: W) -> LineWriter<W> 
new			    pub fn new(inner: T) -> Cursor<T> 
new			    pub fn new<E>(kind: ErrorKind, error: E) -> Error
new			    pub fn new(ip: IpAddr, port: u16) -> SocketAddr 
new			    pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 
new			    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32)
new			    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,
new			    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    pub fn new(t: T) -> AssertRecoverSafe<T> 
new			    pub fn new() -> PathBuf 
new			    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path 
new			    pub fn new<S: AsRef<OsStr>>(program: S) -> Command 
new			    pub fn new() -> io::Result<StdRng> 
new			        pub fn new() -> io::Result<OsRng> 
new			    pub fn new(r: R) -> ReaderRng<R> 
new			    pub fn new(n: usize) -> Barrier 
new			    pub fn new() -> Condvar 
new			    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> 
new			    fn new(inner: Flavor<T>) -> Receiver<T> 
new			    fn new(inner: Flavor<T>) -> Sender<T> 
new			    pub fn new() -> Queue<T> 
new			    unsafe fn new(v: Option<T>) -> *mut Node<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Select 
new			    pub fn new() -> Packet<T> 
new			    fn new() -> *mut Node<T> 
new			    pub unsafe fn new(bound: usize) -> Queue<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new(cap: usize) -> Packet<T> 
new			    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)
new			    pub fn new(t: T) -> Mutex<T> 
new			    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)
new			    pub fn new(t: T) -> RwLock<T> 
new			    pub fn new(count: isize) -> Semaphore 
new			    pub fn new(ptr : *const u8) -> DwarfReader 
new			    pub fn new(guard: T) -> PoisonError<T> 
new			    fn new(lock: &'mutex ReentrantMutex<T>)
new			    pub fn new(t: T) -> ReentrantMutex<T> 
new			    fn new(name: Option<String>) -> Self;
new			    pub fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
new			    pub fn new() -> Wtf8Buf 
new			    pub fn new(fd: c_int) -> FileDesc 
new			    pub fn new() -> DirBuilder 
new			    pub fn new() -> OpenOptions 
new			    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }
new			    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }
new			    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }
new			    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>)
new			    fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType 
new			    fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> 
new			    pub fn new() -> DirBuilder { DirBuilder }
new			    pub fn new() -> OpenOptions { Default::default() }
new			    pub fn new(handle: c::HANDLE) -> Handle 
new			    pub fn new(handle: c::HANDLE) -> RawHandle 
new			    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub unsafe fn new() -> Handler 
new			    fn new(handle: c::HANDLE) -> NoClose 
new			    pub fn new() -> io::Result<Stderr> 
new			    pub fn new() -> io::Result<Stdin> 
new			    pub fn new() -> io::Result<Stdout> 
new			    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>)
new			    fn new(name: Option<String>) -> Thread { Thread::new(name) }
new			    fn new(name: Option<String>) -> Thread 
new			    pub fn new() -> Builder 
new			    pub fn new(secs: u64, nanos: u32) -> Duration 
new_drop			fn new_drop(b : &mut Bencher) 
new_insert_drop			fn new_insert_drop(b : &mut Bencher) 
new_uninitialized			    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> 
next			    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }
next			    fn next(&mut self) -> Option<&'a K> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> { self.iter.next() }
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<K> { self.iter.next() }
next			    fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			    fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<(SafeHash, K, V)> 
next			    fn next(&mut self) -> Option<RawBucket<K, V>> 
next			    pub fn next(&mut self) 
next			    pub fn next(self) -> Bucket<K, V, M> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(String, String)> 
next			    fn next(&mut self) -> Option<OsString> { self.inner.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }
next			    fn next(&mut self) -> Option<String> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<Result<String>> 
next			    fn next(&mut self) -> Option<Result<Vec<u8>>> 
next			    fn next(&mut self) -> Option<Result<u8>> 
next			    fn next(&mut self) -> Option<result::Result<char, CharsError>> 
next			    fn next(&mut self) -> Option<io::Result<SocketAddr>> { self.0.next() }
next			    fn next(&mut self) -> Option<io::Result<TcpStream>> 
next			    fn next(&mut self) -> Option<&'a OsStr> 
next			    fn next(&mut self) -> Option<Component<'a>> 
next			    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }
next			    fn next(&mut self) -> Option<*mut Handle<'static, ()>> 
next			    fn next(&mut self) -> Option<io::Result<SocketAddr>> 
next			    fn next(&mut self) -> Option<CodePoint> 
next			    fn next(&mut self) -> Option<u16> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }
next			    fn next(&mut self) -> Option<OsString> { self.iter.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> 
next			    fn next(&mut self) -> Option<OsString> 
next			    fn next(&mut self) -> Option<PathBuf> 
next_after			    pub fn next_after(self, other: f32) -> f32 
next_after			    pub fn next_after(self, other: f64) -> f64 
next_back			    fn next_back(&mut self) -> Option<u8> 
next_back			    fn next_back(&mut self) -> Option<&'a OsStr> 
next_back			    fn next_back(&mut self) -> Option<Component<'a>> 
next_surrogate			    fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> 
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			        fn next_u32(&mut self) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			        fn next_u64(&mut self) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
nextafter			        pub fn nextafter(x: c_double, y: c_double) -> c_double;
nextafterf			        pub fn nextafterf(x: c_float, y: c_float) -> c_float;
nlink			    fn nlink(&self) -> raw::nlink_t { self.as_raw_stat().st_nlink as raw::nlink_t }
nlink			    fn nlink(&self) -> raw::nlink_t;
no_match			    fn no_match() 
no_match_empty			    fn no_match_empty() 
no_match_empty_reversed			    fn no_match_empty_reversed() 
no_match_reversed			    fn no_match_reversed() 
no_runtime			    fn no_runtime() 
notify_all			    fn notify_all() 
notify_all			    pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }
notify_all			    pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }
notify_all			    pub unsafe fn notify_all(&self) { self.0.notify_all() }
notify_all			    pub unsafe fn notify_all(&self) 
notify_all			    pub unsafe fn notify_all(&self) 
notify_one			    fn notify_one() 
notify_one			    pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }
notify_one			    pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }
notify_one			    pub unsafe fn notify_one(&self) { self.0.notify_one() }
notify_one			    pub unsafe fn notify_one(&self) 
notify_one			    pub unsafe fn notify_one(&self) 
now			        pub fn now() -> Instant 
now			        pub fn now() -> SystemTime 
now			        pub fn now(clock: libc::c_int) -> Timespec 
now			    pub fn now() -> Instant 
now			    pub fn now() -> SystemTime 
now			    pub fn now() -> Instant 
now			    pub fn now() -> SystemTime 
ntoh			fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }
nul_position			    pub fn nul_position(&self) -> usize { self.0 }
null			    pub fn null() -> Stdio { Stdio(StdioImp::None) }
num			pub mod num;
objc_getClass			        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;
objc_msgSend			        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;
octets			    pub fn octets(&self) -> [u8; 4] 
offset			    unsafe fn offset(self, count: isize) -> RawBucket<K, V> 
on_panic			pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) 
once			mod once;
oneshot			mod oneshot;
oneshot_data_waiting			    fn oneshot_data_waiting() 
oneshot_multi_task_recv_then_close			    fn oneshot_multi_task_recv_then_close() 
oneshot_multi_task_recv_then_send			    fn oneshot_multi_task_recv_then_send() 
oneshot_multi_thread_close_stress			    fn oneshot_multi_thread_close_stress() 
oneshot_multi_thread_recv_close_stress			    fn oneshot_multi_thread_recv_close_stress() 
oneshot_multi_thread_send_close_stress			    fn oneshot_multi_thread_send_close_stress() 
oneshot_multi_thread_send_recv_stress			    fn oneshot_multi_thread_send_recv_stress() 
oneshot_single_thread_close_chan_first			    fn oneshot_single_thread_close_chan_first() 
oneshot_single_thread_close_port_first			    fn oneshot_single_thread_close_port_first() 
oneshot_single_thread_peek_close			    fn oneshot_single_thread_peek_close() 
oneshot_single_thread_peek_data			    fn oneshot_single_thread_peek_data() 
oneshot_single_thread_peek_open			    fn oneshot_single_thread_peek_open() 
oneshot_single_thread_recv_chan_close			    fn oneshot_single_thread_recv_chan_close() 
oneshot_single_thread_send_port_close			    fn oneshot_single_thread_send_port_close() 
oneshot_single_thread_send_then_recv			    fn oneshot_single_thread_send_then_recv() 
oneshot_single_thread_try_recv_closed			    fn oneshot_single_thread_try_recv_closed() 
oneshot_single_thread_try_recv_open			    fn oneshot_single_thread_try_recv_open() 
oneshot_single_thread_try_send_closed			    fn oneshot_single_thread_try_send_closed() 
oneshot_single_thread_try_send_closed2			    fn oneshot_single_thread_try_send_closed2() 
oneshot_single_thread_try_send_open			    fn oneshot_single_thread_try_send_open() 
oom_handler			fn oom_handler() -> ! 
oom_handler			fn oom_handler() -> ! 
open			    pub fn open(_filename: Option<&OsStr>) -> Result<*mut u8, String> 
open			    pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> 
open			    pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> 
open			    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> 
open			    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open_c			    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> 
open_external			    unsafe fn open_external(filename: &OsStr) -> *mut u8 
open_flavors			    fn open_flavors() 
open_internal			    unsafe fn open_internal() -> *mut u8 
open_reparse_point			    fn open_reparse_point(path: &Path, write: bool) -> io::Result<File> 
opendir			    fn opendir(p: &Path, write: bool) -> io::Result<File> 
ops			impl ops::Index<ops::Range<usize>> for Wtf8 
ops			impl ops::Index<ops::RangeFrom<usize>> for Wtf8 
ops			impl ops::Index<ops::RangeTo<usize>> for Wtf8 
ops::Deref for CString			impl ops::Deref for CString 
ops::Deref for OsString			impl ops::Deref for OsString 
ops::Deref for PathBuf			impl ops::Deref for PathBuf 
ops::Deref for Wtf8Buf			impl ops::Deref for Wtf8Buf 
ops::Index for CString			impl ops::Index<ops::RangeFull> for CString 
ops::Index for OsString			impl ops::Index<ops::RangeFull> for OsString 
ops::Index for Wtf8			impl ops::Index<ops::RangeFull> for Wtf8 
or_insert			    pub fn or_insert(self, default: V) -> &'a mut V 
or_insert_with			    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V 
ord			    fn ord() 
os			mod os 
os			pub mod os;
os			pub mod os;
os			pub mod os;
os			pub mod os;
os			pub mod os 
os2c			fn os2c(s: &OsStr) -> CString 
os2path			fn os2path(s: &[u16]) -> PathBuf 
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fdatasync(fd) }
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) }
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int 
os_str			mod os_str;
os_str			pub mod os_str;
os_str			pub mod os_str;
os_str_as_u8_slice			fn os_str_as_u8_slice(s: &OsStr) -> &[u8] 
os_str_len			        fn os_str_len(s: &OsStr) -> usize 
output			    pub fn output(&mut self) -> io::Result<Output> 
output			pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,
output_fileline			pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,
page_size			pub fn page_size() -> usize 
panic			pub mod panic;
panic			pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! 
panic			pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! 
panic			pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! 
panic_doesnt_poison			    fn panic_doesnt_poison() 
panicking			mod panicking;
panicking			pub fn panicking() -> bool 
panicking			pub fn panicking() -> bool 
parent			    pub fn parent(&self) -> Option<&Path> 
park			pub fn park() 
park_timeout			pub fn park_timeout(dur: Duration) 
park_timeout_ms			pub fn park_timeout_ms(ms: u32) 
parse			    fn parse(input: &[u8]) -> Option<(OsString, OsString)> 
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_next_component			    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) 
parse_next_component_back			    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) 
parse_prefix			    pub fn parse_prefix(_: &OsStr) -> Option<Prefix> 
parse_prefix			    pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> 
parse_single_component			    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> 
parse_two_comps			        fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> 
parser			mod parser;
partial_cmp			    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> 
partial_cmp			        fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> 
partial_read			    fn partial_read() 
path			        fn path<'a>(&'a self) -> &'a Path2 
path			    pub fn path(&self) -> PathBuf { self.0.path() }
path			pub mod path;
path			    pub fn path(&self) -> PathBuf 
path			    pub fn path(&self) -> PathBuf 
payload			    pub fn payload(&self) -> &(Any + Send) 
pcinfo_cb			    extern fn pcinfo_cb(data: *mut libc::c_void,
peek			    pub fn peek(self) -> BucketState<K, V, M> 
peek			    pub fn peek(&self) -> Option<Component<'a>> 
peek			    fn peek() 
peek			    pub fn peek(&self) -> Option<&mut T> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
perm			    pub fn perm(&self) -> FilePermissions 
perm			    pub fn perm(&self) -> FilePermissions 
permissions			    pub fn permissions(&self) -> Permissions 
pipe			pub mod pipe;
pipe			pub mod pipe;
piped			    pub fn piped() -> Stdio { Stdio(StdioImp::MakePipe) }
platform			mod platform 
poison			pub mod poison;
poison_works			    fn poison_works() 
pop			    pub fn pop(&mut self) -> bool 
pop			    pub fn pop(&self) -> PopResult<T> 
pop			    pub fn pop(&self) -> Option<T> 
pop_internal			fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) 
port			    pub fn port(&self) -> u16 { ntoh(self.inner.sin6_port) }
port			    pub fn port(&self) -> u16 { ntoh(self.inner.sin_port) }
port			    pub fn port(&self) -> u16 
port_gone_concurrent			    fn port_gone_concurrent() 
port_gone_concurrent_shared			    fn port_gone_concurrent_shared() 
position			    pub fn position(&self) -> u64 { self.pos }
postinit_lock			    pub fn postinit_lock(&self) -> MutexGuard<()> 
powf			    pub fn powf(self, n: f32) -> f32 
powf			    pub fn powf(self, n: f64) -> f64 
powi			    pub fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }
powi			    pub fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }
prefix			    pub fn prefix(&self) -> Option<Prefix> 
prefix_len			    fn prefix_len(&self) -> usize 
prefix_remaining			    fn prefix_remaining(&self) -> usize 
prefix_verbatim			    fn prefix_verbatim(&self) -> bool 
preflight1			    fn preflight1() 
preflight2			    fn preflight2() 
preflight3			    fn preflight3() 
preflight4			    fn preflight4() 
preflight5			    fn preflight5() 
preflight6			    fn preflight6() 
preflight7			    fn preflight7() 
preflight8			    fn preflight8() 
preflight9			    fn preflight9() 
prelude			pub mod prelude;
prelude			pub mod prelude;
prelude			pub mod prelude 
prelude			pub mod prelude 
prepend_search_path			    pub fn prepend_search_path(path: &Path) 
prim_array			mod prim_array { }
prim_bool			mod prim_bool { }
prim_char			mod prim_char { }
prim_f32			mod prim_f32 { }
prim_f64			mod prim_f64 { }
prim_i16			mod prim_i16 { }
prim_i32			mod prim_i32 { }
prim_i64			mod prim_i64 { }
prim_i8			mod prim_i8 { }
prim_isize			mod prim_isize { }
prim_pointer			mod prim_pointer { }
prim_slice			mod prim_slice { }
prim_str			mod prim_str { }
prim_tuple			mod prim_tuple { }
prim_u16			mod prim_u16 { }
prim_u32			mod prim_u32 { }
prim_u64			mod prim_u64 { }
prim_u8			mod prim_u8 { }
prim_unit			mod prim_unit { }
prim_usize			mod prim_usize { }
print			pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,
print			pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,
print			pub fn print(w: &mut Write, i: isize, addr: u64, _: &DynamicLibrary, _: c::HANDLE)
print			pub fn print(w: &mut Write, i: isize, addr: u64, dbghelp: &DynamicLibrary,
printing			mod printing;
printing			mod printing;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
propagate			pub fn propagate(payload: Box<Any + Send>) -> ! 
push			    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) 
push			    pub fn push<P: AsRef<Path>>(&mut self, path: P) 
push			    pub fn push(&self, t: T) 
push			    pub fn push(&self, t: T) 
push			pub fn push(f: Box<FnBox()>) -> bool 
push			    pub fn push(&mut self, code_point: CodePoint) 
push_char			    pub fn push_char(&mut self, c: char) 
push_code_point_unchecked			    fn push_code_point_unchecked(&mut self, code_point: CodePoint) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_str			    pub fn push_str(&mut self, other: &str) 
push_wtf8			    pub fn push_wtf8(&mut self, other: &Wtf8) 
put			    pub fn put(mut self, hash: SafeHash, key: K, value: V)
rand			mod rand;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }
raw			pub mod raw;
raw			    pub fn raw(&self) -> c_int { self.fd }
raw			pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t 
raw			    pub fn raw(&self) -> libc::c_int { self.0.raw() }
raw			pub mod raw;
raw			    pub fn raw(&self) -> c::HANDLE { self.0 }
raw			pub unsafe fn raw(m: &Mutex) -> c::PSRWLOCK 
raw			    pub fn raw(&self) -> c::HANDLE { self.inner.raw() }
raw_buckets			    fn raw_buckets(&self) -> RawBuckets<K, V> 
raw_os_error			    pub fn raw_os_error(&self) -> Option<i32> 
rdev			    fn rdev(&self) -> raw::dev_t { self.as_raw_stat().st_rdev as raw::dev_t }
rdev			    fn rdev(&self) -> raw::dev_t;
read			    pub fn read(&self) -> (&K, &V) 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) -> &mut OpenOptions 
read			            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }
read			        fn read<R>(mut input: R) -> JoinHandle<io::Result<Vec<u8>>>
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> 
read			    pub fn read(&self) -> LockResult<RwLockReadGuard<T>> 
read			    pub unsafe fn read<T:Copy>(&mut self) -> T 
read			        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) { self.0.read() }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) { self.read = read; }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read_atomically			    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where
read_char			    fn read_char(&mut self) -> Option<char> 
read_char_buffered			    fn read_char_buffered() 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_dir			pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> 
read_dir			    pub fn read_dir(&self) -> io::Result<fs::ReadDir> 
read_dir_not_found			    fn read_dir_not_found() 
read_encoded_pointer			unsafe fn read_encoded_pointer(reader: &mut DwarfReader,
read_eof			    fn read_eof() 
read_exact			    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> 
read_exact			    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> 
read_exact			    fn read_exact() 
read_exact			    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> 
read_exact_slice			    fn read_exact_slice() 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize)
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> 
read_line			    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> 
read_line			    fn read_line(&mut self, buf: &mut String) -> Result<usize> 
read_line			    fn read_line() 
read_line			    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> 
read_link			pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> 
read_link			    pub fn read_link(&self) -> io::Result<PathBuf> 
read_mut			    pub fn read_mut(&mut self) -> (&mut K, &mut V) 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_or			    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T> + 'static>])
read_seq_3			    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,
read_sleb128			    pub unsafe fn read_sleb128(&mut self) -> i64 
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_socket_addr_v4			    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> 
read_socket_addr_v6			    fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> 
read_till_eof			    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> 
read_to_end			    fn read_to_end() 
read_to_end			fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end_uninit_error			    fn read_to_end_uninit_error() 
read_to_end_uninit_good			    fn read_to_end_uninit_good() 
read_to_end_uninit_zero_len_vec			    fn read_to_end_uninit_zero_len_vec() 
read_to_end_uninitialized			pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> 
read_to_string			    fn read_to_string() 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> 
read_uleb128			    pub unsafe fn read_uleb128(&mut self) -> u64 
read_unlock			    pub unsafe fn read_unlock(&self) { self.0.read_unlock() }
read_unlock			    pub unsafe fn read_unlock(&self) 
read_unlock			    pub unsafe fn read_unlock(&self) 
read_until			    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> 
read_until			    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> 
read_until			    fn read_until() 
read_until			fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
reader			pub mod reader;
readlink			pub fn readlink(p: &Path) -> io::Result<PathBuf> 
readlink			    fn readlink(&self) -> io::Result<PathBuf> 
readlink			pub fn readlink(p: &Path) -> io::Result<PathBuf> 
readlink_not_symlink			    fn readlink_not_symlink() 
readonly			    pub fn readonly(&self) -> bool { self.0.readonly() }
readonly			    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }
readonly			    pub fn readonly(&self) -> bool 
realpath_works			    fn realpath_works() 
realpath_works_tricky			    fn realpath_works_tricky() 
recip			    pub fn recip(self) -> f32 { num::Float::recip(self) }
recip			    pub fn recip(self) -> f64 { num::Float::recip(self) }
recover			pub fn recover<F: FnOnce() -> R + RecoverSafe, R>(f: F) -> Result<R> 
recursive			    pub fn recursive(&mut self, recursive: bool) -> &mut Self 
recursive_mkdir			    fn recursive_mkdir() 
recursive_mkdir_failure			    fn recursive_mkdir_failure() 
recursive_mkdir_slash			    fn recursive_mkdir_slash() 
recursive_rmdir			    fn recursive_rmdir() 
recv			            fn recv(rx: Receiver<Box<i32>>, i: i32) 
recv			    pub fn recv(&self) -> Result<T, RecvError> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }
recv			    pub fn recv(&mut self) -> Result<T, Failure> 
recv			    pub fn recv(&mut self) -> Result<T, Failure<T>> 
recv			    pub fn recv(&self) -> Result<T, ()> 
recv			    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,
recv_a_lot			    fn recv_a_lot() 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from_outside_runtime			    fn recv_from_outside_runtime() 
recvfrom			    pub fn recvfrom(socket: SOCKET,
refcell_vec			    fn refcell_vec() 
reference_tls_used			    unsafe fn reference_tls_used() 
reference_tls_used			    unsafe fn reference_tls_used() {}
register_dtor			unsafe fn register_dtor(key: Key, dtor: Dtor) 
register_dtor			        unsafe fn register_dtor(&self) 
register_dtor			    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) 
relative_from			    pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path> 
release			    pub fn release(&self) 
remove			    pub fn remove(self) -> V 
remove			    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
remove			    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
remove			    pub unsafe fn remove(&mut self) 
remove_dir			pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> 
remove_dir_all			pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> 
remove_file			pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> 
remove_var			pub fn remove_var<K: AsRef<OsStr>>(k: K) 
remutex			pub mod remutex;
remutex			    unsafe fn remutex(&self) -> *mut ReentrantMutex 
rename			pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> 
rename			pub fn rename(old: &Path, new: &Path) -> io::Result<()> 
rename			pub fn rename(old: &Path, new: &Path) -> io::Result<()> 
reparse_point			    fn reparse_point<'a>(&self,
repeat			pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }
repeat_byte			    fn repeat_byte(b: u8) -> usize 
repeat_repeats			    fn repeat_repeats() 
replace			    fn replace(&mut self, key: K) -> Option<K> 
replace			    fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;
replace			    pub fn replace(&mut self, value: T) -> Option<T> 
replace			    pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) 
report_overflow			pub unsafe fn report_overflow() 
repro			        fn repro() 
reseed			    fn reseed(&mut self, rng: &mut StdRng) 
reseed			    fn reseed(&mut self, seed: &'a [usize]) 
reseeding::Reseeder for ThreadRngReseeder			impl reseeding::Reseeder<StdRng> for ThreadRngReseeder 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reset_signal_handling			        unsafe fn reset_signal_handling(_output: &mut AnonPipe) 
reset_signal_handling			        unsafe fn reset_signal_handling(output: &mut AnonPipe) 
resize			    fn resize(&mut self, new_capacity: usize) 
resolve_socket_addr			fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> 
rev_move_buckets			    unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
robin_hood			fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,
round			    pub fn round(self) -> f32 
round			    pub fn round(self) -> f64 
round_up			fn round_up(unrounded: usize, align: usize) -> usize 
round_up_to_next			fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize 
rt			pub mod rt;
rtdeps			mod rtdeps;
run_dtors			unsafe fn run_dtors() 
run_output			    pub fn run_output(mut cmd: Command) -> String 
rust_begin_unwind			pub extern fn rust_begin_unwind(msg: fmt::Arguments,
rust_eh_personality			    extern fn rust_eh_personality(
rust_eh_personality			    pub extern fn rust_eh_personality(
rust_eh_personality			fn rust_eh_personality() 
rust_eh_personality_catch			    pub extern fn rust_eh_personality_catch(
rust_exception_class			fn rust_exception_class() -> uw::_Unwind_Exception_Class 
rust_panic			pub fn rust_panic(cause: Box<Any + Send + 'static>) -> ! 
rust_try			        fn rust_try(f: extern fn(*mut u8),
rwlock			mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
sa4			pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr 
sa6			pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr 
same			    fn same() 
scope_id			    pub fn scope_id(&self) -> u32 { ntoh(self.inner.sin6_scope_id) }
scope_item_allowed			    fn scope_item_allowed() 
search			    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>
search_entry_hashed			fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)
search_hashed			fn search_hashed<K, V, M, F>(table: M,
search_mut			    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>
search_path			    pub fn search_path() -> Vec<PathBuf> 
second			        fn second<A, B>((_, b): (A, B)) -> B { b }
secs			    fn secs() 
security_attributes			    pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			            fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, style: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }
seek			    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek_before_0			    fn seek_before_0() 
seek_past_end			    fn seek_past_end() 
segments			    pub fn segments(&self) -> [u16; 8] 
sel_registerName			        fn sel_registerName(name: *const libc::c_uchar) -> Sel;
select			mod select;
select::Packet for Receiver			impl<T> select::Packet for Receiver<T> 
self_referential			    fn self_referential() 
semaphore			mod semaphore;
send			            fn send(tx: Sender<Box<i32>>, i: i32) 
send			            fn send(tx: SyncSender<Box<i32>>, i: i32) 
send			    pub fn send(&self, t: T) -> Result<(), SendError<T>> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&mut self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int,
send1			    fn send1() 
send2			    fn send2() 
send3			    fn send3() 
send4			    fn send4() 
send_from_outside_runtime			    fn send_from_outside_runtime() 
send_to			    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)
send_to			    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> 
sendto			    pub fn sendto(socket: SOCKET,
sent			    pub fn sent(&self) -> bool 
separator			    fn separator() -> &'static str 
session_leader			    fn session_leader(&mut self, on: bool) -> &mut process::Command 
session_leader			    fn session_leader(&mut self, on: bool) -> &mut process::Command;
set			pub mod set;
set			pub fn set(stack_guard: Option<usize>, thread: Thread) 
set			    pub fn set(&self, val: *mut u8) 
set			    pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }
set			        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr); }
set			    pub fn set<R, F>(&'static self, t: &T, cb: F) -> R where
set_cloexec			    pub fn set_cloexec(&self) 
set_current_dir			pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> 
set_current_dir_works			    fn set_current_dir_works() 
set_extension			    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool 
set_file_name			    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) 
set_handler			pub fn set_handler<F>(handler: F) where F: Fn(&PanicInfo) + 'static + Sync + Send 
set_len			    pub fn set_len(&self, size: u64) -> io::Result<()> 
set_mode			    fn set_mode(&mut self, mode: raw::mode_t) 
set_mode			    fn set_mode(&mut self, mode: raw::mode_t);
set_mode			    pub fn set_mode(&mut self, mode: mode_t) 
set_name			    pub fn set_name(name: &str) 
set_name			    pub unsafe fn set_name(_name: &str) 
set_name			    pub fn set_name(_name: &str) 
set_no_inherit			    fn set_no_inherit(&self) -> io::Result<()> 
set_panic			pub fn set_panic(sink: Box<Write + Send>) -> Option<Box<Write + Send>> 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_permissions			pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions)
set_position			    pub fn set_position(&mut self, pos: u64) { self.pos = pos; }
set_print			pub fn set_print(sink: Box<Write + Send>) -> Option<Box<Write + Send>> 
set_read_timeout			    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_timeout			    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> 
set_timeout			    pub fn set_timeout(&self, dur: Option<Duration>,
set_var			pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) 
set_write_timeout			    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
setenv			pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> 
setenv			pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> 
setsockopt			pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,
setsockopt			    pub fn setsockopt(s: SOCKET,
setup_io			fn setup_io(io: &Stdio, readable: bool)
share_mode			    fn share_mode(&mut self, access: u32) -> &mut OpenOptions 
share_mode			    fn share_mode(&mut self, val: u32) -> &mut Self;
share_mode			    pub fn share_mode(&mut self, val: u32) 
shared			mod shared;
shared_chan_stress			    fn shared_chan_stress() 
shared_data_waiting			    fn shared_data_waiting() 
shift			    pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> 
shims			    mod shims 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown_smoke			    fn shutdown_smoke() 
sigaddset			        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;
sigaddset			    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int 
siginfo_si_addr			    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize 
siginfo_t			        struct siginfo_t 
signal			    pub fn signal(&self) -> bool 
signal			    fn signal(&self) -> Option<i32> 
signal			    fn signal(&self) -> Option<i32>;
signal			    pub fn signal(&self) -> Option<i32> 
signal_reported_right			    fn signal_reported_right() 
signum			    pub fn signum(self) -> f32 { num::Float::signum(self) }
signum			    pub fn signum(self) -> f64 { num::Float::signum(self) }
simple			    fn simple() 
sin			    pub fn sin(self) -> f32 
sin			    pub fn sin(self) -> f64 
sin_cos			    pub fn sin_cos(self) -> (f32, f32) 
sin_cos			    pub fn sin_cos(self) -> (f64, f64) 
since_epoch			    fn since_epoch() 
sinh			    pub fn sinh(self) -> f32 
sinh			        pub fn sinh(n: c_double) -> c_double;
sinh			    pub fn sinh(self) -> f64 
sinhf			        pub fn sinhf(n: c_float) -> c_float;
sinhf			        pub unsafe fn sinhf(n: c_float) -> c_float 
sink			pub fn sink() -> Sink { Sink { _priv: () } }
sink_sinks			    fn sink_sinks() 
size			    pub fn size(&self) -> usize 
size			    fn size(&self) -> usize { self.size }
size			    fn size(&self) -> raw::off_t { self.as_raw_stat().st_size as raw::off_t }
size			    fn size(&self) -> raw::off_t;
size			    pub fn size(&self) -> u64 { self.stat.st_size as u64 }
size			    pub fn size(&self) -> u64 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }
sleep			    pub fn sleep(dur: Duration) 
sleep			    pub fn sleep(dur: Duration) 
sleep			pub fn sleep(dur: Duration) 
sleep_ms			pub fn sleep_ms(ms: u32) 
sleep_ms_smoke			    fn sleep_ms_smoke() 
slice_error_fail			pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! 
slice_unchecked			pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke2			    fn smoke2() 
smoke_bound			    fn smoke_bound() 
smoke_chan_gone			    fn smoke_chan_gone() 
smoke_chan_gone_shared			    fn smoke_chan_gone_shared() 
smoke_dtor			    fn smoke_dtor() 
smoke_failure			    fn smoke_failure() 
smoke_no_dtor			    fn smoke_no_dtor() 
smoke_once			    fn smoke_once() 
smoke_port_gone			    fn smoke_port_gone() 
smoke_shared			    fn smoke_shared() 
smoke_shared_port_gone			    fn smoke_shared_port_gone() 
smoke_shared_port_gone2			    fn smoke_shared_port_gone2() 
smoke_static			    fn smoke_static() 
smoke_test			    fn smoke_test() 
smoke_threads			    fn smoke_threads() 
sockaddr_in			pub struct sockaddr_in 
sockaddr_in6			pub struct sockaddr_in6 
sockaddr_to_addr			fn sockaddr_to_addr(storage: &c::sockaddr_storage,
socket			    pub fn socket(&self) -> &Socket { &self.inner }
socket_addr			    pub fn socket_addr(&self) -> io::Result<SocketAddr> 
socket_and_peer_name			    fn socket_and_peer_name() 
socket_name_ip4			    fn socket_name_ip4() 
socket_smoke_test_ip4			    fn socket_smoke_test_ip4() 
sockname			fn sockname<F>(f: F) -> io::Result<SocketAddr>
soft_link			pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> 
span			    pub fn span<F>(f: F) -> Duration where F: FnOnce() 
spawn			    pub fn spawn(&mut self) -> io::Result<Child> 
spawn			    pub fn spawn(cfg: &Command,
spawn			    pub fn spawn(cfg: &Command,
spawn			    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where
spawn			pub fn spawn<F, T>(f: F) -> JoinHandle<T> where
spawn_inner			    fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> 
split			    fn split() 
split			    fn split(self, byte: u8) -> Split<Self> where Self: Sized 
split_file_at_dot			fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) 
split_paths			pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths 
split_paths			pub fn split_paths(unparsed: &OsStr) -> SplitPaths 
split_paths			pub fn split_paths(unparsed: &OsStr) -> SplitPaths 
split_paths_unix			    fn split_paths_unix() 
split_paths_windows			    fn split_paths_windows() 
spsc_queue			mod spsc_queue;
sqrt			    pub fn sqrt(self) -> f32 
sqrt			    pub fn sqrt(self) -> f64 
square			        fn square(i: i32) -> i32 { i * i }
stack_guard			pub fn stack_guard() -> Option<usize> 
stack_overflow			pub mod stack_overflow;
stack_overflow			pub mod stack_overflow;
stack_size			    pub fn stack_size(mut self, size: usize) -> Builder 
stampede_once			    fn stampede_once() 
start_selection			    fn start_selection(&self, mut token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> 
start_selection			    fn start_selection(&self, token: SignalToken) -> StartResult;
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> 
start_selection			    pub fn start_selection(&self, token: SignalToken) -> StartResult 
start_thread			pub unsafe fn start_thread(main: *mut libc::c_void) 
starts_with			    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool 
stat			    pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			    pub struct stat 
stat			pub struct stat 
stat			    pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub fn stat(p: &Path) -> io::Result<FileAttr> 
stat			pub fn stat(p: &Path) -> io::Result<FileAttr> 
state			pub mod state;
state			    pub fn state(&'static self) -> LocalKeyState 
states			    fn states() 
static_smoke			    fn static_smoke() 
static_smoke			    fn static_smoke() 
statik			    fn statik() 
status			    pub fn status(&mut self) -> io::Result<ExitStatus> 
status_imp			mod status_imp 
std_error::Error for CharsError			impl std_error::Error for CharsError 
stderr			pub fn stderr() -> Stderr 
stderr			    pub fn stderr(&mut self, cfg: Stdio) -> &mut Command 
stderr_init			    fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> 
stderr_raw			fn stderr_raw() -> io::Result<StderrRaw> { stdio::Stderr::new().map(StderrRaw) }
stdin			pub fn stdin() -> Stdin 
stdin			    pub fn stdin(&mut self, cfg: Stdio) -> &mut Command 
stdin_init			    fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> 
stdin_raw			fn stdin_raw() -> io::Result<StdinRaw> { stdio::Stdin::new().map(StdinRaw) }
stdin_works			    fn stdin_works() 
stdio			mod stdio;
stdio			pub mod stdio;
stdio			pub mod stdio;
stdout			pub fn stdout() -> Stdout 
stdout			    pub fn stdout(&mut self, cfg: Stdio) -> &mut Command 
stdout_init			    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> 
stdout_raw			fn stdout_raw() -> io::Result<StdoutRaw> { stdio::Stdout::new().map(StdoutRaw) }
stdout_works			    fn stdout_works() 
store_func			pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,
stream			mod stream;
stream_data_waiting			    fn stream_data_waiting() 
stream_send_recv_stress			    fn stream_send_recv_stress() 
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char,
stress			    fn stress() 
stress			    fn stress() 
stress			    fn stress() 
stress_bound			        unsafe fn stress_bound(bound: usize) 
stress_factor			    pub fn stress_factor() -> usize 
stress_shared			    fn stress_shared() 
strip_prefix			    pub fn strip_prefix<'a, P: ?Sized>(&'a self, base: &'a P)
sub			    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
sub			    fn sub() 
sub			    fn sub(self, rhs: Duration) -> Duration 
sub			    fn sub(self, dur: Duration) -> SystemTime 
sub			    fn sub(self, other: Duration) -> Instant 
sub_bad1			    fn sub_bad1() 
sub_bad2			    fn sub_bad2() 
sub_duration			        fn sub_duration(&self, other: &Duration) -> Timespec 
sub_duration			        pub fn sub_duration(&self, other: &Duration) -> Instant 
sub_duration			        pub fn sub_duration(&self, other: &Duration) -> SystemTime 
sub_duration			    pub fn sub_duration(&self, other: &Duration) -> Instant 
sub_duration			    pub fn sub_duration(&self, other: &Duration) -> SystemTime 
sub_instant			        pub fn sub_instant(&self, other: &Instant) -> Duration 
sub_instant			    pub fn sub_instant(&self, other: &Instant) -> Duration 
sub_time			        pub fn sub_time(&self, other: &SystemTime)
sub_time			    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> 
sub_timespec			        fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> 
subsec_nanos			    pub fn subsec_nanos(&self) -> u32 { self.nanos }
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
super::Recover for HashMap			impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>
symbol			    pub unsafe fn symbol(_handle: *mut u8, _symbol: *const libc::c_char) -> *mut u8 
symbol			    pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 
symbol			    pub unsafe fn symbol(handle: *mut u8,
symbol			    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> 
syminfo_cb			    extern fn syminfo_cb(data: *mut libc::c_void,
symlink			pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>
symlink			pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> 
symlink_dir			pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)
symlink_file			pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)
symlink_inner			pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> 
symlink_metadata			pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> 
symlink_metadata			    pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> 
symlink_noexist			    fn symlink_noexist() 
symlinks_work			    fn symlinks_work() 
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)
sync			pub mod sync;
sync			mod sync;
sync1			    fn sync1() 
sync2			    fn sync2() 
sync3			    fn sync3() 
sync_all			    pub fn sync_all(&self) -> io::Result<()> 
sync_channel			pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) 
sync_data			    pub fn sync_data(&self) -> io::Result<()> 
sync_doesnt_kill_anything			    fn sync_doesnt_kill_anything() 
sync_tests			mod sync_tests 
system_time_elapsed			    fn system_time_elapsed() 
system_time_math			    fn system_time_math() 
table			mod table;
table			    pub fn table(&self) -> &M 
take			    fn take(&mut self, key: &Q) -> Option<K> 
take			    fn take(&mut self, key: &Q) -> Option<Self::Key>;
take			    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>
take			    pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) 
take			    fn take(self, limit: u64) -> Take<Self> where Self: Sized 
take_eof			    fn take_eof() 
take_handler			pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> 
take_some_bytes			    fn take_some_bytes() 
take_to_wake			    fn take_to_wake(&mut self) -> SignalToken 
take_to_wake			    fn take_to_wake(&mut self) -> SignalToken 
tan			    pub fn tan(self) -> f32 
tan			        pub fn tan(n: c_double) -> c_double;
tan			    pub fn tan(self) -> f64 
tanf			        pub fn tanf(n: c_float) -> c_float;
tanf			        pub unsafe fn tanf(n: c_float) -> c_float 
tanh			    pub fn tanh(self) -> f32 
tanh			        pub fn tanh(n: c_double) -> c_double;
tanh			    pub fn tanh(self) -> f64 
tanhf			        pub fn tanhf(n: c_float) -> c_float;
tanhf			        pub unsafe fn tanhf(n: c_float) -> c_float 
tcp			mod tcp;
tcp_clone_smoke			    fn tcp_clone_smoke() 
tcp_clone_two_read			    fn tcp_clone_two_read() 
tcp_clone_two_write			    fn tcp_clone_two_write() 
tee			    fn tee<W: Write>(self, out: W) -> Tee<Self, W> where Self: Sized 
tee			    fn tee() 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
test			    fn test() 
test			mod test 
test			    fn test() 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tgamma			        pub fn tgamma(n: c_double) -> c_double;
tgammaf			        pub fn tgammaf(n: c_float) -> c_float;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			    pub fn thread(&self) -> &Thread 
thread_info			pub mod thread_info;
thread_info::NewThread for Thread			impl thread_info::NewThread for Thread 
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_rng			pub fn thread_rng() -> ThreadRng 
thread_start			        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void 
thread_start			        extern "system" fn thread_start(main: *mut c_void) -> c::DWORD 
time			pub mod time;
time			pub mod time;
time			pub mod time;
timed_out			    pub fn timed_out(&self) -> bool 
timeout			    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> 
timeout			    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> 
timeouts			    fn timeouts() 
timeouts			    fn timeouts() 
tmpdir			    pub fn tmpdir() -> TempDir 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Self::Owned;
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> String 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Vec<u8> 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> char 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> u8 { ASCII_LOWERCASE_MAP[*self as usize] }
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Wtf8Buf 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Self::Owned;
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> String 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Vec<u8> 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> char 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> u8 { ASCII_UPPERCASE_MAP[*self as usize] }
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Wtf8Buf 
to_be			        fn to_be(&self) -> Self { <
to_be			    fn to_be(&self) -> Self;
to_bytes			    pub fn to_bytes(&self) -> &[u8] 
to_bytes			    pub fn to_bytes(&self) -> Option<&[u8]> 
to_bytes_with_nul			    pub fn to_bytes_with_nul(&self) -> &[u8] 
to_char			    pub fn to_char(&self) -> Option<char> 
to_char_lossy			    pub fn to_char_lossy(&self) -> char 
to_cstring			    pub fn to_cstring(&self) -> Option<CString> 
to_degrees			    pub fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }
to_degrees			    pub fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }
to_handle			    fn to_handle(&self, stdio_id: c::DWORD) -> io::Result<Handle> 
to_ipv4			    pub fn to_ipv4(&self) -> Option<Ipv4Addr> 
to_ipv6_compatible			    pub fn to_ipv6_compatible(&self) -> Ipv6Addr 
to_ipv6_mapped			    pub fn to_ipv6_mapped(&self) -> Ipv6Addr 
to_os_string			    pub fn to_os_string(&self) -> OsString 
to_owned			    fn to_owned(&self) -> CString 
to_owned			    fn to_owned() 
to_owned			    fn to_owned(&self) -> OsString { self.to_os_string() }
to_owned			    fn to_owned(&self) -> PathBuf 
to_owned			    pub fn to_owned(&self) -> Buf 
to_owned			    pub fn to_owned(&self) -> Buf 
to_path_buf			    pub fn to_path_buf(&self) -> PathBuf 
to_radians			    pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }
to_radians			    pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }
to_socket_addr_ipaddr_u16			    fn to_socket_addr_ipaddr_u16() 
to_socket_addr_socketaddr			    fn to_socket_addr_socketaddr() 
to_socket_addr_str			    fn to_socket_addr_str() 
to_socket_addr_str_bad			    fn to_socket_addr_str_bad() 
to_socket_addr_str_u16			    fn to_socket_addr_str_u16() 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<T::Iter> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> 
to_str			    fn to_str() 
to_str			    pub fn to_str(&self) -> Result<&str, str::Utf8Error> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_u16s			pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> 
to_u32			    pub fn to_u32(&self) -> u32 
to_u64			    fn to_u64(&self, ft: &c::FILETIME) -> u64 
tokens			pub fn tokens() -> (WaitToken, SignalToken) 
trace_fn			    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,
tracing			mod tracing;
trim_left			    fn trim_left(&mut self) 
trim_right			    fn trim_right(&mut self) 
trunc			    pub fn trunc(self) -> f32 
trunc			    pub fn trunc(self) -> f64 
truncate			    pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions 
truncate			    pub fn truncate(&mut self, new_len: usize) 
truncate			    pub fn truncate(&mut self, truncate: bool) 
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate			    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate_utf16_at_nul			pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] 
truncate_works			    fn truncate_works() 
try			pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> 
try_clone			    pub fn try_clone(&self) -> io::Result<TcpListener> 
try_clone			    pub fn try_clone(&self) -> io::Result<TcpStream> 
try_clone			    pub fn try_clone(&self) -> io::Result<UdpSocket> 
try_fn			    fn try_fn<F: FnOnce()>(opt_closure: *mut u8) 
try_lock			    fn try_lock() 
try_lock			    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> 
try_lock			    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> 
try_lock			    pub unsafe fn try_lock(&self) -> bool { self.0.try_lock() }
try_lock			    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<T>> 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_read			    pub fn try_read(&'static self)
try_read			    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> 
try_read			    pub unsafe fn try_read(&self) -> bool { self.0.try_read() }
try_read			    pub unsafe fn try_read(&self) -> bool 
try_read			    pub unsafe fn try_read(&self) -> bool 
try_recv			    pub fn try_recv(&self) -> Result<T, TryRecvError> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure> 
try_recv			    pub fn try_recv(&mut self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_recv_states			    fn try_recv_states() 
try_send			    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> 
try_send			    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> 
try_send1			    fn try_send1() 
try_send2			    fn try_send2() 
try_send3			    fn try_send3() 
try_wait			    pub fn try_wait(&self) -> Option<ExitStatus> 
try_write			    pub fn try_write(&'static self)
try_write			    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> 
try_write			    pub unsafe fn try_write(&self) -> bool { self.0.try_write() }
try_write			    pub unsafe fn try_write(&self) -> bool 
try_write			    pub unsafe fn try_write(&self) -> bool 
trylock_works			    fn trylock_works() 
tsa			pub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> 
two_mutexes			    fn two_mutexes() 
type_id			    fn type_id(&self) -> TypeId where Self: 'static 
u64x2			struct u64x2(u64, u64);
u8_slice_as_os_str			unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr 
udp			mod udp;
udp_clone_smoke			    fn udp_clone_smoke() 
udp_clone_two_read			    fn udp_clone_two_read() 
udp_clone_two_write			    fn udp_clone_two_write() 
uid			    fn uid(&self) -> raw::uid_t { self.as_raw_stat().st_uid as raw::uid_t }
uid			    fn uid(&self) -> raw::uid_t;
uid			    fn uid(&mut self, id: uid_t) -> &mut process::Command 
uid			    fn uid(&mut self, id: uid_t) -> &mut process::Command;
uid_to_root_fails			    fn uid_to_root_fails() 
uid_works			    fn uid_works() 
unblocks			    fn unblocks() 
unicode_path_exists			    fn unicode_path_exists() 
unicode_path_is_dir			    fn unicode_path_is_dir() 
uninitialized			    pub unsafe fn uninitialized() -> ReentrantMutex 
uninitialized			    pub unsafe fn uninitialized() -> ReentrantMutex 
union			    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> 
unix			    fn unix() 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink_readonly			    fn unlink_readonly() 
unlock			    pub unsafe fn unlock(&self) { self.0.unlock() }
unlock			    pub unsafe fn unlock(&self) 
unlock			    pub unsafe fn unlock(&self) 
unpark			    pub fn unpark(&self) 
unregister_dtor			unsafe fn unregister_dtor(key: Key) -> bool 
unsetenv			pub fn unsetenv(n: &OsStr) -> io::Result<()> 
unsetenv			pub fn unsetenv(n: &OsStr) -> io::Result<()> 
unwind			pub mod unwind;
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult 
usable_capacity			    fn usable_capacity(&self, cap: usize) -> usize 
utf8_error			    pub fn utf8_error(&self) -> Utf8Error 
util			mod util;
util			pub mod util;
uw			mod uw 
v1			pub mod v1;
validate			    fn validate(buf: &Vec<u8>, good_read_len: usize) 
values			    pub fn values<'a>(&'a self) -> Values<'a, K, V> 
var			pub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> 
var_os			pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> 
vars			pub fn vars() -> Vars 
vars_os			pub fn vars_os() -> VarsOs 
vec_seek_before_0			    fn vec_seek_before_0() 
vec_seek_past_end			    fn vec_seek_past_end() 
vectored_handler			extern "system" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS)
verify			    fn verify(&self, mutex: &sys_mutex::Mutex) 
w			        fn w(v: &[u8]) -> &Wtf8 { unsafe { Wtf8::from_bytes_unchecked(v) } }
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub fn wait(&self) -> BarrierWaitResult 
wait			    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)
wait			    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)
wait			    pub fn wait(self) 
wait			    pub fn wait(&self) -> usize 
wait			fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,
wait			    pub unsafe fn wait(&self, mutex: &Mutex) { self.0.wait(mutex::raw(mutex)) }
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&self) -> io::Result<ExitStatus> 
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&self) -> io::Result<ExitStatus> 
wait2			    fn wait2(&self, do_preflight_checks: bool) -> usize 
wait_timeout			    pub fn wait_timeout<'a, T>(&'static self,
wait_timeout			    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout_ms			    fn wait_timeout_ms() 
wait_timeout_ms			    pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)
wait_timeout_ms			    pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)
wait_timeout_with			    fn wait_timeout_with() 
wait_timeout_with			    pub fn wait_timeout_with<'a, T, F>(&'static self,
wait_timeout_with			    pub fn wait_timeout_with<'a, T, F>(&self,
wait_with_output			    pub fn wait_with_output(mut self) -> io::Result<Output> 
wakeup			fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) 
wakeup_senders			    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<State<T>>) 
walk_dir			pub fn walk_dir<P: AsRef<Path>>(path: P) -> io::Result<WalkDir> 
windows			    fn windows() 
with			    fn with<R, F>(f: F) -> Option<R> where F: FnOnce(&mut ThreadInfo) -> R 
with			    pub fn with<F, R>(&'static self, f: F) -> R
with			    pub fn with<R, F>(&'static self, cb: F) -> R where
with_capacity			    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> 
with_capacity			    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> 
with_capacity			    pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> 
with_capacity			    pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> 
with_capacity			    pub fn with_capacity(cap: usize, inner: W) -> LineWriter<W> 
with_capacity			    pub fn with_capacity(n: usize) -> Wtf8Buf 
with_capacity_and_hash_state			    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)
with_capacity_and_hash_state			    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S)
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: usize, hasher: S)
with_extension			    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf 
with_file_name			    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf 
with_hash_state			    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> 
with_hash_state			    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> 
with_hasher			    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> 
with_hasher			    pub fn with_hasher(hasher: S) -> HashSet<T, S> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, write: bool) -> &mut OpenOptions 
write			            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> Result<usize>;
write			    fn write(&mut self, data: &[u8]) -> Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> 
write			    pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) { self.0.write() }
write			pub fn write(w: &mut Write) -> io::Result<()> 
write			pub fn write(w: &mut Write) -> io::Result<()> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, write: bool) 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, data: &[u8]) -> io::Result<usize> 
write			pub fn write(w: &mut Write) -> io::Result<()> 
write			    pub fn write(&mut self, write: bool) { self.write = write; }
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, data: &[u8]) -> io::Result<usize> 
write			fn write(out: &Output, data: &[u8]) -> io::Result<usize> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> 
write_all			    fn write_all(&mut self, data: &[u8]) -> io::Result<()> 
write_all			    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> 
write_close			    fn write_close() 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> 
write_fmt			    fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> 
write_str			            fn write_str(&mut self, s: &str) -> fmt::Result 
write_str_escaped			        fn write_str_escaped(f: &mut fmt::Formatter, s: &str) -> fmt::Result 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_unlock			    pub unsafe fn write_unlock(&self) { self.0.write_unlock() }
write_unlock			    pub unsafe fn write_unlock(&self) { self.read_unlock() }
write_unlock			    pub unsafe fn write_unlock(&self) 
wtf8			pub mod wtf8;
wtf8_as_str			    fn wtf8_as_str() 
wtf8_ascii_byte_at			    fn wtf8_ascii_byte_at() 
wtf8_code_points			    fn wtf8_code_points() 
wtf8_encode_wide			    fn wtf8_encode_wide() 
wtf8_from_str			    fn wtf8_from_str() 
wtf8_len			    fn wtf8_len() 
wtf8_slice			    fn wtf8_slice() 
wtf8_slice_from			    fn wtf8_slice_from() 
wtf8_slice_from_not_code_point_boundary			    fn wtf8_slice_from_not_code_point_boundary() 
wtf8_slice_not_code_point_boundary			    fn wtf8_slice_not_code_point_boundary() 
wtf8_slice_to			    fn wtf8_slice_to() 
wtf8_slice_to_not_code_point_boundary			    fn wtf8_slice_to_not_code_point_boundary() 
wtf8_to_string_lossy			    fn wtf8_to_string_lossy() 
wtf8buf_as_slice			    fn wtf8buf_as_slice() 
wtf8buf_extend			    fn wtf8buf_extend() 
wtf8buf_from_iterator			    fn wtf8buf_from_iterator() 
wtf8buf_from_str			    fn wtf8buf_from_str() 
wtf8buf_from_string			    fn wtf8buf_from_string() 
wtf8buf_from_wide			    fn wtf8buf_from_wide() 
wtf8buf_into_string			    fn wtf8buf_into_string() 
wtf8buf_into_string_lossy			    fn wtf8buf_into_string_lossy() 
wtf8buf_new			    fn wtf8buf_new() 
wtf8buf_push			    fn wtf8buf_push() 
wtf8buf_push_char			    fn wtf8buf_push_char() 
wtf8buf_push_str			    fn wtf8buf_push_str() 
wtf8buf_push_wtf8			    fn wtf8buf_push_wtf8() 
wtf8buf_show			    fn wtf8buf_show() 
wtf8buf_show_str			    fn wtf8buf_show_str() 
wtf8buf_truncate			    fn wtf8buf_truncate() 
wtf8buf_truncate_fail_code_point_boundary			    fn wtf8buf_truncate_fail_code_point_boundary() 
wtf8buf_truncate_fail_longer			    fn wtf8buf_truncate_fail_longer() 
y0			        pub fn y0(n: c_double) -> c_double;
y1			        pub fn y1(n: c_double) -> c_double;
yield_now			    pub fn yield_now() 
yield_now			    pub fn yield_now() 
yield_now			pub fn yield_now() 
yn			        pub fn yn(i: c_int, n: c_double) -> c_double;
zeroed_process_information			fn zeroed_process_information() -> c::PROCESS_INFORMATION 
zeroed_startupinfo			fn zeroed_startupinfo() -> c::STARTUPINFO 
