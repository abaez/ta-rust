::marker::Sync for Key			unsafe impl<T> ::marker::Sync for Key<T> { }
::marker::Sync for Key			unsafe impl<T> ::marker::Sync for Key<T> { }
::marker::Sync for Key			    unsafe impl<T> ::marker::Sync for Key<T> { }
A			    struct A;
ADDRESS64			pub struct ADDRESS64 
ADDRESS_MODE			pub enum ADDRESS_MODE 
ADDRINFOA			pub struct ADDRINFOA 
AcquireSRWLockExclusive			    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> () 
AcquireSRWLockShared			    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () 
Adaptor			        struct Adaptor<'a, T: ?Sized + 'a> 
Add for Duration			impl Add for Duration 
Add for Instant			impl Add<Duration> for Instant 
Add for SystemTime			impl Add<Duration> for SystemTime 
AddAssign for Duration			impl AddAssign for Duration 
AddAssign for Instant			impl AddAssign<Duration> for Instant 
AddAssign for SystemTime			impl AddAssign<Duration> for SystemTime 
AddVectoredExceptionHandler			    pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,
AddrParseError			pub struct AddrParseError(());
AddressKind			enum AddressKind<'a> 
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe(FileDesc);
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe(FileDesc);
AnonPipe			impl AnonPipe 
AnonPipe			pub struct AnonPipe 
Answer			    pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);
Args			pub struct Args { inner: ArgsOs }
Args			pub struct Args 
Args			pub struct Args 
Args			pub struct Args 
ArgsOs			pub struct ArgsOs { inner: sys::args::Args }
AsInner			pub trait AsInner<Inner: ?Sized> 
AsInner for Buf			impl AsInner<[u8]> for Buf 
AsInner for Buf			impl AsInner<[u8]> for Buf 
AsInner for Buf			impl AsInner<Wtf8> for Buf 
AsInner for Child			impl AsInner<imp::Process> for Child 
AsInner for ChildStderr			impl AsInner<AnonPipe> for ChildStderr 
AsInner for ChildStdin			impl AsInner<AnonPipe> for ChildStdin 
AsInner for ChildStdout			impl AsInner<AnonPipe> for ChildStdout 
AsInner for Command			impl AsInner<imp::Command> for Command 
AsInner for DirEntry			impl AsInner<fs_imp::DirEntry> for DirEntry 
AsInner for ExitStatus			impl AsInner<imp::ExitStatus> for ExitStatus 
AsInner for File			impl AsInner<fs_imp::File> for File 
AsInner for FileAttr			impl AsInner<syscall::Stat> for FileAttr 
AsInner for FileAttr			impl AsInner<stat64> for FileAttr 
AsInner for FileDesc			impl AsInner<usize> for FileDesc 
AsInner for FileDesc			impl AsInner<c_int> for FileDesc 
AsInner for FileType			impl AsInner<fs_imp::FileType> for FileType 
AsInner for Ipv4Addr			impl AsInner<c::in_addr> for Ipv4Addr 
AsInner for Ipv6Addr			impl AsInner<c::in6_addr> for Ipv6Addr 
AsInner for JoinHandle			impl<T> AsInner<imp::Thread> for JoinHandle<T> 
AsInner for Metadata			impl AsInner<fs_imp::FileAttr> for Metadata 
AsInner for OsStr			impl AsInner<Slice> for OsStr 
AsInner for Permissions			impl AsInner<fs_imp::FilePermissions> for Permissions 
AsInner for Socket			impl AsInner<c_int> for Socket 
AsInner for Socket			impl AsInner<c::SOCKET> for Socket 
AsInner for TcpListener			impl AsInner<net_imp::TcpListener> for TcpListener 
AsInner for TcpStream			impl AsInner<net_imp::TcpStream> for TcpStream 
AsInner for UdpSocket			impl AsInner<net_imp::UdpSocket> for UdpSocket 
AsInner for Wtf8			impl AsInner<[u8]> for Wtf8 
AsInnerMut			pub trait AsInnerMut<Inner: ?Sized> 
AsInnerMut for Command			impl AsInnerMut<imp::Command> for Command 
AsInnerMut for DirBuilder			impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder 
AsInnerMut for OpenOptions			impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions 
AsRawFd			pub trait AsRawFd 
AsRawFd			pub trait AsRawFd 
AsRawFd for UnixDatagram			impl AsRawFd for UnixDatagram 
AsRawFd for UnixListener			impl AsRawFd for UnixListener 
AsRawFd for UnixStream			impl AsRawFd for UnixStream 
AsRawFd for fs			impl AsRawFd for fs::File 
AsRawFd for fs			impl AsRawFd for fs::File 
AsRawFd for net			impl AsRawFd for net::TcpListener 
AsRawFd for net			impl AsRawFd for net::TcpStream 
AsRawFd for net			impl AsRawFd for net::UdpSocket 
AsRawFd for net			impl AsRawFd for net::TcpListener 
AsRawFd for net			impl AsRawFd for net::TcpStream 
AsRawFd for net			impl AsRawFd for net::UdpSocket 
AsRawFd for process			impl AsRawFd for process::ChildStderr 
AsRawFd for process			impl AsRawFd for process::ChildStdin 
AsRawFd for process			impl AsRawFd for process::ChildStdout 
AsRawFd for process			impl AsRawFd for process::ChildStderr 
AsRawFd for process			impl AsRawFd for process::ChildStdin 
AsRawFd for process			impl AsRawFd for process::ChildStdout 
AsRawHandle			pub trait AsRawHandle 
AsRawHandle for fs			impl AsRawHandle for fs::File 
AsRawHandle for process			impl AsRawHandle for process::Child 
AsRawHandle for process			impl AsRawHandle for process::ChildStderr 
AsRawHandle for process			impl AsRawHandle for process::ChildStdin 
AsRawHandle for process			impl AsRawHandle for process::ChildStdout 
AsRawHandle for thread			impl<T> AsRawHandle for thread::JoinHandle<T> 
AsRawSocket			pub trait AsRawSocket 
AsRawSocket for net			impl AsRawSocket for net::TcpListener 
AsRawSocket for net			impl AsRawSocket for net::TcpStream 
AsRawSocket for net			impl AsRawSocket for net::UdpSocket 
AsRef for CStr			impl AsRef<CStr> for CStr 
AsRef for CString			impl AsRef<CStr> for CString 
AsRef for Component			impl<'a> AsRef<OsStr> for Component<'a> 
AsRef for Components			impl<'a> AsRef<OsStr> for Components<'a> 
AsRef for Components			impl<'a> AsRef<Path> for Components<'a> 
AsRef for Cow			impl<'a> AsRef<Path> for Cow<'a, OsStr> 
AsRef for Iter			impl<'a> AsRef<OsStr> for Iter<'a> 
AsRef for Iter			impl<'a> AsRef<Path> for Iter<'a> 
AsRef for OsStr			impl AsRef<OsStr> for OsStr 
AsRef for OsStr			impl AsRef<Path> for OsStr 
AsRef for OsString			impl AsRef<OsStr> for OsString 
AsRef for OsString			impl AsRef<Path> for OsString 
AsRef for Path			impl AsRef<OsStr> for Path 
AsRef for Path			impl AsRef<Path> for Path 
AsRef for PathBuf			impl AsRef<OsStr> for PathBuf 
AsRef for PathBuf			impl AsRef<Path> for PathBuf 
AsRef for String			impl AsRef<OsStr> for String 
AsRef for String			impl AsRef<Path> for String 
AsRef for str			impl AsRef<OsStr> for str 
AsRef for str			impl AsRef<Path> for str 
AsciiEscaped			struct AsciiEscaped<'a>(&'a [u8]);
AsciiExt			impl AsciiExt for [u8] 
AsciiExt			pub trait AsciiExt 
AsciiExt for Wtf8			impl AsciiExt for Wtf8 
AsciiExt for char			impl AsciiExt for char 
AsciiExt for str			impl AsciiExt for str 
AsciiExt for u8			impl AsciiExt for u8 
AssertUnwindSafe			pub struct AssertUnwindSafe<T>(
AsyncPipe			impl<'a> AsyncPipe<'a> 
AsyncPipe			struct AsyncPipe<'a> 
B			    struct B;
BY_HANDLE_FILE_INFORMATION			pub struct BY_HANDLE_FILE_INFORMATION 
Barrier			impl Barrier 
Barrier			pub struct Barrier 
BarrierState			struct BarrierState 
BarrierWaitResult			impl BarrierWaitResult 
BarrierWaitResult			pub struct BarrierWaitResult(bool);
BitAnd			impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>
BitOr			impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>
BitXor			impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>
Blocker			enum Blocker 
Borrow for CString			impl Borrow<CStr> for CString 
Borrow for OsString			impl Borrow<OsStr> for OsString 
Borrow for PathBuf			impl Borrow<Path> for PathBuf 
Bucket			impl<K, V, M> Bucket<K, V, M> 
Bucket			pub struct Bucket<K, V, M> 
BucketState			pub enum BucketState<K, V, M> 
Buf			impl Buf 
Buf			pub struct Buf 
Buf			impl Buf 
Buf			pub struct Buf 
Buf			impl Buf 
Buf			pub struct Buf 
BufRead			impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B 
BufRead			impl<'a> BufRead for &'a [u8] 
BufRead			pub trait BufRead: Read 
BufRead for Box			impl<B: BufRead + ?Sized> BufRead for Box<B> 
BufRead for BufReader			impl<R: Read> BufRead for BufReader<R> 
BufRead for Chain			impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> 
BufRead for Cursor			impl<T> BufRead for Cursor<T> where T: AsRef<[u8]> 
BufRead for Empty			impl BufRead for Empty 
BufRead for R			        impl BufRead for R 
BufRead for StdinLock			impl<'a> BufRead for StdinLock<'a> 
BufRead for Take			impl<T: BufRead> BufRead for Take<T> 
BufReader			impl<R: Read> BufReader<R> 
BufReader			pub struct BufReader<R> 
BufWriter			impl<W: Write> BufWriter<W> 
BufWriter			pub struct BufWriter<W: Write> 
Buffer			impl<T> Buffer<T> 
Buffer			struct Buffer<T> 
BuildHasher for RandomState			impl BuildHasher for RandomState 
Builder			impl Builder 
Builder			pub struct Builder 
Bytes			pub struct Bytes<R> 
CONDITION_VARIABLE			pub struct CONDITION_VARIABLE { pub ptr: LPVOID }
CONTEXT			pub struct CONTEXT 
CRITICAL_SECTION			pub struct CRITICAL_SECTION 
CStr			impl CStr 
CStr			pub struct CStr 
CString			impl CString 
CString			pub struct CString 
CancelIo			    pub fn CancelIo(handle: HANDLE) -> BOOL;
Chain			pub struct Chain<T, U> 
Chars			pub struct Chars<R> 
CharsError			pub enum CharsError 
Child			impl Child 
Child			pub struct Child 
ChildPipes			struct ChildPipes 
ChildPipes			pub struct ChildPipes 
ChildStderr			pub struct ChildStderr 
ChildStdin			pub struct ChildStdin 
ChildStdio			enum ChildStdio 
ChildStdio			impl ChildStdio 
ChildStdio			impl ChildStdio 
ChildStdio			pub enum ChildStdio 
ChildStdout			pub struct ChildStdout 
Cleanup			struct Cleanup 
Clone for Bucket			impl<K, V, M: Copy> Clone for Bucket<K, V, M> 
Clone for Difference			impl<'a, T, S> Clone for Difference<'a, T, S> 
Clone for Dropable			    impl Clone for Dropable 
Clone for Intersection			impl<'a, T, S> Clone for Intersection<'a, T, S> 
Clone for Ipv4Addr			impl Clone for Ipv4Addr 
Clone for Ipv6Addr			impl Clone for Ipv6Addr 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Iter			impl<'a, K> Clone for Iter<'a, K> 
Clone for Iter			impl<'a, K, V> Clone for Iter<'a, K, V> 
Clone for Keys			impl<'a, K, V> Clone for Keys<'a, K, V> 
Clone for RawBucket			impl<K, V> Clone for RawBucket<K, V> 
Clone for RawBuckets			impl<'a, K, V> Clone for RawBuckets<'a, K, V> 
Clone for RawTable			impl<K: Clone, V: Clone> Clone for RawTable<K, V> 
Clone for Sender			impl<T> Clone for Sender<T> 
Clone for SocketAddrV4			impl Clone for SocketAddrV4 
Clone for SocketAddrV6			impl Clone for SocketAddrV6 
Clone for SymmetricDifference			impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> 
Clone for SyncSender			impl<T> Clone for SyncSender<T> 
Clone for Union			impl<'a, T, S> Clone for Union<'a, T, S> 
Clone for Values			impl<'a, K, V> Clone for Values<'a, K, V> 
Clone for WIN32_FIND_DATAW			impl Clone for WIN32_FIND_DATAW 
CloseHandle			    pub fn CloseHandle(hObject: HANDLE) -> BOOL;
CodePoint			impl CodePoint 
CodePoint			pub struct CodePoint 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			pub struct Command 
Command			impl Command 
Command			impl Command 
Command			impl Command 
Command			pub struct Command 
CommandExt			pub trait CommandExt 
CommandExt			pub trait CommandExt 
CommandExt			pub trait CommandExt 
CommandExt for process			impl CommandExt for process::Command 
CommandExt for process			impl CommandExt for process::Command 
CommandExt for process			impl CommandExt for process::Command 
CommandLineToArgvW			    pub fn CommandLineToArgvW(lpCmdLine: *mut LPCWSTR,
Component			impl<'a> Component<'a> 
Component			pub enum Component<'a> 
Components			impl<'a> Components<'a> 
Components			pub struct Components<'a> 
Condvar			impl Condvar 
Condvar			pub struct Condvar 
Condvar			impl Condvar 
Condvar			pub struct Condvar 
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }
Condvar			impl Condvar 
Condvar			pub struct Condvar { inner: UnsafeCell<c::CONDITION_VARIABLE> }
Condvar			impl Condvar 
Condvar			pub struct Condvar(imp::Condvar);
Context			    struct Context<'a> 
ContinueDebugEvent			            fn ContinueDebugEvent(dwProcessId: DWORD, dwThreadId: DWORD,
Copy for Bucket			impl<K, V, M: Copy> Copy for Bucket<K, V, M> {}
Copy for RawBucket			impl<K, V> Copy for RawBucket<K, V> {}
CopyFileExW			    pub fn CopyFileExW(lpExistingFileName: LPCWSTR,
CreateDirectoryW			    pub fn CreateDirectoryW(lpPathName: LPCWSTR,
CreateEventW			    pub fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES,
CreateFileW			    pub fn CreateFileW(lpFileName: LPCWSTR,
CreateHardLinkW			    pub fn CreateHardLinkW(lpSymlinkFileName: LPCWSTR,
CreateNamedPipeW			    pub fn CreateNamedPipeW(lpName: LPCWSTR,
CreateProcessW			    pub fn CreateProcessW(lpApplicationName: LPCWSTR,
CreateSymbolicLinkW			    pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,
CreateThread			    pub fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,
CryptAcquireContextA			    pub fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,
CryptGenRandom			    pub fn CryptGenRandom(hProv: HCRYPTPROV,
CryptReleaseContext			    pub fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;
Cursor			impl<T> Cursor<T> 
Cursor			pub struct Cursor<T> 
Custom			struct Custom 
DEBUG_EVENT			        struct DEBUG_EVENT 
Data			    struct Data<F, R> 
Debug for Buf			impl Debug for Buf 
Debug for Buf			impl Debug for Buf 
Debug for Buf			impl Debug for Buf 
Debug for Entry			impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> 
Debug for HashMap			impl<K, V, S> Debug for HashMap<K, V, S>
Debug for OccupiedEntry			impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> 
Debug for OsStr			impl Debug for OsStr 
Debug for OsString			impl Debug for OsString 
Debug for Slice			impl Debug for Slice 
Debug for Slice			impl Debug for Slice 
Debug for Slice			impl Debug for Slice 
Debug for VacantEntry			impl<'a, K: 'a + Debug, V: 'a> Debug for VacantEntry<'a, K, V> 
DebugHelper			        struct DebugHelper<'a>(&'a Path);
Default			impl<'a> Default for &'a CStr 
Default			impl<'a> Default for &'a OsStr 
Default for CString			impl Default for CString 
Default for Condvar			impl Default for Condvar 
Default for DefaultHasher			impl Default for DefaultHasher 
Default for HashMap			impl<K, V, S> Default for HashMap<K, V, S>
Default for HashSet			impl<T, S> Default for HashSet<T, S>
Default for Mutex			impl<T: ?Sized + Default> Default for Mutex<T> 
Default for OsString			impl Default for OsString 
Default for RandomState			impl Default for RandomState 
Default for RwLock			impl<T: Default> Default for RwLock<T> 
DefaultHasher			impl DefaultHasher 
DefaultHasher			pub struct DefaultHasher(SipHasher13);
DefaultResizePolicy			impl DefaultResizePolicy 
DefaultResizePolicy			struct DefaultResizePolicy;
DeleteCriticalSection			    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
DeleteFileW			    pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;
Deref for AssertUnwindSafe			impl<T> Deref for AssertUnwindSafe<T> 
Deref for FullBucket			impl<K, V, M> Deref for FullBucket<K, V, M>
Deref for Handle			impl Deref for Handle 
Deref for MutexGuard			impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> 
Deref for ReentrantMutexGuard			impl<'mutex, T> Deref for ReentrantMutexGuard<'mutex, T> 
Deref for RwLockReadGuard			impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> 
Deref for RwLockWriteGuard			impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> 
DerefMut for AssertUnwindSafe			impl<T> DerefMut for AssertUnwindSafe<T> 
DerefMut for MutexGuard			impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> 
DerefMut for RwLockWriteGuard			impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> 
DeviceIoControl			    pub fn DeviceIoControl(hDevice: HANDLE,
Difference			pub struct Difference<'a, T: 'a, S: 'a> 
Dir			struct Dir(FileDesc);
Dir			struct Dir(*mut libc::DIR);
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder 
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder { mode: u16 }
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder { mode: mode_t }
DirBuilder			impl DirBuilder 
DirBuilder			pub struct DirBuilder;
DirBuilderExt			pub trait DirBuilderExt 
DirBuilderExt			pub trait DirBuilderExt 
DirBuilderExt for fs			impl DirBuilderExt for fs::DirBuilder 
DirBuilderExt for fs			impl DirBuilderExt for fs::DirBuilder 
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry(fs_imp::DirEntry);
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
DirEntry			impl DirEntry 
DirEntry			pub struct DirEntry 
DirEntryExt			pub trait DirEntryExt 
DirEntryExt for fs			impl DirEntryExt for fs::DirEntry 
Display			pub struct Display<'a> 
Display for StringError			        impl Display for StringError 
Div for Duration			impl Div<u32> for Duration 
DivAssign for Duration			impl DivAssign<u32> for Duration 
Dl_info			    struct Dl_info 
Dns			impl Dns 
Dns			pub struct Dns 
DnsAnswer			pub struct DnsAnswer 
DnsQuery			pub struct DnsQuery 
DoubleEndedIterator for Args			impl DoubleEndedIterator for Args 
DoubleEndedIterator for Args			impl DoubleEndedIterator for Args 
DoubleEndedIterator for Args			impl DoubleEndedIterator for Args 
DoubleEndedIterator for Args			impl DoubleEndedIterator for Args 
DoubleEndedIterator for ArgsOs			impl DoubleEndedIterator for ArgsOs 
DoubleEndedIterator for Components			impl<'a> DoubleEndedIterator for Components<'a> 
DoubleEndedIterator for EscapeDefault			impl DoubleEndedIterator for EscapeDefault 
DoubleEndedIterator for Iter			impl<'a> DoubleEndedIterator for Iter<'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drain			pub struct Drain<'a, K: 'a> 
Drain			pub struct Drain<'a, K: 'a, V: 'a> 
Drop for Answer			    impl<'a> Drop for Answer<'a> 
Drop for Args			impl Drop for Args 
Drop for AsyncPipe			impl<'a> Drop for AsyncPipe<'a> 
Drop for BufWriter			impl<W: Write> Drop for BufWriter<W> 
Drop for CString			impl Drop for CString 
Drop for Cleanup			impl Drop for Cleanup 
Drop for Condvar			impl Drop for Condvar 
Drop for Dir			impl Drop for Dir 
Drop for Drain			impl<'a, K: 'a, V: 'a> Drop for Drain<'a, K, V> 
Drop for DropGuard			impl<'a> Drop for DropGuard<'a> 
Drop for Dropable			    impl Drop for Dropable 
Drop for DynamicLibrary			impl Drop for DynamicLibrary 
Drop for Env			impl Drop for Env 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FileDesc			impl Drop for FileDesc 
Drop for FindNextFileHandle			impl Drop for FindNextFileHandle 
Drop for Finish			impl Drop for Finish 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			        impl Drop for Foo 
Drop for Foo			    impl Drop for Foo 
Drop for Guard			        impl<'a> Drop for Guard<'a> 
Drop for Handle			impl<'rx, T: Send> Drop for Handle<'rx, T> 
Drop for Handle			impl Drop for Handle 
Drop for Handle			impl Drop for Handle 
Drop for Handler			impl Drop for Handler 
Drop for Key			impl Drop for Key 
Drop for LaunchpadDestructor			        impl Drop for LaunchpadDestructor 
Drop for LookupHost			impl Drop for LookupHost 
Drop for Mutex			impl<T: ?Sized> Drop for Mutex<T> 
Drop for MutexGuard			impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> 
Drop for NoClose			impl Drop for NoClose 
Drop for OsRng			impl Drop for OsRng 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Packet			impl<T> Drop for Packet<T> 
Drop for Process			impl Drop for Process 
Drop for Queue			impl<T> Drop for Queue<T> 
Drop for Queue			impl<T> Drop for Queue<T> 
Drop for RawTable			impl<K, V> Drop for RawTable<K, V> 
Drop for Receiver			impl<T> Drop for Receiver<T> 
Drop for ReentrantMutex			impl<T> Drop for ReentrantMutex<T> 
Drop for ReentrantMutexGuard			impl<'a, T> Drop for ReentrantMutexGuard<'a, T> 
Drop for RwLock			impl<T: ?Sized> Drop for RwLock<T> 
Drop for RwLockReadGuard			impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> 
Drop for RwLockWriteGuard			impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> 
Drop for S1			        impl Drop for S1 
Drop for S2			        impl Drop for S2 
Drop for Select			impl Drop for Select 
Drop for Sender			impl<T> Drop for Sender<T> 
Drop for Socket			impl Drop for Socket 
Drop for SyncSender			impl<T> Drop for SyncSender<T> 
Drop for TempDir			    impl Drop for TempDir 
Drop for Thread			impl Drop for Thread 
Drop for Unwinder			            impl Drop for Unwinder 
Drop for Unwinder			            impl Drop for Unwinder 
DropGuard			impl<'a> DropGuard<'a> 
DropGuard			struct DropGuard<'a> 
Dropable			    impl Dropable 
Dropable			    struct Dropable 
DuplicateHandle			    pub fn DuplicateHandle(hSourceProcessHandle: HANDLE,
Duration			impl Duration 
Duration			pub struct Duration 
DynamicLibrary			impl DynamicLibrary 
DynamicLibrary			pub struct DynamicLibrary 
EXCEPTION_DISPOSITION			pub enum EXCEPTION_DISPOSITION 
EXCEPTION_POINTERS			pub struct EXCEPTION_POINTERS 
EXCEPTION_RECORD			pub struct EXCEPTION_RECORD 
Empty			pub struct Empty { _priv: () }
EmptyBucket			impl<K, V, M> EmptyBucket<K, V, M> 
EmptyBucket			impl<K, V, M> EmptyBucket<K, V, M>
EmptyBucket			pub struct EmptyBucket<K, V, M> 
EncodeWide			pub struct EncodeWide<'a> 
EnterCriticalSection			    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
Entry			impl<'a, K, V> Entry<'a, K, V> 
Entry			pub enum Entry<'a, K: 'a, V: 'a> 
Env			pub struct Env 
Env			pub struct Env 
Env			pub struct Env 
Eq for CStr			impl Eq for CStr {}
Eq for Foo			        impl Eq for Foo {}
Eq for HashMap			impl<K, V, S> Eq for HashMap<K, V, S>
Eq for HashSet			impl<T, S> Eq for HashSet<T, S>
Eq for Ipv4Addr			impl Eq for Ipv4Addr {}
Eq for Ipv6Addr			impl Eq for Ipv6Addr {}
Eq for OsStr			impl Eq for OsStr {}
Eq for OsString			impl Eq for OsString {}
Eq for SocketAddrV4			impl Eq for SocketAddrV4 {}
Eq for SocketAddrV6			impl Eq for SocketAddrV6 {}
Eq for SystemTime			impl Eq for SystemTime {}
Eq for Timespec			impl Eq for Timespec {}
Eq for Timespec			impl Eq for Timespec {}
Error			impl Error + 'static + Send + Sync 
Error			impl Error + 'static + Send 
Error			impl Error + 'static 
Error			impl Error + Send + Sync 
Error			impl Error + Send 
Error			impl Error 
Error			pub trait Error: Debug + Display 
Error			impl Error 
Error			pub struct Error 
Error for A			    impl Error for A 
Error for AddrParseError			impl Error for AddrParseError 
Error for B			    impl Error for B 
Error for Box			impl<T: Error> Error for Box<T> 
Error for IntoStringError			impl Error for IntoStringError 
Error for JoinPathsError			impl Error for JoinPathsError 
Error for NulError			impl Error for NulError 
Error for PoisonError			impl<T> Error for PoisonError<T> 
Error for StringError			        impl Error for StringError 
Error for StripPrefixError			impl Error for StripPrefixError 
Error for SystemTimeError			impl Error for SystemTimeError 
Error for TryLockError			impl<T> Error for TryLockError<T> 
Error for VarError			impl Error for VarError 
Error for cell			impl Error for cell::BorrowError 
Error for cell			impl Error for cell::BorrowMutError 
Error for char			impl Error for char::CharTryFromError 
Error for char			impl Error for char::DecodeUtf16Error 
Error for fmt			impl Error for fmt::Error 
Error for num			impl Error for num::ParseFloatError 
Error for num			impl Error for num::ParseIntError 
Error for num			impl Error for num::TryFromIntError 
Error for str			impl Error for str::ParseBoolError 
Error for str			impl Error for str::Utf8Error 
Error for string			impl Error for string::FromUtf16Error 
Error for string			impl Error for string::FromUtf8Error 
Error for string			impl Error for string::ParseError 
ErrorKind			impl ErrorKind 
ErrorKind			pub enum ErrorKind 
ErrorRepeat			    struct ErrorRepeat 
EscapeDefault			pub struct EscapeDefault 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for Args			impl ExactSizeIterator for Args 
ExactSizeIterator for ArgsOs			impl ExactSizeIterator for ArgsOs 
ExactSizeIterator for Drain			impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
ExactSizeIterator for Drain			impl<'a, K> ExactSizeIterator for Drain<'a, K> 
ExactSizeIterator for Drain			impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> 
ExactSizeIterator for EscapeDefault			impl ExactSizeIterator for EscapeDefault {}
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> 
ExactSizeIterator for IntoIter			impl<K> ExactSizeIterator for IntoIter<K> 
ExactSizeIterator for IntoIter			impl<K, V> ExactSizeIterator for IntoIter<K, V> 
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
ExactSizeIterator for Iter			impl<'a, K> ExactSizeIterator for Iter<'a, K> 
ExactSizeIterator for Iter			impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> 
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
ExactSizeIterator for IterMut			impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> 
ExactSizeIterator for Keys			impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> 
ExactSizeIterator for Values			impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> 
ExactSizeIterator for ValuesMut			impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> 
ExitProcess			    pub fn ExitProcess(uExitCode: c_uint) -> !;
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(imp::ExitStatus);
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(i32);
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(c_int);
ExitStatus			impl ExitStatus 
ExitStatus			pub struct ExitStatus(c::DWORD);
ExitStatusExt			pub trait ExitStatusExt 
ExitStatusExt			pub trait ExitStatusExt 
ExitStatusExt			pub trait ExitStatusExt 
ExitStatusExt for process			impl ExitStatusExt for process::ExitStatus 
ExitStatusExt for process			impl ExitStatusExt for process::ExitStatus 
ExitStatusExt for process			impl ExitStatusExt for process::ExitStatus 
Extend for HashMap			impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>
Extend for HashMap			impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>
Extend for HashSet			impl<'a, T, S> Extend<&'a T> for HashSet<T, S>
Extend for HashSet			impl<T, S> Extend<T> for HashSet<T, S>
Extend for Wtf8Buf			impl Extend<CodePoint> for Wtf8Buf 
FILETIME			pub struct FILETIME 
FILE_BASIC_INFO			pub struct FILE_BASIC_INFO 
FILE_END_OF_FILE_INFO			pub struct FILE_END_OF_FILE_INFO 
FILE_INFO_BY_HANDLE_CLASS			pub enum FILE_INFO_BY_HANDLE_CLASS 
FLOATING_SAVE_AREA			pub struct FLOATING_SAVE_AREA 
FailFlushWriter			        struct FailFlushWriter;
FailFlushWriter			        struct FailFlushWriter<'a>(&'a mut Vec<u8>);
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
Failure			pub enum Failure<T> 
Failure			pub enum Failure 
File			impl File 
File			pub struct File 
File			impl File 
File			pub struct File(FileDesc);
File			impl File 
File			pub struct File(FileDesc);
File			impl File 
File			pub struct File { handle: Handle }
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr 
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr 
FileAttr			impl FileAttr 
FileAttr			pub struct FileAttr 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileDesc			impl FileDesc 
FileDesc			pub struct FileDesc 
FileExt			pub trait FileExt 
FileExt			pub trait FileExt 
FileExt for fs			impl FileExt for fs::File 
FileExt for fs			impl FileExt for fs::File 
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { mode: u16 }
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { mode: mode_t }
FilePermissions			impl FilePermissions 
FilePermissions			pub struct FilePermissions { attrs: c::DWORD }
FileType			impl FileType 
FileType			pub struct FileType(fs_imp::FileType);
FileType			impl FileType 
FileType			pub struct FileType { mode: u16 }
FileType			impl FileType 
FileType			pub struct FileType { mode: mode_t }
FileType			impl FileType 
FileType			pub enum FileType 
FileTypeExt			pub trait FileTypeExt 
FileTypeExt			pub trait FileTypeExt 
FileTypeExt for fs			impl FileTypeExt for fs::FileType 
FileTypeExt for fs			impl FileTypeExt for fs::FileType 
FindClose			    pub fn FindClose(findFile: HANDLE) -> BOOL;
FindFirstFileW			    pub fn FindFirstFileW(fileName: LPCWSTR,
FindNextFileHandle			struct FindNextFileHandle(c::HANDLE);
FindNextFileW			    pub fn FindNextFileW(findFile: HANDLE, findFileData: LPWIN32_FIND_DATAW)
Finish			struct Finish 
Flag			impl Flag 
Flag			pub struct Flag { failed: AtomicBool }
Flavor			enum Flavor<T> 
FlushFileBuffers			    pub fn FlushFileBuffers(hFile: HANDLE) -> BOOL;
Foo			        struct Foo(&'static str, i32);
Foo			        struct Foo(Arc<AtomicUsize>);
Foo			        struct Foo(Arc<AtomicUsize>);
Foo			        struct Foo;
Foo			    struct Foo(Sender<()>);
FormatMessageW			    pub fn FormatMessageW(flags: DWORD,
FreeEnvironmentStringsW			    pub fn FreeEnvironmentStringsW(env_ptr: LPWCH) -> BOOL;
FreeLibrary			    pub fn FreeLibrary(handle: HMODULE) -> BOOL;
From			impl<W> From<IntoInnerError<W>> for Error 
From			impl<T> From<PoisonError<T>> for TryLockError<T> 
From for Box			impl From<String> for Box<Error + Send + Sync> 
From for Box			impl From<String> for Box<Error> 
From for Box			impl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a> 
From for Box			impl<'a, E: Error + 'a> From<E> for Box<Error + 'a> 
From for Box			impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<Error + Send + Sync + 'a> 
From for Box			impl<'a> From<&'a str> for Box<Error> 
From for CString			impl<'a> From<&'a CStr> for CString 
From for Cow			impl<'a> From<&'a Path> for Cow<'a, Path> 
From for Cow			impl<'a> From<PathBuf> for Cow<'a, Path> 
From for Error			impl From<ErrorKind> for Error 
From for ExitStatus			impl From<i32> for ExitStatus 
From for ExitStatus			impl From<c_int> for ExitStatus 
From for ExitStatus			impl From<c::DWORD> for ExitStatus 
From for Ipv4Addr			impl From<[u8; 4]> for Ipv4Addr 
From for Ipv4Addr			impl From<u32> for Ipv4Addr 
From for Ipv6Addr			impl From<[u8; 16]> for Ipv6Addr 
From for OsString			impl From<String> for OsString 
From for OsString			impl From<PathBuf> for OsString 
From for PathBuf			impl From<OsString> for PathBuf 
From for PathBuf			impl From<String> for PathBuf 
From for SystemTime			impl From<syscall::TimeSpec> for SystemTime 
From for SystemTime			    impl From<libc::timespec> for SystemTime 
From for SystemTime			    impl From<libc::timeval> for SystemTime 
From for SystemTime			impl From<c::FILETIME> for SystemTime 
From for Vec			impl From<CString> for Vec<u8> 
From for io			impl From<NulError> for io::Error 
From for n16			impl From<u16> for n16 
From for u16			impl From<n16> for u16 
From for u32			impl From<Ipv4Addr> for u32 
FromBytesWithNulError			pub struct FromBytesWithNulError { _a: () }
FromInner			pub trait FromInner<Inner> 
FromInner for Child			impl FromInner<(imp::Process, imp::StdioPipes)> for Child 
FromInner for ChildStderr			impl FromInner<AnonPipe> for ChildStderr 
FromInner for ChildStdin			impl FromInner<AnonPipe> for ChildStdin 
FromInner for ChildStdout			impl FromInner<AnonPipe> for ChildStdout 
FromInner for ExitStatus			impl FromInner<imp::ExitStatus> for ExitStatus 
FromInner for File			impl FromInner<fs_imp::File> for File 
FromInner for File			impl FromInner<usize> for File 
FromInner for File			impl FromInner<c_int> for File 
FromInner for File			impl FromInner<c::HANDLE> for File 
FromInner for FilePermissions			impl FromInner<u32> for FilePermissions 
FromInner for FilePermissions			impl FromInner<u32> for FilePermissions 
FromInner for Ipv4Addr			impl FromInner<c::in_addr> for Ipv4Addr 
FromInner for Ipv6Addr			impl FromInner<c::in6_addr> for Ipv6Addr 
FromInner for OsString			impl FromInner<Buf> for OsString 
FromInner for Permissions			impl FromInner<fs_imp::FilePermissions> for Permissions 
FromInner for Socket			impl FromInner<c_int> for Socket 
FromInner for Socket			impl FromInner<c::SOCKET> for Socket 
FromInner for SocketAddrV4			impl FromInner<c::sockaddr_in> for SocketAddrV4 
FromInner for SocketAddrV6			impl FromInner<c::sockaddr_in6> for SocketAddrV6 
FromInner for Stdio			impl FromInner<imp::Stdio> for Stdio 
FromInner for SystemTime			impl FromInner<time::SystemTime> for SystemTime 
FromInner for TcpListener			impl FromInner<net_imp::TcpListener> for TcpListener 
FromInner for TcpListener			impl FromInner<Socket> for TcpListener 
FromInner for TcpStream			impl FromInner<net_imp::TcpStream> for TcpStream 
FromInner for TcpStream			impl FromInner<Socket> for TcpStream 
FromInner for UdpSocket			impl FromInner<net_imp::UdpSocket> for UdpSocket 
FromInner for UdpSocket			impl FromInner<Socket> for UdpSocket 
FromIterator for HashMap			impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>
FromIterator for HashSet			impl<T, S> FromIterator<T> for HashSet<T, S>
FromIterator for Wtf8Buf			impl FromIterator<CodePoint> for Wtf8Buf 
FromRawFd			pub trait FromRawFd 
FromRawFd			pub trait FromRawFd 
FromRawFd for UnixDatagram			impl FromRawFd for UnixDatagram 
FromRawFd for UnixListener			impl FromRawFd for UnixListener 
FromRawFd for UnixStream			impl FromRawFd for UnixStream 
FromRawFd for fs			impl FromRawFd for fs::File 
FromRawFd for fs			impl FromRawFd for fs::File 
FromRawFd for net			impl FromRawFd for net::TcpListener 
FromRawFd for net			impl FromRawFd for net::TcpStream 
FromRawFd for net			impl FromRawFd for net::UdpSocket 
FromRawFd for net			impl FromRawFd for net::TcpListener 
FromRawFd for net			impl FromRawFd for net::TcpStream 
FromRawFd for net			impl FromRawFd for net::UdpSocket 
FromRawFd for process			impl FromRawFd for process::Stdio 
FromRawFd for process			impl FromRawFd for process::Stdio 
FromRawHandle			pub trait FromRawHandle 
FromRawHandle for fs			impl FromRawHandle for fs::File 
FromRawHandle for process			impl FromRawHandle for process::Stdio 
FromRawSocket			pub trait FromRawSocket 
FromRawSocket for net			impl FromRawSocket for net::TcpListener 
FromRawSocket for net			impl FromRawSocket for net::TcpStream 
FromRawSocket for net			impl FromRawSocket for net::UdpSocket 
FromStr for IpAddr			impl FromStr for IpAddr 
FromStr for Ipv4Addr			impl FromStr for Ipv4Addr 
FromStr for Ipv6Addr			impl FromStr for Ipv6Addr 
FromStr for SocketAddr			impl FromStr for SocketAddr 
FromStr for SocketAddrV4			impl FromStr for SocketAddrV4 
FromStr for SocketAddrV6			impl FromStr for SocketAddrV6 
FullBucket			impl<'t, K, V, M> FullBucket<K, V, M>
FullBucket			impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> 
FullBucket			impl<K, V, M> FullBucket<K, V, M> 
FullBucket			impl<K, V, M> FullBucket<K, V, M>
FullBucket			pub struct FullBucket<K, V, M> 
FusedIterator for Components			impl<'a> FusedIterator for Components<'a> {}
FusedIterator for Difference			impl<'a, T, S> FusedIterator for Difference<'a, T, S>
FusedIterator for Drain			impl<'a, K, V> FusedIterator for Drain<'a, K, V> {}
FusedIterator for Drain			impl<'a, K> FusedIterator for Drain<'a, K> {}
FusedIterator for EscapeDefault			impl FusedIterator for EscapeDefault {}
FusedIterator for Intersection			impl<'a, T, S> FusedIterator for Intersection<'a, T, S>
FusedIterator for IntoIter			impl<K, V> FusedIterator for IntoIter<K, V> {}
FusedIterator for IntoIter			impl<K> FusedIterator for IntoIter<K> {}
FusedIterator for Iter			impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}
FusedIterator for Iter			impl<'a, K> FusedIterator for Iter<'a, K> {}
FusedIterator for Iter			impl<'a> FusedIterator for Iter<'a> {}
FusedIterator for IterMut			impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}
FusedIterator for Keys			impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}
FusedIterator for SymmetricDifference			impl<'a, T, S> FusedIterator for SymmetricDifference<'a, T, S>
FusedIterator for Union			impl<'a, T, S> FusedIterator for Union<'a, T, S>
FusedIterator for Values			impl<'a, K, V> FusedIterator for Values<'a, K, V> {}
FusedIterator for ValuesMut			impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}
GUID			pub struct GUID 
GapThenFull			impl<K, V, M> GapThenFull<K, V, M>
GapThenFull			pub struct GapThenFull<K, V, M> 
GetCommandLineW			    pub fn GetCommandLineW() -> *mut LPCWSTR;
GetConsoleMode			    pub fn GetConsoleMode(hConsoleHandle: HANDLE,
GetCurrentDirectoryW			    pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;
GetCurrentProcess			    pub fn GetCurrentProcess() -> HANDLE;
GetCurrentProcessId			    pub fn GetCurrentProcessId() -> DWORD;
GetCurrentThread			    pub fn GetCurrentThread() -> HANDLE;
GetEnvironmentStringsW			    pub fn GetEnvironmentStringsW() -> LPWCH;
GetEnvironmentVariableW			    pub fn GetEnvironmentVariableW(n: LPCWSTR, v: LPWSTR, nsize: DWORD) -> DWORD;
GetExitCodeProcess			    pub fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;
GetFileInformationByHandle			    pub fn GetFileInformationByHandle(hFile: HANDLE,
GetFinalPathNameByHandleW			    pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,
GetLastError			    pub fn GetLastError() -> DWORD;
GetModuleFileNameW			    pub fn GetModuleFileNameW(hModule: HMODULE,
GetModuleHandleW			    pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;
GetOverlappedResult			    pub fn GetOverlappedResult(hFile: HANDLE,
GetProcAddress			    pub fn GetProcAddress(handle: HMODULE,
GetProcessId			    pub fn GetProcessId(handle: HANDLE) -> DWORD;
GetStdHandle			    pub fn GetStdHandle(which: DWORD) -> HANDLE;
GetSystemTimeAsFileTime			    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
GetTempPathW			    pub fn GetTempPathW(nBufferLength: DWORD,
GetUserProfileDirectoryW			    pub fn GetUserProfileDirectoryW(hToken: HANDLE,
Guard			    struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }
Guard			pub struct Guard 
Handle			impl<'rx, T: Send> Handle<'rx, T> 
Handle			pub struct Handle<'rx, T:Send+'rx> 
Handle			impl Handle 
Handle			pub struct Handle 
Handle			impl Handle 
Handle			pub struct Handle(RawHandle);
Handler			impl Handler 
Handler			pub struct Handler;
Handler			impl Handler 
Handler			pub struct Handler 
Handler			impl Handler 
Handler			pub struct Handler;
Hash for CodePoint			impl Hash for CodePoint 
Hash for OsStr			impl Hash for OsStr 
Hash for OsString			impl Hash for OsString 
Hash for Path			impl Hash for Path 
Hash for PathBuf			impl Hash for PathBuf 
Hash for PrefixComponent			impl<'a> Hash for PrefixComponent<'a> 
Hash for Wtf8			impl Hash for Wtf8 
Hash for Wtf8Buf			impl Hash for Wtf8Buf 
HashMap			impl<K, V, S> HashMap<K, V, S>
HashMap			impl<K: Hash + Eq, V> HashMap<K, V, RandomState> 
HashMap			pub struct HashMap<K, V, S = RandomState> 
HashSet			impl<T, S> HashSet<T, S>
HashSet			impl<T: Hash + Eq> HashSet<T, RandomState> 
HashSet			pub struct HashSet<T, S = RandomState> 
Hasher for DefaultHasher			impl Hasher for DefaultHasher 
Hook			enum Hook 
IMAGEHLP_LINE64			pub struct IMAGEHLP_LINE64 
Incoming			pub struct Incoming<'a> { listener: &'a TcpListener }
Incoming			pub struct Incoming<'a> 
Index for HashMap			impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>
InitializeCriticalSection			    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
Inner			struct Inner 
Inner			struct Inner 
Instant			impl Instant 
Instant			pub struct Instant 
Instant			    impl Instant 
Instant			    pub struct Instant 
Instant			impl Instant 
Instant			pub struct Instant 
Instant			impl Instant 
Instant			pub struct Instant(time::Instant);
InternalEntry			enum InternalEntry<K, V, M> 
InternalEntry			impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> 
InternalEntry			impl<K, V, M> InternalEntry<K, V, M> 
Intersection			pub struct Intersection<'a, T: 'a, S: 'a> 
IntoInner			impl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr 
IntoInner			impl IntoInner<Vec<u8>> for Buf 
IntoInner			impl IntoInner<Vec<u8>> for Buf 
IntoInner			pub trait IntoInner<Inner> 
IntoInner for Buf			impl IntoInner<Wtf8Buf> for Buf 
IntoInner for Child			impl IntoInner<imp::Process> for Child 
IntoInner for ChildStderr			impl IntoInner<AnonPipe> for ChildStderr 
IntoInner for ChildStdin			impl IntoInner<AnonPipe> for ChildStdin 
IntoInner for ChildStdout			impl IntoInner<AnonPipe> for ChildStdout 
IntoInner for File			impl IntoInner<fs_imp::File> for File 
IntoInner for JoinHandle			impl<T> IntoInner<imp::Thread> for JoinHandle<T> 
IntoInner for OsString			impl IntoInner<Buf> for OsString 
IntoInner for Socket			impl IntoInner<c_int> for Socket 
IntoInner for Socket			impl IntoInner<c::SOCKET> for Socket 
IntoInner for TcpListener			impl IntoInner<net_imp::TcpListener> for TcpListener 
IntoInner for TcpStream			impl IntoInner<net_imp::TcpStream> for TcpStream 
IntoInner for UdpSocket			impl IntoInner<net_imp::UdpSocket> for UdpSocket 
IntoInnerError			impl<W> IntoInnerError<W> 
IntoInnerError			pub struct IntoInnerError<W>(W, Error);
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<K> 
IntoIter			pub struct IntoIter<K, V> 
IntoIter			pub struct IntoIter<T> 
IntoIterator			impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>
IntoIterator			impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>
IntoIterator			impl<'a, T, S> IntoIterator for &'a HashSet<T, S>
IntoIterator			impl<'a> IntoIterator for &'a Path 
IntoIterator			impl<'a> IntoIterator for &'a PathBuf 
IntoIterator			impl<'a, T> IntoIterator for &'a Receiver<T> 
IntoIterator			impl<'a> IntoIterator for &'a UnixListener 
IntoIterator for HashMap			impl<K, V, S> IntoIterator for HashMap<K, V, S>
IntoIterator for HashSet			impl<T, S> IntoIterator for HashSet<T, S>
IntoIterator for Receiver			impl <T> IntoIterator for Receiver<T> 
IntoRawFd			pub trait IntoRawFd 
IntoRawFd			pub trait IntoRawFd 
IntoRawFd for UnixDatagram			impl IntoRawFd for UnixDatagram 
IntoRawFd for UnixListener			impl IntoRawFd for UnixListener 
IntoRawFd for UnixStream			impl IntoRawFd for UnixStream 
IntoRawFd for fs			impl IntoRawFd for fs::File 
IntoRawFd for fs			impl IntoRawFd for fs::File 
IntoRawFd for net			impl IntoRawFd for net::TcpListener 
IntoRawFd for net			impl IntoRawFd for net::TcpStream 
IntoRawFd for net			impl IntoRawFd for net::UdpSocket 
IntoRawFd for net			impl IntoRawFd for net::TcpListener 
IntoRawFd for net			impl IntoRawFd for net::TcpStream 
IntoRawFd for net			impl IntoRawFd for net::UdpSocket 
IntoRawFd for process			impl IntoRawFd for process::ChildStderr 
IntoRawFd for process			impl IntoRawFd for process::ChildStdin 
IntoRawFd for process			impl IntoRawFd for process::ChildStdout 
IntoRawFd for process			impl IntoRawFd for process::ChildStderr 
IntoRawFd for process			impl IntoRawFd for process::ChildStdin 
IntoRawFd for process			impl IntoRawFd for process::ChildStdout 
IntoRawHandle			pub trait IntoRawHandle 
IntoRawHandle for fs			impl IntoRawHandle for fs::File 
IntoRawHandle for process			impl IntoRawHandle for process::Child 
IntoRawHandle for process			impl IntoRawHandle for process::ChildStderr 
IntoRawHandle for process			impl IntoRawHandle for process::ChildStdin 
IntoRawHandle for process			impl IntoRawHandle for process::ChildStdout 
IntoRawHandle for thread			impl<T> IntoRawHandle for thread::JoinHandle<T>  
IntoRawSocket			pub trait IntoRawSocket 
IntoRawSocket for net			impl IntoRawSocket for net::TcpListener 
IntoRawSocket for net			impl IntoRawSocket for net::TcpStream 
IntoRawSocket for net			impl IntoRawSocket for net::UdpSocket 
IntoStringError			impl IntoStringError 
IntoStringError			pub struct IntoStringError 
IpAddr			impl IpAddr 
IpAddr			pub enum IpAddr 
Ipv4Addr			impl Ipv4Addr 
Ipv4Addr			pub struct Ipv4Addr 
Ipv6Addr			impl Ipv6Addr 
Ipv6Addr			pub struct Ipv6Addr 
Ipv6MulticastScope			pub enum Ipv6MulticastScope 
IsMinusOne			pub trait IsMinusOne 
IsMinusOne			pub trait IsMinusOne 
IsZero			pub trait IsZero 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			pub struct Iter<'a, K: 'a> 
Iter			pub struct Iter<'a, K: 'a, V: 'a> 
Iter			impl<'a> Iter<'a> 
Iter			pub struct Iter<'a> 
Iter			pub struct Iter<'a, T: 'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
IterMut			pub struct IterMut<'a, K: 'a, V: 'a> 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for Args			impl Iterator for Args 
Iterator for ArgsOs			impl Iterator for ArgsOs 
Iterator for Bytes			impl<R: Read> Iterator for Bytes<R> 
Iterator for Chars			impl<R: Read> Iterator for Chars<R> 
Iterator for Components			impl<'a> Iterator for Components<'a> 
Iterator for Difference			impl<'a, T, S> Iterator for Difference<'a, T, S>
Iterator for Drain			impl<'a, K, V> Iterator for Drain<'a, K, V> 
Iterator for Drain			impl<'a, K> Iterator for Drain<'a, K> 
Iterator for Drain			impl<'a, K, V> Iterator for Drain<'a, K, V> 
Iterator for EncodeWide			impl<'a> Iterator for EncodeWide<'a> 
Iterator for Env			impl Iterator for Env 
Iterator for Env			impl Iterator for Env 
Iterator for Env			impl Iterator for Env 
Iterator for EscapeDefault			impl Iterator for EscapeDefault 
Iterator for Incoming			impl<'a> Iterator for Incoming<'a> 
Iterator for Incoming			impl<'a> Iterator for Incoming<'a> 
Iterator for Intersection			impl<'a, T, S> Iterator for Intersection<'a, T, S>
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<K> Iterator for IntoIter<K> 
Iterator for IntoIter			impl<K, V> Iterator for IntoIter<K, V> 
Iterator for IntoIter			impl<T> Iterator for IntoIter<T> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a, K> Iterator for Iter<'a, K> 
Iterator for Iter			impl<'a, K, V> Iterator for Iter<'a, K, V> 
Iterator for Iter			impl<'a> Iterator for Iter<'a> 
Iterator for Iter			impl<'a, T> Iterator for Iter<'a, T> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for IterMut			impl<'a, K, V> Iterator for IterMut<'a, K, V> 
Iterator for Keys			impl<'a, K, V> Iterator for Keys<'a, K, V> 
Iterator for Lines			impl<B: BufRead> Iterator for Lines<B> 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for LookupHost			impl Iterator for LookupHost 
Iterator for Packets			impl Iterator for Packets 
Iterator for RawBuckets			impl<'a, K, V> Iterator for RawBuckets<'a, K, V> 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for ReadDir			impl Iterator for ReadDir 
Iterator for RevMoveBuckets			impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> 
Iterator for Split			impl<B: BufRead> Iterator for Split<B> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SplitPaths			impl<'a> Iterator for SplitPaths<'a> 
Iterator for SymmetricDifference			impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>
Iterator for TryIter			impl<'a, T> Iterator for TryIter<'a, T> 
Iterator for Union			impl<'a, T, S> Iterator for Union<'a, T, S>
Iterator for Values			impl<'a, K, V> Iterator for Values<'a, K, V> 
Iterator for ValuesMut			impl<'a, K, V> Iterator for ValuesMut<'a, K, V> 
Iterator for Vars			impl Iterator for Vars 
Iterator for VarsOs			impl Iterator for VarsOs 
Iterator for Wtf8CodePoints			impl<'a> Iterator for Wtf8CodePoints<'a> 
JoinHandle			impl<T> JoinHandle<T> 
JoinHandle			pub struct JoinHandle<T>(JoinInner<T>);
JoinHandleExt			pub trait JoinHandleExt 
JoinHandleExt for JoinHandle			impl<T> JoinHandleExt for JoinHandle<T> 
JoinInner			impl<T> JoinInner<T> 
JoinInner			struct JoinInner<T> 
JoinPathsError			pub struct JoinPathsError 
JoinPathsError			pub struct JoinPathsError;
JoinPathsError			pub struct JoinPathsError;
JoinPathsError			pub struct JoinPathsError;
Juju			        struct Juju;
KDHELP64			pub struct KDHELP64 
Key			impl<T> Key<T> 
Key			pub struct Key<T> 
Key			impl<T> Key<T> 
Key			pub struct Key<T> 
Key			impl Key 
Key			pub struct Key 
Key			    impl<T: 'static> Key<T> 
Key			    pub struct Key<T> 
Keys			pub struct Keys<'a, K: 'a, V: 'a> 
Kind			enum Kind 
LaunchpadDestructor			        struct LaunchpadDestructor(*mut launchpad_t);
Lazy			impl<T: Send + Sync + 'static> Lazy<T> 
Lazy			pub struct Lazy<T> 
LeaveCriticalSection			    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);
LineWriter			impl<W: Write> LineWriter<W> 
LineWriter			pub struct LineWriter<W: Write> 
Lines			pub struct Lines<B> 
LoadLibraryW			    pub fn LoadLibraryW(name: LPCWSTR) -> HMODULE;
LocalFree			    pub fn LocalFree(ptr: *mut c_void);
LocalKey			impl<T: 'static> LocalKey<T> 
LocalKey			pub struct LocalKey<T: 'static> 
LocalKeyState			pub enum LocalKeyState 
Location			impl<'a> Location<'a> 
Location			pub struct Location<'a> 
LookupHost			pub struct LookupHost(net_imp::LookupHost);
LookupHost			pub struct LookupHost(IntoIter<SocketAddr>);
LookupHost			pub struct LookupHost 
M128A			pub struct M128A 
MOUNT_POINT_REPARSE_BUFFER			pub struct MOUNT_POINT_REPARSE_BUFFER 
Maybe			enum Maybe<T> 
Message			enum Message<T> 
Metadata			impl Metadata 
Metadata			pub struct Metadata(fs_imp::FileAttr);
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt			pub trait MetadataExt 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for Metadata			impl MetadataExt for Metadata 
MetadataExt for fs			impl MetadataExt for fs::Metadata 
MetadataExt for fs			impl MetadataExt for fs::Metadata 
MoveFileExW			    pub fn MoveFileExW(lpExistingFileName: LPCWSTR,
Mul for Duration			impl Mul<u32> for Duration 
MulAssign for Duration			impl MulAssign<u32> for Duration 
Mutex			impl<T: ?Sized> Mutex<T> 
Mutex			impl<T> Mutex<T> 
Mutex			pub struct Mutex<T: ?Sized> 
Mutex			impl Mutex 
Mutex			pub struct Mutex 
Mutex			impl Mutex 
Mutex			pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }
Mutex			impl Mutex 
Mutex			pub struct Mutex 
Mutex			impl Mutex 
Mutex			pub struct Mutex(imp::Mutex);
MutexGuard			impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> 
MutexGuard			pub struct MutexGuard<'a, T: ?Sized + 'a> 
MyUpgrade			enum MyUpgrade<T> 
NetInt			trait NetInt 
NewThread			pub trait NewThread 
NoClose			impl NoClose 
NoClose			pub struct NoClose(Option<Handle>);
Node			impl<T> Node<T> 
Node			struct Node<T> 
Node			impl<T> Node<T> 
Node			struct Node<T> 
Node			struct Node 
NonCopy			    struct NonCopy(i32);
NonCopy			    struct NonCopy(i32);
NulError			impl NulError 
NulError			pub struct NulError(usize, Vec<u8>);
OVERLAPPED			pub struct OVERLAPPED 
OccupiedEntry			impl<'a, K, V> OccupiedEntry<'a, K, V> 
OccupiedEntry			pub struct OccupiedEntry<'a, K: 'a, V: 'a> 
Once			impl Once 
Once			pub struct Once 
OnceState			impl OnceState 
OnceState			pub struct OnceState 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions(fs_imp::OpenOptions);
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptions			impl OpenOptions 
OpenOptions			pub struct OpenOptions 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt			pub trait OpenOptionsExt 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenOptionsExt for OpenOptions			impl OpenOptionsExt for OpenOptions 
OpenProcessToken			    pub fn OpenProcessToken(ProcessHandle: HANDLE,
Ord for CStr			impl Ord for CStr 
Ord for Ipv4Addr			impl Ord for Ipv4Addr 
Ord for Ipv6Addr			impl Ord for Ipv6Addr 
Ord for OsStr			impl Ord for OsStr 
Ord for OsString			impl Ord for OsString 
Ord for SystemTime			impl Ord for SystemTime 
Ord for Timespec			impl Ord for Timespec 
Ord for Timespec			impl Ord for Timespec 
OsRng			impl OsRng 
OsRng			pub struct OsRng(sys::rand::OsRng);
OsRng			impl OsRng 
OsRng			pub struct OsRng;
OsRng			    impl OsRng 
OsRng			    pub struct OsRng 
OsRng			impl OsRng 
OsRng			pub struct OsRng 
OsRngInner			    enum OsRngInner 
OsStr			impl OsStr 
OsStr			pub struct OsStr 
OsStrExt			pub trait OsStrExt 
OsStrExt			pub trait OsStrExt 
OsStrExt			pub trait OsStrExt 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsStrExt for OsStr			impl OsStrExt for OsStr 
OsString			impl OsString 
OsString			pub struct OsString 
OsStringExt			pub trait OsStringExt 
OsStringExt			pub trait OsStringExt 
OsStringExt			pub trait OsStringExt 
OsStringExt for OsString			impl OsStringExt for OsString 
OsStringExt for OsString			impl OsStringExt for OsString 
OsStringExt for OsString			impl OsStringExt for OsString 
Output			pub struct Output 
Output			impl Output 
Output			pub enum Output 
PROCESS_INFORMATION			pub struct PROCESS_INFORMATION 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			pub trait Packet 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			impl<T> Packet<T> 
Packet			pub struct Packet<T> 
Packet			    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);
Packet			struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);
Packets			struct Packets { cur: *mut Handle<'static, ()> }
PanicInfo			impl<'a> PanicInfo<'a> 
PanicInfo			pub struct PanicInfo<'a> 
PanicWriter			        struct PanicWriter;
Parser			impl<'a> Parser<'a> 
Parser			struct Parser<'a> 
PartialEq			        impl<'a, 'b> PartialEq<
PartialEq			        impl<'a, 'b> PartialEq<
PartialEq			        impl<'a, 'b> PartialEq<
PartialEq			        impl<'a, 'b> PartialEq<
PartialEq for CStr			impl PartialEq for CStr 
PartialEq for Foo			        impl PartialEq for Foo 
PartialEq for HashMap			impl<K, V, S> PartialEq for HashMap<K, V, S>
PartialEq for HashSet			impl<T, S> PartialEq for HashSet<T, S>
PartialEq for Ipv4Addr			impl PartialEq for Ipv4Addr 
PartialEq for Ipv6Addr			impl PartialEq for Ipv6Addr 
PartialEq for OsStr			impl PartialEq for OsStr 
PartialEq for OsStr			impl PartialEq<str> for OsStr 
PartialEq for OsString			impl PartialEq for OsString 
PartialEq for OsString			impl PartialEq<str> for OsString 
PartialEq for SocketAddrV4			impl PartialEq for SocketAddrV4 
PartialEq for SocketAddrV6			impl PartialEq for SocketAddrV6 
PartialEq for SystemTime			impl PartialEq for SystemTime 
PartialEq for Timespec			impl PartialEq for Timespec 
PartialEq for Timespec			impl PartialEq for Timespec 
PartialEq for str			impl PartialEq<OsStr> for str 
PartialEq for str			impl PartialEq<OsString> for str 
PartialOrd			        impl<'a, 'b> PartialOrd<
PartialOrd			        impl<'a, 'b> PartialOrd<
PartialOrd			        impl<'a, 'b> PartialOrd<
PartialOrd			        impl<'a, 'b> PartialOrd<
PartialOrd for CStr			impl PartialOrd for CStr 
PartialOrd for Ipv4Addr			impl PartialOrd for Ipv4Addr 
PartialOrd for Ipv6Addr			impl PartialOrd for Ipv6Addr 
PartialOrd for OsStr			impl PartialOrd for OsStr 
PartialOrd for OsStr			impl PartialOrd<str> for OsStr 
PartialOrd for OsString			impl PartialOrd for OsString 
PartialOrd for OsString			impl PartialOrd<str> for OsString 
PartialOrd for SystemTime			impl PartialOrd for SystemTime 
PartialOrd for Timespec			impl PartialOrd for Timespec 
PartialOrd for Timespec			impl PartialOrd for Timespec 
Path			impl Path 
Path			pub struct Path 
PathBuf			impl PathBuf 
PathBuf			pub struct PathBuf 
Permissions			impl Permissions 
Permissions			pub struct Permissions(fs_imp::FilePermissions);
PermissionsExt			pub trait PermissionsExt 
PermissionsExt			pub trait PermissionsExt 
PermissionsExt for Permissions			impl PermissionsExt for Permissions 
PermissionsExt for Permissions			impl PermissionsExt for Permissions 
Pipes			pub struct Pipes 
PoisonError			impl<T> PoisonError<T> 
PoisonError			pub struct PoisonError<T> 
PopResult			pub enum PopResult<T> 
PositionReader			        struct PositionReader 
Prefix			impl<'a> Prefix<'a> 
Prefix			pub enum Prefix<'a> 
PrefixComponent			impl<'a> PrefixComponent<'a> 
PrefixComponent			pub struct PrefixComponent<'a> 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Process			impl Process 
Process			pub struct Process 
Put			impl<'t, K, V> Put<K, V> for &'t mut RawTable<K, V> 
Put			pub trait Put<K, V> 
Put for Bucket			impl<K, V, M> Put<K, V> for Bucket<K, V, M>
Put for FullBucket			impl<K, V, M> Put<K, V> for FullBucket<K, V, M>
QueryPerformanceCounter			    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER)
QueryPerformanceFrequency			    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;
Queue			impl<T> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl<T> Queue<T> 
Queue			pub struct Queue<T> 
Queue			impl Queue 
Queue			struct Queue 
R			        struct R;
R			impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> 
REPARSE_DATA_BUFFER			pub struct REPARSE_DATA_BUFFER 
REPARSE_MOUNTPOINT_DATA_BUFFER			pub struct REPARSE_MOUNTPOINT_DATA_BUFFER 
RWLock			impl RWLock 
RWLock			pub struct RWLock 
RWLock			impl RWLock 
RWLock			pub struct RWLock 
RWLock			impl RWLock 
RWLock			pub struct RWLock { inner: UnsafeCell<c::SRWLOCK> }
RWLock			impl RWLock 
RWLock			pub struct RWLock(imp::RWLock);
RandomState			impl RandomState 
RandomState			pub struct RandomState 
RawBucket			impl<K, V> RawBucket<K, V> 
RawBucket			struct RawBucket<K, V> 
RawBuckets			struct RawBuckets<'a, K, V> 
RawHandle			impl RawHandle 
RawHandle			pub struct RawHandle(c::HANDLE);
RawTable			impl<K, V> RawTable<K, V> 
RawTable			pub struct RawTable<K, V> 
Read			impl<'a> Read for &'a File 
Read			impl<'a, R: Read + ?Sized> Read for &'a mut R 
Read			impl<'a> Read for &'a [u8] 
Read			pub trait Read 
Read			impl<'a> Read for &'a TcpStream 
Read			impl<'a> Read for &'a FileDesc 
Read			impl<'a> Read for &'a FileDesc 
Read			impl<'a> Read for &'a RawHandle 
Read			impl<'a> Read for &'a Socket 
Read			impl<'a> Read for &'a Stdin 
Read for Box			impl<R: Read + ?Sized> Read for Box<R> 
Read for BufReader			impl<R: Read> Read for BufReader<R> 
Read for Chain			impl<T: Read, U: Read> Read for Chain<T, U> 
Read for ChildStderr			impl Read for ChildStderr 
Read for ChildStdout			impl Read for ChildStdout 
Read for Cursor			impl<T> Read for Cursor<T> where T: AsRef<[u8]> 
Read for Empty			impl Read for Empty 
Read for ErrorRepeat			    impl Read for ErrorRepeat 
Read for File			impl Read for File 
Read for PositionReader			        impl Read for PositionReader 
Read for R			        impl Read for R 
Read for Repeat			impl Read for Repeat 
Read for ShortReader			    impl Read for ShortReader 
Read for Stdin			impl Read for Stdin 
Read for StdinLock			impl<'a> Read for StdinLock<'a> 
Read for StdinRaw			impl Read for StdinRaw 
Read for Take			impl<T: Read> Read for Take<T> 
Read for TcpStream			impl Read for TcpStream 
ReadConsoleW			    pub fn ReadConsoleW(hConsoleInput: HANDLE,
ReadDir			pub struct ReadDir(fs_imp::ReadDir);
ReadDir			pub struct ReadDir 
ReadDir			pub struct ReadDir 
ReadDir			pub struct ReadDir 
ReadFile			    pub fn ReadFile(hFile: HANDLE,
ReaderRng			impl<R: Read> ReaderRng<R> 
ReaderRng			pub struct ReaderRng<R> 
Receiver			impl<T> Receiver<T> 
Receiver			pub struct Receiver<T> 
Recover			trait Recover<Q: ?Sized> 
RecvError			pub struct RecvError;
RecvTimeoutError			pub enum RecvTimeoutError 
ReentrantMutex			impl ReentrantMutex 
ReentrantMutex			pub struct ReentrantMutex 
ReentrantMutex			impl ReentrantMutex 
ReentrantMutex			pub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }
ReentrantMutex			impl ReentrantMutex 
ReentrantMutex			pub struct ReentrantMutex { inner: UnsafeCell<c::CRITICAL_SECTION> }
ReentrantMutex			impl<T> ReentrantMutex<T> 
ReentrantMutex			pub struct ReentrantMutex<T> 
ReentrantMutexGuard			impl<'mutex, T> ReentrantMutexGuard<'mutex, T> 
ReentrantMutexGuard			pub struct ReentrantMutexGuard<'a, T: 'a> 
RefUnwindSafe			impl RefUnwindSafe for .. {}
RefUnwindSafe			pub trait RefUnwindSafe {}
RefUnwindSafe for AssertUnwindSafe			impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}
RefUnwindSafe for Mutex			impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}
RefUnwindSafe for RwLock			impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicBool {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicI16 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicI32 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicI64 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicI8 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicIsize {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicU16 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicU32 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicU64 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicU8 {}
RefUnwindSafe for atomic			impl RefUnwindSafe for atomic::AtomicUsize {}
RefUnwindSafe for atomic			impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}
ReleaseSRWLockExclusive			    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) -> () 
ReleaseSRWLockShared			    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () 
RemoveDirectoryW			    pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;
Repeat			pub struct Repeat { byte: u8 }
Repr			enum Repr 
RevMoveBuckets			struct RevMoveBuckets<'a, K, V> 
Rng for OsRng			impl Rng for OsRng 
Rng for OsRng			impl Rng for OsRng 
Rng for OsRng			    impl Rng for OsRng 
Rng for OsRng			impl Rng for OsRng 
Rng for ReaderRng			impl<R: Read> Rng for ReaderRng<R> 
Rng for StdRng			impl Rng for StdRng 
Rng for ThreadRng			impl Rng for ThreadRng 
RtlCaptureContext			    pub fn RtlCaptureContext(ctx: *mut CONTEXT);
RwLock			impl<T: ?Sized> RwLock<T> 
RwLock			impl<T> RwLock<T> 
RwLock			pub struct RwLock<T: ?Sized> 
RwLockReadGuard			impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> 
RwLockReadGuard			pub struct RwLockReadGuard<'a, T: ?Sized + 'a> 
RwLockWriteGuard			impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> 
RwLockWriteGuard			pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> 
S1			        struct S1(Sender<()>);
S1			        struct S1;
S2			        struct S2;
SECURITY_ATTRIBUTES			pub struct SECURITY_ATTRIBUTES 
SOCKADDR			pub struct SOCKADDR 
SOCKADDR_STORAGE_LH			pub struct SOCKADDR_STORAGE_LH 
SRWLOCK			pub struct SRWLOCK { pub ptr: LPVOID }
STACKFRAME64			pub struct STACKFRAME64 
STARTUPINFO			pub struct STARTUPINFO 
SYMBOLIC_LINK_REPARSE_BUFFER			pub struct SYMBOLIC_LINK_REPARSE_BUFFER 
SYMBOL_INFO			pub struct SYMBOL_INFO 
SafeHash			impl SafeHash 
SafeHash			pub struct SafeHash 
SecRandom			    enum SecRandom {}
SecRandomCopyBytes			        fn SecRandomCopyBytes(rnd: *const SecRandom,
SeedableRng for StdRng			impl<'a> SeedableRng<&'a [usize]> for StdRng 
Seek			impl<'a> Seek for &'a File 
Seek			impl<'a, S: Seek + ?Sized> Seek for &'a mut S 
Seek			pub trait Seek 
Seek for Box			impl<S: Seek + ?Sized> Seek for Box<S> 
Seek for BufReader			impl<R: Seek> Seek for BufReader<R> 
Seek for BufWriter			impl<W: Write + Seek> Seek for BufWriter<W> 
Seek for File			impl Seek for File 
Seek for PositionReader			        impl Seek for PositionReader 
SeekFrom			pub enum SeekFrom 
Select			impl Select 
Select			pub struct Select 
SelectInner			struct SelectInner 
SelectionResult			pub enum SelectionResult<T> 
SelectionResult			pub enum SelectionResult<T> 
Send for Condvar			unsafe impl Send for Condvar {}
Send for Condvar			unsafe impl Send for Condvar {}
Send for Condvar			unsafe impl Send for Condvar {}
Send for Dir			unsafe impl Send for Dir {}
Send for Dir			unsafe impl Send for Dir {}
Send for Drain			unsafe impl<'a, K: Send, V: Send> Send for Drain<'a, K, V> {}
Send for FindNextFileHandle			unsafe impl Send for FindNextFileHandle {}
Send for Inner			unsafe impl Send for Inner {}
Send for IntoIter			unsafe impl<K: Send, V: Send> Send for IntoIter<K, V> {}
Send for Iter			unsafe impl<'a, K: Sync, V: Sync> Send for Iter<'a, K, V> {}
Send for IterMut			unsafe impl<'a, K: Send, V: Send> Send for IterMut<'a, K, V> {}
Send for LookupHost			unsafe impl Send for LookupHost {}
Send for Mutex			unsafe impl<T: ?Sized + Send> Send for Mutex<T> { }
Send for Mutex			unsafe impl Send for Mutex {}
Send for Mutex			unsafe impl Send for Mutex {}
Send for Mutex			unsafe impl Send for Mutex {}
Send for Node			unsafe impl Send for Node {}
Send for Once			unsafe impl Send for Once {}
Send for Packet			unsafe impl<T: Send> Send for Packet<T> { }
Send for Packet			    unsafe impl<T: Send> Send for Packet<T> {}
Send for Packet			unsafe impl<T: Send> Send for Packet<T> {}
Send for Queue			unsafe impl<T: Send> Send for Queue<T> { }
Send for Queue			unsafe impl<T: Send> Send for Queue<T> { }
Send for RWLock			unsafe impl Send for RWLock {}
Send for RWLock			unsafe impl Send for RWLock {}
Send for RWLock			unsafe impl Send for RWLock {}
Send for RawHandle			unsafe impl Send for RawHandle {}
Send for RawTable			unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}
Send for Receiver			unsafe impl<T: Send> Send for Receiver<T> { }
Send for ReentrantMutex			unsafe impl Send for ReentrantMutex {}
Send for ReentrantMutex			unsafe impl Send for ReentrantMutex {}
Send for ReentrantMutex			unsafe impl Send for ReentrantMutex {}
Send for ReentrantMutex			unsafe impl<T: Send> Send for ReentrantMutex<T> {}
Send for RwLock			unsafe impl<T: ?Sized + Send + Sync> Send for RwLock<T> {}
Send for Sender			unsafe impl<T: Send> Send for Sender<T> { }
Send for State			unsafe impl<T: Send> Send for State<T> {}
Send for SyncSender			unsafe impl<T: Send> Send for SyncSender<T> {}
Send for Thread			unsafe impl Send for Thread {}
Send for Thread			unsafe impl Send for Thread {}
SendError			pub struct SendError<T>(#[stable(feature = "rust1", since = "1.0.0")] pub T);
Sender			impl<T> Sender<T> 
Sender			pub struct Sender<T> 
SetCurrentDirectoryW			    pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;
SetEnvironmentVariableW			    pub fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR) -> BOOL;
SetFileAttributesW			    pub fn SetFileAttributesW(lpFileName: LPCWSTR,
SetFileInformationByHandle			    pub fn SetFileInformationByHandle(_hFile: HANDLE,
SetFilePointerEx			    pub fn SetFilePointerEx(hFile: HANDLE,
SetHandleInformation			    pub fn SetHandleInformation(hObject: HANDLE,
SetLastError			    pub fn SetLastError(dwErrCode: DWORD);
SetThreadStackGuarantee			    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL 
ShortReader			    pub struct ShortReader 
Shutdown			pub enum Shutdown 
SignalToken			impl SignalToken 
SignalToken			pub struct SignalToken 
Sink			pub struct Sink { _priv: () }
Sleep			    pub fn Sleep(dwMilliseconds: DWORD);
SleepConditionVariableSRW			    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,
Slice			impl Slice 
Slice			pub struct Slice 
Slice			impl Slice 
Slice			pub struct Slice 
Slice			impl Slice 
Slice			pub struct Slice 
Socket			impl Socket 
Socket			pub struct Socket(FileDesc);
Socket			impl Socket 
Socket			pub struct Socket(c::SOCKET);
SocketAddr			impl SocketAddr 
SocketAddr			pub enum SocketAddr 
SocketAddr			impl SocketAddr 
SocketAddr			pub struct SocketAddr 
SocketAddrV4			impl SocketAddrV4 
SocketAddrV4			pub struct SocketAddrV4 { inner: c::sockaddr_in }
SocketAddrV6			impl SocketAddrV6 
SocketAddrV6			pub struct SocketAddrV6 { inner: c::sockaddr_in6 }
Split			pub struct Split<B> 
SplitPaths			pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }
SplitPaths			pub struct SplitPaths<'a> 
SplitPaths			pub struct SplitPaths<'a> 
SplitPaths			pub struct SplitPaths<'a> 
StartResult			pub enum StartResult 
State			enum State 
State			struct State<T> 
State			enum State 
StaticKey			impl StaticKey 
StaticKey			pub struct StaticKey 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdError for JoinPathsError			impl StdError for JoinPathsError 
StdRng			impl StdRng 
StdRng			pub struct StdRng 
Stderr			impl Stderr 
Stderr			pub struct Stderr 
Stderr			impl Stderr 
Stderr			pub struct Stderr(());
Stderr			impl Stderr 
Stderr			pub struct Stderr(());
Stderr			impl Stderr 
Stderr			pub struct Stderr(Output);
StderrLock			pub struct StderrLock<'a> 
StderrRaw			struct StderrRaw(stdio::Stderr);
Stdin			impl Stdin 
Stdin			pub struct Stdin 
Stdin			impl Stdin 
Stdin			pub struct Stdin(());
Stdin			impl Stdin 
Stdin			pub struct Stdin(());
Stdin			impl Stdin 
Stdin			pub struct Stdin 
StdinLock			pub struct StdinLock<'a> 
StdinRaw			struct StdinRaw(stdio::Stdin);
Stdio			impl Stdio 
Stdio			pub struct Stdio(imp::Stdio);
Stdio			impl Stdio 
Stdio			pub enum Stdio 
Stdio			impl Stdio 
Stdio			pub enum Stdio 
Stdio			impl Stdio 
Stdio			pub enum Stdio 
StdioPipes			pub struct StdioPipes 
StdioPipes			pub struct StdioPipes 
StdioPipes			pub struct StdioPipes 
Stdout			impl Stdout 
Stdout			pub struct Stdout 
Stdout			impl Stdout 
Stdout			pub struct Stdout(());
Stdout			impl Stdout 
Stdout			pub struct Stdout(());
Stdout			impl Stdout 
Stdout			pub struct Stdout(Output);
StdoutLock			pub struct StdoutLock<'a> 
StdoutRaw			struct StdoutRaw(stdio::Stdout);
StringError			        struct StringError(String);
StripPrefixError			pub struct StripPrefixError(());
Sub			impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>
Sub for Duration			impl Sub for Duration 
Sub for Instant			impl Sub<Duration> for Instant 
Sub for Instant			impl Sub<Instant> for Instant 
Sub for SystemTime			impl Sub<Duration> for SystemTime 
SubAssign for Duration			impl SubAssign for Duration 
SubAssign for Instant			impl SubAssign<Duration> for Instant 
SubAssign for SystemTime			impl SubAssign<Duration> for SystemTime 
SwitchToThread			    pub fn SwitchToThread() -> BOOL;
SymmetricDifference			pub struct SymmetricDifference<'a, T: 'a, S: 'a> 
Sync for Condvar			unsafe impl Sync for Condvar {}
Sync for Condvar			unsafe impl Sync for Condvar {}
Sync for Condvar			unsafe impl Sync for Condvar {}
Sync for Dir			unsafe impl Sync for Dir {}
Sync for Dir			unsafe impl Sync for Dir {}
Sync for Drain			unsafe impl<'a, K: Sync, V: Sync> Sync for Drain<'a, K, V> {}
Sync for FindNextFileHandle			unsafe impl Sync for FindNextFileHandle {}
Sync for Inner			unsafe impl Sync for Inner {}
Sync for IntoIter			unsafe impl<K: Sync, V: Sync> Sync for IntoIter<K, V> {}
Sync for Iter			unsafe impl<'a, K: Sync, V: Sync> Sync for Iter<'a, K, V> {}
Sync for IterMut			unsafe impl<'a, K: Sync, V: Sync> Sync for IterMut<'a, K, V> {}
Sync for Lazy			unsafe impl<T> Sync for Lazy<T> {}
Sync for LookupHost			unsafe impl Sync for LookupHost {}
Sync for Mutex			unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Mutex			unsafe impl Sync for Mutex {}
Sync for Once			unsafe impl Sync for Once {}
Sync for Packet			unsafe impl<T: Send> Sync for Packet<T> { }
Sync for Packet			    unsafe impl<T> Sync for Packet<T> {}
Sync for Packet			unsafe impl<T: Sync> Sync for Packet<T> {}
Sync for Queue			unsafe impl<T: Send> Sync for Queue<T> { }
Sync for Queue			unsafe impl<T: Send> Sync for Queue<T> { }
Sync for RWLock			unsafe impl Sync for RWLock {}
Sync for RWLock			unsafe impl Sync for RWLock {}
Sync for RWLock			unsafe impl Sync for RWLock {}
Sync for RawHandle			unsafe impl Sync for RawHandle {}
Sync for RawTable			unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}
Sync for ReentrantMutex			unsafe impl Sync for ReentrantMutex {}
Sync for ReentrantMutex			unsafe impl Sync for ReentrantMutex {}
Sync for ReentrantMutex			unsafe impl Sync for ReentrantMutex {}
Sync for ReentrantMutex			unsafe impl<T: Send> Sync for ReentrantMutex<T> {}
Sync for RwLock			unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}
Sync for Thread			unsafe impl Sync for Thread {}
Sync for Thread			unsafe impl Sync for Thread {}
SyncSender			impl<T> SyncSender<T> 
SyncSender			pub struct SyncSender<T> 
SystemTime			impl SystemTime 
SystemTime			pub struct SystemTime 
SystemTime			    impl SystemTime 
SystemTime			    pub struct SystemTime 
SystemTime			impl SystemTime 
SystemTime			pub struct SystemTime 
SystemTime			impl SystemTime 
SystemTime			pub struct SystemTime(time::SystemTime);
SystemTimeError			impl SystemTimeError 
SystemTimeError			pub struct SystemTimeError(Duration);
Take			impl<T> Take<T> 
Take			pub struct Take<T> 
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener(net_imp::TcpListener);
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener(File);
TcpListener			impl TcpListener 
TcpListener			pub struct TcpListener 
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream(net_imp::TcpStream);
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream(File);
TcpStream			impl TcpStream 
TcpStream			pub struct TcpStream 
TempDir			    impl TempDir 
TempDir			    pub struct TempDir(PathBuf);
TerminateProcess			    pub fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;
TestError			        struct TestError;
Thread			impl Thread 
Thread			pub struct Thread 
Thread			impl Thread 
Thread			pub struct Thread 
Thread			impl Thread 
Thread			pub struct Thread 
Thread			impl Thread 
Thread			pub struct Thread 
ThreadId			impl ThreadId 
ThreadId			pub struct ThreadId(u64);
ThreadInfo			impl ThreadInfo 
ThreadInfo			struct ThreadInfo 
ThreadRng			pub struct ThreadRng 
ThreadRngReseeder			struct ThreadRngReseeder;
Timespec			impl Timespec 
Timespec			struct Timespec 
Timespec			impl Timespec 
Timespec			struct Timespec 
TlsAlloc			    pub fn TlsAlloc() -> DWORD;
TlsFree			    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
TlsGetValue			    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
TlsSetValue			    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;
ToOwned for CStr			impl ToOwned for CStr 
ToOwned for OsStr			impl ToOwned for OsStr 
ToOwned for Path			impl ToOwned for Path 
ToSocketAddrs			impl ToSocketAddrs for (IpAddr, u16) 
ToSocketAddrs			impl ToSocketAddrs for (Ipv4Addr, u16) 
ToSocketAddrs			impl ToSocketAddrs for (Ipv6Addr, u16) 
ToSocketAddrs			impl<'a, T: ToSocketAddrs + ?Sized> ToSocketAddrs for &'a T 
ToSocketAddrs			impl<'a> ToSocketAddrs for &'a [SocketAddr] 
ToSocketAddrs			impl<'a> ToSocketAddrs for (&'a str, u16) 
ToSocketAddrs			pub trait ToSocketAddrs 
ToSocketAddrs for SocketAddr			impl ToSocketAddrs for SocketAddr 
ToSocketAddrs for SocketAddrV4			impl ToSocketAddrs for SocketAddrV4 
ToSocketAddrs for SocketAddrV6			impl ToSocketAddrs for SocketAddrV6 
ToSocketAddrs for str			impl ToSocketAddrs for str 
TryAcquireSRWLockExclusive			    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN 
TryAcquireSRWLockShared			    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN 
TryEnterCriticalSection			    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;
TryIter			pub struct TryIter<'a, T: 'a> 
TryLockError			pub enum TryLockError<T> 
TryRecvError			pub enum TryRecvError 
TrySendError			pub enum TrySendError<T> 
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket(net_imp::UdpSocket);
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket(File, UnsafeCell<Option<SocketAddr>>);
UdpSocket			impl UdpSocket 
UdpSocket			pub struct UdpSocket 
Union			pub struct Union<'a, T: 'a, S: 'a> 
UnixDatagram			impl UnixDatagram 
UnixDatagram			pub struct UnixDatagram(Socket);
UnixListener			impl UnixListener 
UnixListener			pub struct UnixListener(Socket);
UnixStream			impl UnixStream 
UnixStream			pub struct UnixStream(Socket);
UnsafeFlavor			trait UnsafeFlavor<T> 
UnsafeFlavor for Receiver			impl<T> UnsafeFlavor<T> for Receiver<T> 
UnsafeFlavor for Sender			impl<T> UnsafeFlavor<T> for Sender<T> 
UnwindSafe			impl UnwindSafe for .. {}
UnwindSafe			impl<'a, T: RefUnwindSafe + ?Sized> UnwindSafe for &'a T {}
UnwindSafe			impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}
UnwindSafe			impl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}
UnwindSafe			pub trait UnwindSafe {}
UnwindSafe for Arc			impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Arc<T> {}
UnwindSafe for AssertUnwindSafe			impl<T> UnwindSafe for AssertUnwindSafe<T> {}
UnwindSafe for Mutex			impl<T: ?Sized> UnwindSafe for Mutex<T> {}
UnwindSafe for Rc			impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}
UnwindSafe for RwLock			impl<T: ?Sized> UnwindSafe for RwLock<T> {}
UnwindSafe for Shared			impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Shared<T> {}
UnwindSafe for Unique			impl<T: UnwindSafe> UnwindSafe for Unique<T> {}
Unwinder			            struct Unwinder 
Unwinder			            struct Unwinder 
UpgradeResult			pub enum UpgradeResult 
UpgradeResult			pub enum UpgradeResult 
VacantEntry			impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> 
VacantEntry			pub struct VacantEntry<'a, K: 'a, V: 'a> 
VacantEntryState			enum VacantEntryState<K, V, M> 
Value			    struct Value<T: 'static> 
Values			pub struct Values<'a, K: 'a, V: 'a> 
ValuesMut			pub struct ValuesMut<'a, K: 'a, V: 'a> 
VarError			pub enum VarError 
Vars			pub struct Vars { inner: VarsOs }
VarsOs			pub struct VarsOs { inner: os_imp::Env }
WIN32_FILE_ATTRIBUTE_DATA			pub struct WIN32_FILE_ATTRIBUTE_DATA 
WIN32_FIND_DATAW			pub struct WIN32_FIND_DATAW 
WSACleanup			    pub fn WSACleanup() -> c_int;
WSADATA			pub struct WSADATA 
WSADuplicateSocketW			    pub fn WSADuplicateSocketW(s: SOCKET,
WSAGetLastError			    pub fn WSAGetLastError() -> c_int;
WSAPROTOCOLCHAIN			pub struct WSAPROTOCOLCHAIN 
WSAPROTOCOL_INFO			pub struct WSAPROTOCOL_INFO 
WSASocketW			    pub fn WSASocketW(af: c_int,
WSAStartup			    pub fn WSAStartup(wVersionRequested: WORD,
WaitForDebugEvent			            fn WaitForDebugEvent(lpDebugEvent: *mut DEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;
WaitForMultipleObjects			    pub fn WaitForMultipleObjects(nCount: DWORD,
WaitForSingleObject			    pub fn WaitForSingleObject(hHandle: HANDLE,
WaitTimeoutResult			impl WaitTimeoutResult 
WaitTimeoutResult			pub struct WaitTimeoutResult(bool);
WaitToken			impl WaitToken 
WaitToken			pub struct WaitToken 
Waiter			struct Waiter 
WakeAllConditionVariable			    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE)
WakeConditionVariable			    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE)
Weak			impl<F> Weak<F> 
Weak			pub struct Weak<F> 
Write			impl<'a> Write for &'a File 
Write			impl<'a, W: Write + ?Sized> Write for &'a mut W 
Write			impl<'a> Write for &'a mut [u8] 
Write			pub trait Write 
Write			impl<'a> Write for &'a TcpStream 
Write for Box			impl<W: Write + ?Sized> Write for Box<W> 
Write for BufWriter			impl<W: Write> Write for BufWriter<W> 
Write for ChildStdin			impl Write for ChildStdin 
Write for Cursor			impl Write for Cursor<Box<[u8]>> 
Write for Cursor			impl Write for Cursor<Vec<u8>> 
Write for Cursor			impl<'a> Write for Cursor<&'a mut [u8]> 
Write for FailFlushWriter			        impl Write for FailFlushWriter 
Write for FailFlushWriter			        impl<'a> Write for FailFlushWriter<'a> 
Write for File			impl Write for File 
Write for LineWriter			impl<W: Write> Write for LineWriter<W> 
Write for PanicWriter			        impl Write for PanicWriter 
Write for Sink			impl Write for Sink 
Write for Stderr			impl Write for Stderr 
Write for StderrLock			impl<'a> Write for StderrLock<'a> 
Write for StderrRaw			impl Write for StderrRaw 
Write for Stdout			impl Write for Stdout 
Write for StdoutLock			impl<'a> Write for StdoutLock<'a> 
Write for StdoutRaw			impl Write for StdoutRaw 
Write for TcpStream			impl Write for TcpStream 
Write for Vec			impl Write for Vec<u8> 
WriteConsoleW			    pub fn WriteConsoleW(hConsoleOutput: HANDLE,
WriteFile			    pub fn WriteFile(hFile: HANDLE,
Wtf8			impl Wtf8 
Wtf8			pub struct Wtf8 
Wtf8Buf			impl Wtf8Buf 
Wtf8Buf			pub struct Wtf8Buf 
Wtf8CodePoints			pub struct Wtf8CodePoints<'a> 
_NSGetArgc			            fn _NSGetArgc() -> *mut libc::c_int;
_NSGetArgv			            fn _NSGetArgv() -> *mut *mut *mut libc::c_char;
_NSGetExecutablePath			        fn _NSGetExecutablePath(buf: *mut libc::c_char,
__getit			        fn __getit() -> 
__init			        fn __init() -> 
__rand			pub mod __rand 
__rust_maybe_catch_panic			    fn __rust_maybe_catch_panic(f: fn(*mut u8),
__rust_start_panic			    fn __rust_start_panic(data: usize, vtable: usize) -> u32;
_assert_both			    fn _assert_both<T: Send + Sync>() {}
_assert_error_is_sync_send			fn _assert_error_is_sync_send() 
_assert_send_sync			        fn _assert_send_sync<T: Send + Sync>() {}
_assert_send_sync			    fn _assert_send_sync() 
_assert_sync_and_send			fn _assert_sync_and_send() 
_create			    fn _create(&self, path: &Path) -> io::Result<()> 
_ends_with			    fn _ends_with(&self, child: &Path) -> bool 
_get_next_image_info			            fn _get_next_image_info(team_id: i32, cookie: *mut i32,
_is_sync_send			    fn _is_sync_send<T: Sync+Send>() {}
_join			    fn _join(&self, path: &Path) -> PathBuf 
_new			    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> 
_new			    fn _new(kind: ErrorKind, error: Box<error::Error+Send+Sync>) -> Error 
_open			    fn _open(&self, path: &Path) -> io::Result<File> 
_print			pub fn _print(args: fmt::Arguments) 
_push			    fn _push(&mut self, path: &Path) 
_remove_var			fn _remove_var(k: &OsStr) 
_set_extension			    fn _set_extension(&mut self, extension: &OsStr) -> bool 
_set_file_name			    fn _set_file_name(&mut self, file_name: &OsStr) 
_set_var			fn _set_var(k: &OsStr, v: &OsStr) 
_starts_with			    fn _starts_with(&self, base: &Path) -> bool 
_strip_prefix			    fn _strip_prefix<'a>(&'a self, base: &'a Path)
_tlv_atexit			        fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),
_var			fn _var(key: &OsStr) -> Result<String, VarError> 
_var_os			fn _var_os(key: &OsStr) -> Option<OsString> 
_with_extension			    fn _with_extension(&self, extension: &OsStr) -> PathBuf 
_with_file_name			    fn _with_file_name(&self, file_name: &OsStr) -> PathBuf 
_write			unsafe fn _write(w: &mut Write) -> io::Result<()> 
abort			pub fn abort() -> ! 
abort			pub fn abort(args: fmt::Arguments) -> ! 
abort_internal			pub unsafe fn abort_internal() -> ! 
abort_internal			pub unsafe fn abort_internal() -> ! 
abort_internal			pub unsafe fn abort_internal() -> ! 
abort_selection			    fn abort_selection(&self) -> bool 
abort_selection			    pub fn abort_selection(&self) -> Result<bool, Receiver<T>> 
abort_selection			    fn abort_selection(&self) -> bool;
abort_selection			    pub fn abort_selection(&self, _was_upgrade: bool) -> bool 
abort_selection			    pub fn abort_selection(&self,
abort_selection			    pub fn abort_selection(&self) -> bool 
abort_selection			fn abort_selection<'a, T>(guard: &mut MutexGuard<'a , State<T>>) -> bool 
abs			    pub fn abs(self) -> f32 { num::Float::abs(self) }
abs			    pub fn abs(self) -> f64 { num::Float::abs(self) }
abs_sub			    pub fn abs_sub(self, other: f32) -> f32 
abs_sub			     pub fn abs_sub(self, other: f64) -> f64 
abstract_namespace_not_allowed			    fn abstract_namespace_not_allowed() 
accept			    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> 
accept			    pub fn accept(&self) -> Result<(TcpStream, SocketAddr)> 
accept			    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> 
accept			    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)
accept			    pub fn accept(socket: SOCKET,
accept			    pub fn accept(&self, storage: *mut c::SOCKADDR,
accept			    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> 
accept4			                fn accept4(c_int, *mut sockaddr, *mut socklen_t, c_int) -> c_int
access_mode			    fn access_mode(&mut self, access: u32) -> &mut OpenOptions 
access_mode			    fn access_mode(&mut self, access: u32) -> &mut Self;
access_mode			    pub fn access_mode(&mut self, access_mode: u32) { self.access_mode = Some(access_mode); }
accessed			    pub fn accessed(&self) -> io::Result<SystemTime> 
accessed			    pub fn accessed(&self) -> io::Result<SystemTime> 
accessed			    pub fn accessed(&self) -> io::Result<SystemTime> 
accessed			    pub fn accessed(&self) -> io::Result<SystemTime> 
accessed_u64			    pub fn accessed_u64(&self) -> u64 
acos			    pub fn acos(self) -> f32 
acos			        pub fn acos(n: c_double) -> c_double;
acos			    pub fn acos(self) -> f64 
acosf			        pub fn acosf(n: c_float) -> c_float;
acosf			        pub unsafe fn acosf(n: c_float) -> c_float 
acosh			    pub fn acosh(self) -> f32 
acosh			    pub fn acosh(self) -> f64 
acquire_send_slot			    fn acquire_send_slot(&self) -> MutexGuard<State<T>> 
add			    pub unsafe fn add(&mut self) 
add			    fn add() 
add			    fn add(self, rhs: Duration) -> Duration 
add			    fn add(self, dur: Duration) -> SystemTime 
add			    fn add(self, other: Duration) -> Instant 
add_assign			    fn add_assign(&mut self, rhs: Duration) 
add_assign			    fn add_assign(&mut self, other: Duration) 
add_duration			    fn add_duration(&self, other: &Duration) -> Timespec 
add_duration			    pub fn add_duration(&self, other: &Duration) -> Instant 
add_duration			    pub fn add_duration(&self, other: &Duration) -> SystemTime 
add_duration			        pub fn add_duration(&self, other: &Duration) -> Instant 
add_duration			        pub fn add_duration(&self, other: &Duration) -> SystemTime 
add_duration			    fn add_duration(&self, other: &Duration) -> Timespec 
add_duration			    pub fn add_duration(&self, other: &Duration) -> Instant 
add_duration			    pub fn add_duration(&self, other: &Duration) -> SystemTime 
addr			mod addr;
address			    fn address<'a>(&'a self) -> AddressKind<'a> 
alloc			    unsafe fn alloc(&self) -> *mut Node<T> 
android			pub mod android;
anon_pipe			pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> 
anon_pipe			pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> 
anon_pipe			pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> 
answer			mod answer;
append			    pub fn append(&mut self, append: bool) -> &mut OpenOptions 
append			    pub fn append(&mut self, append: bool) { self.append = append; }
append			    pub fn append(&mut self, append: bool) { self.append = append; }
append			    pub fn append(&mut self, append: bool) { self.append = append; }
append_arg			    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) -> io::Result<()> 
append_to_string			fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>
arch			mod arch 
arch			mod arch 
arch			mod arch 
arch			mod arch 
arg			    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command 
arg			    pub fn arg(&mut self, arg: &OsStr) 
arg			    pub fn arg(&mut self, arg: &OsStr) 
arg			    pub fn arg(&mut self, arg: &OsStr) 
args			pub fn args() -> Args 
args			    pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command 
args			    pub fn args() -> Args 
args			pub fn args() -> Args 
args			pub mod args;
args			    pub fn args() -> Args 
args			pub fn args() -> Args 
args			pub mod args;
args			pub fn args() -> Args 
args			pub mod args;
args_os			pub fn args_os() -> ArgsOs 
as_bytes			    pub fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8];
as_bytes			    pub fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8] 
as_bytes			    fn as_bytes(&self) -> &[u8];
as_bytes_with_nul			    pub fn as_bytes_with_nul(&self) -> &[u8] 
as_inner			    fn as_inner(&self) -> &Slice 
as_inner			    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::File { &self.inner }
as_inner			    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }
as_inner			    fn as_inner(&self) -> &fs_imp::FileType { &self.0 }
as_inner			    fn as_inner(&self) -> &c::in6_addr { &self.inner }
as_inner			    fn as_inner(&self) -> &c::in_addr { &self.inner }
as_inner			    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }
as_inner			    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }
as_inner			    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }
as_inner			    fn as_inner(&self) -> &AnonPipe { &self.inner }
as_inner			    fn as_inner(&self) -> &imp::Command { &self.inner }
as_inner			    fn as_inner(&self) -> &imp::ExitStatus { &self.0 }
as_inner			    fn as_inner(&self) -> &imp::Process { &self.handle }
as_inner			    fn as_inner(&self) -> &usize { &self.fd }
as_inner			    fn as_inner(&self) -> &syscall::Stat { &self.stat }
as_inner			    fn as_inner(&self) -> &[u8] 
as_inner			    fn as_inner(&self) -> &c_int { &self.fd }
as_inner			    fn as_inner(&self) -> &stat64 { &self.stat }
as_inner			    fn as_inner(&self) -> &c_int { self.0.as_inner() }
as_inner			    fn as_inner(&self) -> &[u8] 
as_inner			    fn as_inner(&self) -> &c::SOCKET { &self.0 }
as_inner			    fn as_inner(&self) -> &Wtf8 
as_inner			    fn as_inner(&self) -> &Inner;
as_inner			    fn as_inner(&self) -> &[u8] { &self.bytes }
as_inner			    fn as_inner(&self) -> &imp::Thread { self.0.native.as_ref().unwrap() }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut fs_imp::DirBuilder 
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }
as_inner_mut			    fn as_inner_mut(&mut self) -> &mut Inner;
as_mut_vec			    fn as_mut_vec(&mut self) -> &mut Vec<u8> 
as_os_str			    pub fn as_os_str(&self) -> &OsStr 
as_os_str			    pub fn as_os_str(&self) -> &'a OsStr 
as_os_str			    pub fn as_os_str(&self) -> &OsStr 
as_os_str			    pub fn as_os_str(self) -> &'a OsStr 
as_path			    pub fn as_path(&self) -> &'a Path 
as_path			    pub fn as_path(&self) -> &Path 
as_pathname			    pub fn as_pathname(&self) -> Option<&Path> 
as_pthread_t			    fn as_pthread_t(&self) -> RawPthread 
as_pthread_t			    fn as_pthread_t(&self) -> RawPthread;
as_ptr			    pub fn as_ptr(&self) -> *const c_char 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd;
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd;
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_fd			    fn as_raw_fd(&self) -> RawFd 
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle 
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle;
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle 
as_raw_handle			    fn as_raw_handle(&self) -> RawHandle 
as_raw_socket			    fn as_raw_socket(&self) -> RawSocket 
as_raw_socket			    fn as_raw_socket(&self) -> RawSocket;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat 
as_raw_stat			    fn as_raw_stat(&self) -> &raw::stat;
as_ref			    fn as_ref(&self) -> &CStr 
as_ref			    fn as_ref(&self) -> &OsStr 
as_ref			    fn as_ref(&self) -> &OsStr 
as_ref			    fn as_ref(&self) -> &Path 
as_secs			    pub fn as_secs(&self) -> u64 { self.secs }
as_slice			    pub fn as_slice(&self) -> &Slice 
as_slice			    pub fn as_slice(&self) -> &Slice 
as_slice			    pub fn as_slice(&self) -> &Slice 
as_slice			    pub fn as_slice(&self) -> &Wtf8 
as_str			    fn as_str(&self) -> &'static str 
as_str			    pub fn as_str(&self) -> Option<&str> 
as_u8_slice			    fn as_u8_slice(&self) -> &[u8] 
ascii			pub mod ascii;
ascii_byte_at			    pub fn ascii_byte_at(&self, position: usize) -> u8 
asin			    pub fn asin(self) -> f32 
asin			        pub fn asin(n: c_double) -> c_double;
asin			    pub fn asin(self) -> f64 
asinf			        pub fn asinf(n: c_float) -> c_float;
asinf			        pub unsafe fn asinf(n: c_float) -> c_float 
asinh			    pub fn asinh(self) -> f32 
asinh			    pub fn asinh(self) -> f64 
assert_all_eq			    fn assert_all_eq(buf: &[u8], value: u8) 
assert_covariance			fn assert_covariance() 
assert_covariance			fn assert_covariance() 
assert_send			    fn assert_send<T: Send>() {}
assert_sync			    fn assert_sync<T: Sync>() {}
at_exit			pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> 
at_exit_imp			pub mod at_exit_imp;
at_index			    pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> 
atan			    pub fn atan(self) -> f32 
atan			        pub fn atan(n: c_double) -> c_double;
atan			    pub fn atan(self) -> f64 
atan2			    pub fn atan2(self, other: f32) -> f32 
atan2			        pub fn atan2(a: c_double, b: c_double) -> c_double;
atan2			    pub fn atan2(self, other: f64) -> f64 
atan2f			        pub fn atan2f(a: c_float, b: c_float) -> c_float;
atan2f			        pub unsafe fn atan2f(n: c_float, b: c_float) -> c_float 
atanf			        pub fn atanf(n: c_float) -> c_float;
atanf			        pub unsafe fn atanf(n: c_float) -> c_float 
atanh			    pub fn atanh(self) -> f32 
atanh			    pub fn atanh(self) -> f64 
atime			    fn atime(&self) -> i64 
atime			    fn atime(&self) -> i64;
atime			    fn atime(&self) -> i64 { self.st_atime() }
atime			    fn atime(&self) -> i64;
atime_nsec			    fn atime_nsec(&self) -> i64 
atime_nsec			    fn atime_nsec(&self) -> i64;
atime_nsec			    fn atime_nsec(&self) -> i64 { self.st_atime_nsec() }
atime_nsec			    fn atime_nsec(&self) -> i64;
attributes			    fn attributes(&mut self, attributes: u32) -> &mut OpenOptions 
attributes			    fn attributes(&mut self, val: u32) -> &mut Self;
attributes			    pub fn attributes(&mut self, attrs: u32) { self.attributes = attrs; }
attrs			    pub fn attrs(&self) -> u32 { self.attributes as u32 }
avoid_copying_the_body			    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Box<Fn() + Send>) 
backtrace			pub mod backtrace;
backtrace			        fn backtrace(buf: *mut *mut libc::c_void,
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace			pub mod backtrace;
backtrace_create_state			        fn backtrace_create_state(filename: *const libc::c_char,
backtrace_pcinfo			        fn backtrace_pcinfo(state: *mut backtrace_state,
backtrace_state			    enum backtrace_state {}
backtrace_syminfo			        fn backtrace_syminfo(state: *mut backtrace_state,
barrier			mod barrier;
base_port			fn base_port() -> u16 
basic			    fn basic() 
before_exec			    fn before_exec<F>(&mut self, f: F) -> &mut process::Command
before_exec			    pub fn before_exec(&mut self,
before_exec			    fn before_exec<F>(&mut self, f: F) -> &mut process::Command
before_exec			    pub fn before_exec(&mut self,
begin_panic			pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! 
begin_panic_fmt			pub fn begin_panic_fmt(msg: &fmt::Arguments,
bench			mod bench;
bench			mod bench 
bench_buffered_reader			    fn bench_buffered_reader(b: &mut test::Bencher) 
bench_buffered_writer			    fn bench_buffered_writer(b: &mut test::Bencher) 
bench_pow_function			    fn bench_pow_function(b: &mut Bencher) 
bench_read_slice			    fn bench_read_slice(b: &mut test::Bencher) 
bench_read_to_end			    fn bench_read_to_end(b: &mut test::Bencher) 
bench_read_vec			    fn bench_read_vec(b: &mut test::Bencher) 
bench_uninitialized			    fn bench_uninitialized(b: &mut ::test::Bencher) 
bench_write_slice			    fn bench_write_slice(b: &mut test::Bencher) 
bench_write_vec			    fn bench_write_vec(b: &mut test::Bencher) 
binary_file			    fn binary_file() 
bind			    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> 
bind			    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> 
bind			    pub fn bind(addr: &SocketAddr) -> Result<TcpListener> 
bind			    pub fn bind(addr: &SocketAddr) -> Result<UdpSocket> 
bind			    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> 
bind			    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> 
bind			    pub fn bind(socket: SOCKET, address: *const SOCKADDR,
bind			    pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> 
bind			    pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> 
bind_error			    fn bind_error() 
bind_error			    fn bind_error() 
bitand			    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
bitor			    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
bitxor			    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
blksize			    fn blksize(&self) -> u64 { self.st_blksize() }
blksize			    fn blksize(&self) -> u64;
blocking			mod blocking;
blocks			    fn blocks(&self) -> u64 { self.st_blocks() }
blocks			    fn blocks(&self) -> u64;
borrow			    fn borrow(&self) -> &CStr { self }
borrow			    fn borrow(&self) -> &OsStr { &self[..] }
borrow			    fn borrow(&self) -> &Path 
borrow			    pub fn borrow(&self) -> LockResult<Guard> 
borrow_table_mut			    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> 
borrow_table_mut			    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V>;
borrowed			    fn borrowed() 
both_ready			    fn both_ready() 
broadcast			    pub fn broadcast(&self) -> io::Result<bool> 
broadcast			    pub fn broadcast(&self) -> Result<bool> 
broadcast			    pub fn broadcast(&self) -> io::Result<bool> 
buffered			mod buffered;
build_hasher			    fn build_hasher(&self) -> DefaultHasher 
build_libbacktrace			fn build_libbacktrace(host: &str, target: &str) 
build_with_zero1			    fn build_with_zero1() 
build_with_zero2			    fn build_with_zero2() 
build_with_zero3			    fn build_with_zero3() 
builtin			pub mod builtin 
bump			    fn bump(&self, amt: isize) -> isize 
bump			    fn bump(&self, amt: isize) -> isize 
by_ref			    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }
bytes			    fn bytes(&self) -> &[u8] 
bytes			    fn bytes(self) -> Bytes<Self> where Self: Sized 
bytes_to_path			    fn bytes_to_path(b: &[u8]) -> PathBuf 
bytes_to_path			    fn bytes_to_path(b: &[u8]) -> PathBuf 
c			        fn c<T: Clone>(t: &T) -> T { t.clone() }
c			pub mod c;
c			            fn c(value: &u32) -> CodePoint { CodePoint::from_u32(*value).unwrap() }
c			        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }
c_str			mod c_str;
c_to_rust			    fn c_to_rust() 
c_void			pub enum c_void 
calculate_allocation			fn calculate_allocation(hash_size: usize,
calculate_offsets			fn calculate_offsets(hashes_size: usize,
call_inner			    fn call_inner(&'static self,
call_once			    extern "rust-call" fn call_once(self, _args: ()) -> R 
call_once			    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() 
call_once_force			    pub fn call_once_force<F>(&'static self, f: F) where F: FnOnce(&OnceState) 
can_alias_safehash_as_hash			fn can_alias_safehash_as_hash() 
can_recv			    fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&self) -> Result<bool, Receiver<T>> 
can_recv			    fn can_recv(&self) -> bool;
can_recv			    pub fn can_recv(&self) -> bool 
can_recv			    pub fn can_recv(&self) -> Result<bool, Receiver<T>> 
can_recv			    pub fn can_recv(&self) -> bool 
cancel_io			    pub fn cancel_io(&self) -> io::Result<()> 
cannot			                         enum cannot be exhaustively matched against",
canonicalize			pub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> 
canonicalize			    pub fn canonicalize(&self) -> io::Result<PathBuf> 
canonicalize			pub fn canonicalize(p: &Path) -> io::Result<PathBuf> 
canonicalize			pub fn canonicalize(p: &Path) -> io::Result<PathBuf> 
canonicalize			pub fn canonicalize(p: &Path) -> io::Result<PathBuf> 
canonicalize_works_simple			    fn canonicalize_works_simple() 
cap			    fn cap(&self) -> usize { self.buf.len() }
capacity			    fn capacity(&self, raw_cap: usize) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
capacity			    pub fn capacity(&self) -> usize 
cast_from_usize			    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken 
cast_to_usize			    pub unsafe fn cast_to_usize(self) -> usize 
catch_unwind			pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> 
cause			    fn cause(&self) -> Option<&Error> { None }
cause			    fn cause(&self) -> Option<&Error> 
cause			    fn cause(&self) -> Option<&Error> 
cause			    fn cause(&self) -> Option<&error::Error> 
cause			    fn cause(&self) -> Option<&std_error::Error> 
cause			    fn cause(&self) -> Option<&error::Error> 
cause			    fn cause(&self) -> Option<&Error> 
cbrt			    pub fn cbrt(self) -> f32 
cbrt			        pub fn cbrt(n: c_double) -> c_double;
cbrt			    pub fn cbrt(self) -> f64 
cbrtf			        pub fn cbrtf(n: c_float) -> c_float;
ceil			    pub fn ceil(self) -> f32 
ceil			    pub fn ceil(self) -> f64 
chain			    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized 
chain_bufread			    fn chain_bufread() 
chain_zero_length_read_is_not_eof			    fn chain_zero_length_read_is_not_eof() 
chan_gone_concurrent			    fn chan_gone_concurrent() 
channel			pub fn channel<T>() -> (Sender<T>, Receiver<T>) 
chars			    fn chars(self) -> Chars<Self> where Self: Sized 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
chdir			pub fn chdir(p: &path::Path) -> io::Result<()> 
check			        fn check(m: &HashMap<isize, ()>) 
check			        fn check(octets: &[u8; 4], unspec: bool, loopback: bool,
check			        fn check(str_addr: &str, octets: &[u8; 16], unspec: bool, loopback: bool,
check4			        fn check4(octets: &[u8; 4], unspec: bool, loopback: bool,
check6			        fn check6(str_addr: &str, unspec: bool, loopback: bool,
check_parse			        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool 
checked_add			    fn checked_add() 
checked_add			    pub fn checked_add(self, rhs: Duration) -> Option<Duration> 
checked_div			    fn checked_div() 
checked_div			    pub fn checked_div(self, rhs: u32) -> Option<Duration> 
checked_mul			    fn checked_mul() 
checked_mul			    pub fn checked_mul(self, rhs: u32) -> Option<Duration> 
checked_sub			    fn checked_sub() 
checked_sub			    pub fn checked_sub(self, rhs: Duration) -> Option<Duration> 
child_no			        fn child_no(x: u32) -> Box<Fn() + Send> 
chmod_works			    fn chmod_works() 
circular			    fn circular() 
classify			    pub fn classify(self) -> FpCategory { num::Float::classify(self) }
classify			    pub fn classify(self) -> FpCategory { num::Float::classify(self) }
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { imp::cleanup() }
cleanup			pub unsafe fn cleanup() 
cleanup			    pub fn cleanup() 
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { imp::cleanup() }
cleanup			    pub unsafe fn cleanup() 
cleanup			pub unsafe fn cleanup() { }
cleanup			pub unsafe fn cleanup() {}
cleanup			pub fn cleanup() 
cleanup			pub fn cleanup() 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clear			    pub fn clear(&mut self) 
clone			        fn clone(&self) -> Dropable 
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> Keys<'a, K, V> 
clone			    fn clone(&self) -> Values<'a, K, V> 
clone			    fn clone(&self) -> Difference<'a, T, S> 
clone			    fn clone(&self) -> Intersection<'a, T, S> 
clone			    fn clone(&self) -> Iter<'a, K> 
clone			    fn clone(&self) -> SymmetricDifference<'a, T, S> 
clone			    fn clone(&self) -> Union<'a, T, S> 
clone			    fn clone(&self) -> Bucket<K, V, M> 
clone			    fn clone(&self) -> Iter<'a, K, V> 
clone			    fn clone(&self) -> RawBucket<K, V> 
clone			    fn clone(&self) -> RawBuckets<'a, K, V> 
clone			    fn clone(&self) -> RawTable<K, V> 
clone			    fn clone(&self) -> SocketAddrV4 { *self }
clone			    fn clone(&self) -> SocketAddrV6 { *self }
clone			    fn clone(&self) -> Ipv4Addr { *self }
clone			    fn clone(&self) -> Ipv6Addr { *self }
clone			    fn clone(&self) -> Sender<T> 
clone			    fn clone(&self) -> SyncSender<T> 
clone			    fn clone() -> Option<Vec<Vec<u8>>> 
clone			    fn clone() -> Option<Vec<Vec<u8>>> 
clone			    fn clone(&self) -> Self { *self }
clone_accept_concurrent			    fn clone_accept_concurrent() 
clone_accept_smoke			    fn clone_accept_smoke() 
clone_chan			    pub fn clone_chan(&self) 
clone_chan			    pub fn clone_chan(&self) 
clone_while_reading			    fn clone_while_reading() 
cloning			    fn cloning() 
cloning2			    fn cloning2() 
cloning3			    fn cloning3() 
close_read_wakes_up			    fn close_read_wakes_up() 
close_readwrite_smoke			    fn close_readwrite_smoke() 
closed			    fn closed() 
closesocket			    pub fn closesocket(socket: SOCKET) -> c_int;
cmath			mod cmath 
cmath			mod cmath 
cmp			    fn cmp(&self, other: &CStr) -> Ordering 
cmp			    fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }
cmp			    fn cmp(&self, other: &OsString) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Ipv4Addr) -> Ordering 
cmp			    fn cmp(&self, other: &Ipv6Addr) -> Ordering 
cmp			    fn cmp(&self, other: &Components<'a>) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Path) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &PathBuf) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &PrefixComponent<'a>) -> cmp::Ordering 
cmp			    fn cmp(&self, other: &Timespec) -> Ordering 
cmp			    fn cmp(&self, other: &Timespec) -> Ordering 
cmp			    fn cmp(&self, other: &SystemTime) -> Ordering 
cmp::Eq for Components			impl<'a> cmp::Eq for Components<'a> {}
cmp::Eq for Path			impl cmp::Eq for Path {}
cmp::Eq for PathBuf			impl cmp::Eq for PathBuf {}
cmp::Ord for Components			impl<'a> cmp::Ord for Components<'a> 
cmp::Ord for Path			impl cmp::Ord for Path 
cmp::Ord for PathBuf			impl cmp::Ord for PathBuf 
cmp::Ord for PrefixComponent			impl<'a> cmp::Ord for PrefixComponent<'a> 
cmp::PartialEq for Components			impl<'a> cmp::PartialEq for Components<'a> 
cmp::PartialEq for Path			impl cmp::PartialEq for Path 
cmp::PartialEq for PathBuf			impl cmp::PartialEq for PathBuf 
cmp::PartialEq for PrefixComponent			impl<'a> cmp::PartialEq for PrefixComponent<'a> 
cmp::PartialOrd for Components			impl<'a> cmp::PartialOrd for Components<'a> 
cmp::PartialOrd for Path			impl cmp::PartialOrd for Path 
cmp::PartialOrd for PathBuf			impl cmp::PartialOrd for PathBuf 
cmp::PartialOrd for PrefixComponent			impl<'a> cmp::PartialOrd for PrefixComponent<'a> 
cmp_bufread			    fn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) 
cname			    fn cname(&self) -> Option<&CStr> 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code			    pub fn code(&self) -> Option<i32> 
code_point_from_char			    fn code_point_from_char() 
code_point_from_u32			    fn code_point_from_u32() 
code_point_to_char			    fn code_point_to_char() 
code_point_to_char_lossy			    fn code_point_to_char_lossy() 
code_point_to_string			    fn code_point_to_string() 
code_point_to_u32			    fn code_point_to_u32() 
code_points			    pub fn code_points(&self) -> Wtf8CodePoints 
collections			pub mod collections;
combine			         fn combine(arr: &[u8]) -> i32 
combine			        fn combine(arr: &[u8]) -> i32 
compile			    pub fn compile(&self) -> Vec<u8> 
components			    pub fn components(&self) -> Components 
condvar			mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
condvar			pub mod condvar;
connect			        fn connect(i: usize, addr: SocketAddr) 
connect			    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> 
connect			    pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> 
connect			    pub fn connect(addr: &SocketAddr) -> Result<TcpStream> 
connect			    pub fn connect(&self, addr: &SocketAddr) -> Result<()> 
connect			    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> 
connect			    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> 
connect			    pub fn connect(socket: SOCKET, address: *const SOCKADDR, len: c_int)
connect			    pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> 
connect			    pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> 
connect_error			    fn connect_error() 
connect_loopback			    fn connect_loopback() 
connect_send_recv			    fn connect_send_recv() 
consts			pub mod consts 
consume			    fn consume(&mut self, amt: usize) 
consume			    fn consume(&mut self, amt: usize) { self.pos += amt as u64; }
consume			    fn consume(&mut self, amt: usize) { (**self).consume(amt) }
consume			    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }
consume			            fn consume(&mut self, _amt: usize) { }
consume			    fn consume(&mut self, amt: usize) 
consume			    fn consume(&mut self, amt: usize);
consume			    fn consume(&mut self, n: usize) { self.inner.consume(n) }
consume			    fn consume(&mut self, _n: usize) {}
contains			    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
contains_key			    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool
contains_zero_byte			    fn contains_zero_byte(x: usize) -> bool 
copy			pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> 
copy			pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>
copy			pub fn copy(from: &Path, to: &Path) -> io::Result<u64> 
copy			pub fn copy(from: &Path, to: &Path) -> io::Result<u64> 
copy			pub fn copy(from: &Path, to: &Path) -> io::Result<u64> 
copy_copies			    fn copy_copies() 
copy_file_does_not_exist			    fn copy_file_does_not_exist() 
copy_file_dst_dir			    fn copy_file_dst_dir() 
copy_file_dst_exists			    fn copy_file_dst_exists() 
copy_file_ok			    fn copy_file_ok() 
copy_file_preserves_perm_bits			    fn copy_file_preserves_perm_bits() 
copy_file_preserves_streams			    fn copy_file_preserves_streams() 
copy_file_src_dir			    fn copy_file_src_dir() 
copy_src_does_not_exist			    fn copy_src_does_not_exist() 
cos			    pub fn cos(self) -> f32 
cos			    pub fn cos(self) -> f64 
cosh			    pub fn cosh(self) -> f32 
cosh			        pub fn cosh(n: c_double) -> c_double;
cosh			    pub fn cosh(self) -> f64 
coshf			        pub fn coshf(n: c_float) -> c_float;
coshf			        pub unsafe fn coshf(n: c_float) -> c_float 
cp			        fn cp(string: &Wtf8Buf) -> Vec<Option<char>> 
create			    pub fn create(&mut self, create: bool) -> &mut OpenOptions 
create			    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> 
create			    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> 
create			    pub fn create(&mut self, create: bool) { self.create = create; }
create			pub unsafe fn create(dtor: Option<Dtor>) -> Key 
create			    pub fn create(&mut self, create: bool) { self.create = create; }
create			pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
create			    pub fn create(&mut self, create: bool) { self.create = create; }
create			pub unsafe fn create(dtor: Option<Dtor>) -> Key 
create_dir			pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> 
create_dir_all			    fn create_dir_all(&self, path: &Path) -> io::Result<()> 
create_dir_all			pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> 
create_dir_all_with_junctions			    fn create_dir_all_with_junctions() 
create_new			    pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions 
create_new			    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }
create_new			    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }
create_new			    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }
created			    pub fn created(&self) -> io::Result<SystemTime> 
created			    pub fn created(&self) -> io::Result<SystemTime> 
created			    pub fn created(&self) -> io::Result<SystemTime> 
created			    pub fn created(&self) -> io::Result<SystemTime> 
created_u64			    pub fn created_u64(&self) -> u64 
creation			    fn creation() 
creation_flags			    fn creation_flags(&mut self, flags: u32) -> &mut process::Command 
creation_flags			    fn creation_flags(&mut self, flags: u32) -> &mut process::Command;
creation_flags			    pub fn creation_flags(&mut self, flags: u32) 
creation_time			    fn creation_time(&self) -> u64 { self.as_inner().created_u64() }
creation_time			    fn creation_time(&self) -> u64;
cstr			fn cstr(path: &Path) -> io::Result<CString> 
ctime			    fn ctime(&self) -> i64 
ctime			    fn ctime(&self) -> i64;
ctime			    fn ctime(&self) -> i64 { self.st_ctime() }
ctime			    fn ctime(&self) -> i64;
ctime_nsec			    fn ctime_nsec(&self) -> i64 
ctime_nsec			    fn ctime_nsec(&self) -> i64;
ctime_nsec			    fn ctime_nsec(&self) -> i64 { self.st_ctime_nsec() }
ctime_nsec			    fn ctime_nsec(&self) -> i64;
current			    pub unsafe fn current() -> Option<usize> { None }
current			    pub unsafe fn current() -> Option<usize> { None }
current			    pub unsafe fn current() -> Option<usize> 
current			    pub unsafe fn current() -> Option<usize> { None }
current			pub fn current() -> Thread 
current_dir			pub fn current_dir() -> io::Result<PathBuf> 
current_dir			    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_exe			pub fn current_exe() -> io::Result<PathBuf> 
current_thread			pub fn current_thread() -> Option<Thread> 
cursor			mod cursor;
custom_flags			    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions 
custom_flags			    fn custom_flags(&mut self, flags: i32) -> &mut Self;
custom_flags			    pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }
custom_flags			    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions 
custom_flags			    fn custom_flags(&mut self, flags: i32) -> &mut Self;
custom_flags			    pub fn custom_flags(&mut self, flags: i32) { self.custom_flags = flags; }
custom_flags			    fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions 
custom_flags			    fn custom_flags(&mut self, flags: u32) -> &mut Self;
custom_flags			    pub fn custom_flags(&mut self, flags: u32) { self.custom_flags = flags; }
cvt			pub fn cvt(result: Result<usize, syscall::Error>) -> io::Result<usize> 
cvt			pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> 
cvt			pub fn cvt<I: IsZero>(i: I) -> io::Result<I> 
cvt			pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> 
cvt_gai			pub fn cvt_gai(err: c_int) -> io::Result<()> 
cvt_gai			pub fn cvt_gai(err: c_int) -> io::Result<()> 
cvt_pread64			pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)
cvt_pread64			        unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)
cvt_pwrite64			pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)
cvt_pwrite64			        unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)
cvt_r			pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
cvt_r			pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
cwd			    pub fn cwd(&mut self, dir: &OsStr) 
datagram_pair			    fn datagram_pair() 
datasync			    pub fn datasync(&self) -> io::Result<()> 
datasync			    pub fn datasync(&self) -> io::Result<()> 
datasync			    pub fn datasync(&self) -> io::Result<()> { self.fsync() }
debug			    fn debug() 
debug			    fn debug() 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_error_kind			pub fn decode_error_kind(errno: i32) -> ErrorKind 
decode_surrogate			fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 
decode_surrogate_pair			fn decode_surrogate_pair(lead: u16, trail: u16) -> char 
decrement			    fn decrement(&self, token: SignalToken) -> StartResult 
decrement			    fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> 
default			    fn default() -> DefaultHasher 
default			    fn default() -> HashMap<K, V, S> 
default			    fn default() -> RandomState 
default			    fn default() -> HashSet<T, S> 
default			    fn default() -> &'a CStr 
default			    fn default() -> CString 
default			    fn default() -> &'a OsStr 
default			    fn default() -> OsString 
default			    fn default() -> Condvar 
default			    fn default() -> Mutex<T> 
default			    fn default() -> RwLock<T> 
default_hook			fn default_hook(info: &PanicInfo) 
demangle			    fn demangle() 
demangle			pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> 
demangle_dollars			    fn demangle_dollars() 
demangle_elements_beginning_with_underscore			    fn demangle_elements_beginning_with_underscore() 
demangle_many_dollars			    fn demangle_many_dollars() 
demangle_trait_impls			    fn demangle_trait_impls() 
demangle_windows			    fn demangle_windows() 
dequeue			    fn dequeue(&mut self) -> Option<SignalToken> 
dequeue			    fn dequeue(&mut self) -> T 
deref			    fn deref(&self) -> &RawTable<K, V> 
deref			    fn deref(&self) -> &CStr 
deref			    fn deref(&self) -> &OsStr 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &Path 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &RawHandle { &self.0 }
deref			    fn deref(&self) -> &T 
deref			    fn deref(&self) -> &Wtf8 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
deref_mut			    fn deref_mut(&mut self) -> &mut T 
description			    fn description(&self) -> &str { self.inner.description() }
description			    fn description(&self) -> &str 
description			            fn description(&self) -> &str { &self.0 }
description			        fn description(&self) -> &str { "A-desc" }
description			    fn description(&self) -> &str { "failed to parse bool" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str;
description			    fn description(&self) -> &str { "nul byte found in data" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			            fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "prefix not found" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "failed to join paths" }
description			    fn description(&self) -> &str { "failed to join paths" }
description			    fn description(&self) -> &str { "failed to join paths" }
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "other time was not earlier than self" }
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			    pub unsafe fn destroy(&self) 
destroy			pub unsafe fn destroy(key: Key) 
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) { self.0.destroy() }
destroy			    pub unsafe fn destroy(&self) 
destroy_upgraded_shared_port_when_sender_still_active			    fn destroy_upgraded_shared_port_when_sender_still_active() 
dev			    fn dev(&self) -> u64 { self.st_dev() }
dev			    fn dev(&self) -> u64;
difference			    fn difference<'a, 'new>(v: Difference<'a, &'static str, RandomState>)
difference			    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> 
dir_entry_debug			    fn dir_entry_debug() 
dir_entry_methods			    fn dir_entry_methods() 
displacement			    pub fn displacement(&self) -> usize 
display			    pub fn display(&self) -> Display 
div			    fn div() 
div			    fn div(self, rhs: u32) -> Duration 
div_assign			    fn div_assign(&mut self, rhs: u32) 
dladdr			        fn dladdr(addr: *const libc::c_void,
dns			mod dns;
do_call			    fn do_call<F: FnOnce() -> R, R>(data: *mut u8) 
do_exec			    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error 
do_exec			    unsafe fn do_exec(&mut self, stdio: ChildPipes)
do_exec			    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error 
do_send			    fn do_send(&self, t: Message<T>) -> UpgradeResult 
done			    pub fn done(&self, guard: &Guard) 
dont_panic_in_drop_on_panicked_flush			    fn dont_panic_in_drop_on_panicked_flush() 
double_bind			    fn double_bind() 
downcast			    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Error>> 
downcast			    pub fn downcast<T: Error + 'static>(self: Box<Self>)
downcast_mut			    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> 
downcast_ref			    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> 
downcasting			    fn downcasting() 
drain			    fn drain<'new>(d: Drain<'static, &'static str, &'static str>)
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drain			    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> 
drain			    pub fn drain(&mut self) -> Drain<T> 
drain			    pub fn drain(&mut self) -> Drain<K, V> 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			                fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) { unsafe { launchpad_destroy(self.0); } }
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			    fn drop(&mut self) 
drop			            fn drop(&mut self) 
drop			        fn drop(&mut self) 
drop_chan			    pub fn drop_chan(&self) 
drop_chan			    pub fn drop_chan(&self) 
drop_chan			    pub fn drop_chan(&self) 
drop_chan			    pub fn drop_chan(&self) 
drop_full			    fn drop_full() 
drop_full			    fn drop_full() 
drop_full_shared			    fn drop_full_shared() 
drop_handler			    pub unsafe fn drop_handler(_handler: &mut super::Handler) 
drop_handler			    pub unsafe fn drop_handler(handler: &mut Handler) 
drop_port			    pub fn drop_port(&self) 
drop_port			    pub fn drop_port(&self) 
drop_port			    pub fn drop_port(&self) 
drop_port			    pub fn drop_port(&self) 
dtors_in_dtors_in_dtors			    fn dtors_in_dtors_in_dtors() 
dumb_print			pub fn dumb_print(args: fmt::Arguments) 
dup			    pub fn dup(&self, buf: &[u8]) -> io::Result<File> 
duplicate			    pub fn duplicate(&self) -> io::Result<FileDesc> 
duplicate			    pub fn duplicate(&self) -> io::Result<File> 
duplicate			    pub fn duplicate(&self) -> Result<TcpListener> 
duplicate			    pub fn duplicate(&self) -> Result<TcpStream> 
duplicate			    pub fn duplicate(&self) -> Result<UdpSocket> 
duplicate			    pub fn duplicate(&self) -> io::Result<FileDesc> 
duplicate			    pub fn duplicate(&self) -> io::Result<File> 
duplicate			    pub fn duplicate(&self) -> io::Result<Socket> 
duplicate			    pub fn duplicate(&self) -> io::Result<File> 
duplicate			    pub fn duplicate(&self, access: c::DWORD, inherit: bool,
duplicate			    pub fn duplicate(&self) -> io::Result<Socket> 
duplicate			    pub fn duplicate(&self) -> io::Result<TcpListener> 
duplicate			    pub fn duplicate(&self) -> io::Result<TcpStream> 
duplicate			    pub fn duplicate(&self) -> io::Result<UdpSocket> 
dur2intervals			    fn dur2intervals(dur: &Duration) -> u64 
dur2intervals			fn dur2intervals(d: &Duration) -> i64 
dur2timeout			pub fn dur2timeout(dur: Duration) -> c::DWORD 
duration			    pub fn duration(&self) -> Duration 
duration			mod duration;
duration_since			    pub fn duration_since(&self, earlier: Instant) -> Duration 
duration_since			    pub fn duration_since(&self, earlier: SystemTime)
dynamic_lib			pub mod dynamic_lib;
dynamic_tests			mod dynamic_tests 
e			        fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf 
each_addr			fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>
each_alignment			    fn each_alignment() 
each_alignment_reversed			    fn each_alignment_reversed() 
each_ip			    fn each_ip(f: &mut FnMut(SocketAddr)) 
each_ip			    fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) 
elapsed			    pub fn elapsed(&self) -> Duration 
elapsed			    pub fn elapsed(&self) -> Result<Duration, SystemTimeError> 
empty			pub fn empty() -> Empty { Empty { _priv: () } }
empty_reads			    fn empty_reads() 
encode_wide			    fn encode_wide(&self) -> EncodeWide 
encode_wide			    fn encode_wide(&self) -> EncodeWide;
encode_wide			    pub fn encode_wide(&self) -> EncodeWide 
ends_with			    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool 
enqueue			    fn enqueue(&mut self, node: &mut Node) -> WaitToken 
enqueue			    fn enqueue(&mut self, t: T) 
ensure_no_nuls			fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> 
entry			    pub fn entry(&mut self, key: K) -> Entry<K, V> 
env			pub mod env;
env			    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command
env			pub mod env;
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env			pub mod env;
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env			pub mod env;
env			pub fn env() -> Env 
env			    pub fn env(&mut self, key: &OsStr, val: &OsStr) 
env_clear			    pub fn env_clear(&mut self) -> &mut Command 
env_clear			    pub fn env_clear(&mut self) 
env_clear			    pub fn env_clear(&mut self) 
env_clear			    pub fn env_clear(&mut self) 
env_cmd			    pub fn env_cmd() -> Command 
env_remove			    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
env_remove			    pub fn env_remove(&mut self, key: &OsStr) 
environ			pub unsafe fn environ() -> *mut *const *const c_char 
eq			    fn eq(&self, other: &HashMap<K, V, S>) -> bool 
eq			            fn eq(&self, other: &Self) -> bool 
eq			    fn eq(&self, other: &HashSet<T, S>) -> bool 
eq			    fn eq(a: Option<OsString>, b: Option<&str>) 
eq			    fn eq(&self, other: &CStr) -> bool 
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			    fn eq(&self, other: &OsStr) -> bool 
eq			    fn eq(&self, other: &OsString) -> bool 
eq			    fn eq(&self, other: &str) -> bool 
eq			    fn eq(&self, other: &SocketAddrV4) -> bool 
eq			    fn eq(&self, other: &SocketAddrV6) -> bool 
eq			    fn eq(&self, other: &Ipv4Addr) -> bool 
eq			    fn eq(&self, other: &Ipv6Addr) -> bool 
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			            fn eq(&self, other: &
eq			    fn eq(&self, other: &Components<'a>) -> bool 
eq			    fn eq(&self, other: &Path) -> bool 
eq			    fn eq(&self, other: &PathBuf) -> bool 
eq			    fn eq(&self, other: &PrefixComponent<'a>) -> bool 
eq			    fn eq(&self, other: &Timespec) -> bool 
eq			    fn eq(&self, other: &Timespec) -> bool 
eq			    fn eq(&self, other: &SystemTime) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &char) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &str) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &u8) -> bool 
eq_ignore_ascii_case			    fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool 
equal_hash			    fn equal_hash() 
erf			        pub fn erf(n: c_double) -> c_double;
erfc			        pub fn erfc(n: c_double) -> c_double;
erfcf			        pub fn erfcf(n: c_float) -> c_float;
erff			        pub fn erff(n: c_float) -> c_float;
errno			pub fn errno() -> i32 
errno			pub fn errno() -> i32 
errno			pub fn errno() -> i32 
errno_location			    fn errno_location() -> *mut c_int;
error			    pub fn error(&self) -> &Error { &self.1 }
error			mod error;
error			pub mod error;
error::Error for Error			impl error::Error for Error 
error::Error for IntoInnerError			impl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> 
error::Error for RecvError			impl error::Error for RecvError 
error::Error for RecvTimeoutError			impl error::Error for RecvTimeoutError 
error::Error for SendError			impl<T: Send> error::Error for SendError<T> 
error::Error for TestError			        impl error::Error for TestError 
error::Error for TryRecvError			impl error::Error for TryRecvError 
error::Error for TrySendError			impl<T: Send> error::Error for TrySendError<T> 
error_cb			    extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,
error_repeat			    fn error_repeat(byte: u8, limit: u64) -> ErrorRepeat 
error_string			pub fn error_string(errno: i32) -> String 
error_string			pub fn error_string(errno: i32) -> String 
error_string			pub fn error_string(errnum: i32) -> String 
escape_default			pub fn escape_default(c: u8) -> EscapeDefault 
exec			    fn exec(&mut self) -> io::Error 
exec			    fn exec(&mut self) -> io::Error;
exec			    pub fn exec(&mut self, default: Stdio) -> io::Error 
exec			    fn exec(&mut self) -> io::Error 
exec			    fn exec(&mut self) -> io::Error;
exec			    pub fn exec(&mut self, default: Stdio) -> io::Error 
exec			    pub fn exec(&mut self, default: Stdio) -> io::Error 
exists			    pub fn exists(&self) -> bool 
exit			pub fn exit(code: i32) -> ! 
exit			pub fn exit(code: i32) -> ! 
exit			pub fn exit(code: i32) -> ! 
exit			pub fn exit(code: i32) -> ! 
exit_reported_right			    fn exit_reported_right() 
exited			    fn exited(&self) -> bool 
exited			    fn exited(&self) -> bool 
exp			    pub fn exp(self) -> f32 
exp			    pub fn exp(self) -> f64 
exp2			    pub fn exp2(self) -> f32 
exp2			    pub fn exp2(self) -> f64 
exp_m1			    pub fn exp_m1(self) -> f32 
exp_m1			    pub fn exp_m1(self) -> f64 
expm1			        pub fn expm1(n: c_double) -> c_double;
expm1f			        pub fn expm1f(n: c_float) -> c_float;
ext			pub mod ext;
ext			pub mod ext;
ext			pub mod ext;
extend			    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) 
extend			    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) 
extend			    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) 
extend			    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) 
extend			    fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) 
extend			    fn extend<T: IntoIterator<Item=CodePoint>>(&mut self, iter: T) 
extension			    pub fn extension(&self) -> Option<&OsStr> 
f			        fn f(values: &[u32]) -> Wtf8Buf 
f			        fn f(i: i32, tx: Sender<()>) 
f32			impl f32 
f32			pub mod f32;
f64			impl f64 
f64			pub mod f64;
fallback			    unsafe fn fallback() -> Option<OsString> { None }
fallback			    unsafe fn fallback() -> Option<OsString> 
fallback			pub mod fallback 
fast_rebind			    fn fast_rebind() 
fast_thread_local			pub mod fast_thread_local;
fast_thread_local			pub mod fast_thread_local;
fchmod_works			    fn fchmod_works() 
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd			pub mod fd;
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd			    fn fd(&self) -> Option<usize> 
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd			pub mod fd;
fd			    pub fn fd(&self) -> &FileDesc { &self.0 }
fd			    pub fn fd(&self) -> Option<c_int> 
fdim			        pub fn fdim(a: c_double, b: c_double) -> c_double;
fdimf			        pub fn fdimf(a: c_float, b: c_float) -> c_float;
fetch			unsafe fn fetch(name: &str) -> usize 
ffi			pub mod ffi;
ffi			pub mod ffi;
ffi			pub mod ffi;
ffi			pub mod ffi;
file			    pub fn file(&self) -> &str 
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_attr			    pub fn file_attr(&self) -> io::Result<FileAttr> 
file_attributes			    fn file_attributes(&self) -> u32 { self.as_inner().attrs() }
file_attributes			    fn file_attributes(&self) -> u32;
file_create_new_already_exists_error			    fn file_create_new_already_exists_error() 
file_name			    pub fn file_name(&self) -> OsString 
file_name			    pub fn file_name(&self) -> Option<&OsStr> 
file_name			    pub fn file_name(&self) -> OsString 
file_name			    pub fn file_name(&self) -> OsString 
file_name			    pub fn file_name(&self) -> OsString 
file_size			    fn file_size(&self) -> u64 { self.as_inner().size() }
file_size			    fn file_size(&self) -> u64;
file_stem			    pub fn file_stem(&self) -> Option<&OsStr> 
file_test_directoryinfo_check_exists_before_and_after_mkdir			    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() 
file_test_directoryinfo_readdir			    fn file_test_directoryinfo_readdir() 
file_test_fileinfo_check_exists_before_and_after_file_creation			    fn file_test_fileinfo_check_exists_before_and_after_file_creation() 
file_test_fileinfo_false_when_checking_is_file_on_a_directory			    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() 
file_test_io_eof			    fn file_test_io_eof() 
file_test_io_non_positional_read			    fn file_test_io_non_positional_read() 
file_test_io_read_write_at			    fn file_test_io_read_write_at() 
file_test_io_seek_and_tell_smoke_test			    fn file_test_io_seek_and_tell_smoke_test() 
file_test_io_seek_and_write			    fn file_test_io_seek_and_write() 
file_test_io_seek_read_write			    fn file_test_io_seek_read_write() 
file_test_io_seek_shakedown			    fn file_test_io_seek_shakedown() 
file_test_io_smoke_test			    fn file_test_io_smoke_test() 
file_test_iounlinking_invalid_path_should_raise_condition			    fn file_test_iounlinking_invalid_path_should_raise_condition() 
file_test_stat_is_correct_on_is_dir			    fn file_test_stat_is_correct_on_is_dir() 
file_test_stat_is_correct_on_is_file			    fn file_test_stat_is_correct_on_is_file() 
file_try_clone			    fn file_try_clone() 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
file_type			    pub fn file_type(&self) -> FileType 
file_type			    pub fn file_type(&self) -> io::Result<FileType> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }
fill_buf			            fn fill_buf(&mut self) -> io::Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> Result<&[u8]> 
fill_buf			    fn fill_buf(&mut self) -> Result<&[u8]>;
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }
fill_buf			    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(&[]) }
fill_bytes			    fn fill_bytes(&mut self, bytes: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, mut v: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, buf: &mut [u8]) 
fill_bytes			        fn fill_bytes(&mut self, v: &mut [u8]) 
fill_bytes			    fn fill_bytes(&mut self, v: &mut [u8]) 
fill_utf16_buf			fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>
final_lead_surrogate			    fn final_lead_surrogate(&self) -> Option<u16> 
find_existing			fn find_existing(b: &mut Bencher) 
find_nonexisting			fn find_nonexisting(b: &mut Bencher) 
find_zero_slice			                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) 
finish			    fn finish(&self) -> u64 
finish			    fn finish(&mut self) -> io::Result<()> 
finished			    fn finished(&self) -> bool 
first			    pub fn first(table: M) -> Bucket<K, V, M> 
first_bucket_raw			    fn first_bucket_raw(&self) -> RawBucket<K, V> 
flag_locked			    unsafe fn flag_locked(&self) -> bool 
floor			    pub fn floor(self) -> f32 
floor			    pub fn floor(self) -> f64 
flowinfo			    pub fn flowinfo(&self) -> u32 
flush			    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }
flush			            fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			            fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { (**self).flush() }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> Result<()>;
flush			    fn flush(&mut self) -> io::Result<()> { self.0.flush() }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> 
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> { Ok(()) }
flush			    fn flush(&mut self) -> io::Result<()> 
flush			    pub fn flush(&self) -> io::Result<()> 
flush_buf			    fn flush_buf(&mut self) -> io::Result<()> 
fmax			        pub fn fmax(a: c_double, b: c_double) -> c_double;
fmaxf			        pub fn fmaxf(a: c_float, b: c_float) -> c_float;
fmin			        pub fn fmin(a: c_double, b: c_double) -> c_double;
fminf			        pub fn fminf(a: c_float, b: c_float) -> c_float;
fmod			        pub fn fmod(a: c_double, b: c_double) -> c_double;
fmodf			        pub fn fmodf(a: c_float, b: c_float) -> c_float;
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> 
fmt			    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Debug for BufReader			impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug 
fmt::Debug for BufWriter			impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug 
fmt::Debug for CStr			impl fmt::Debug for CStr 
fmt::Debug for CString			impl fmt::Debug for CString 
fmt::Debug for CodePoint			impl fmt::Debug for CodePoint 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Command			impl fmt::Debug for Command 
fmt::Debug for Components			impl<'a> fmt::Debug for Components<'a> 
fmt::Debug for DebugHelper			        impl<'a> fmt::Debug for DebugHelper<'a> 
fmt::Debug for DirEntry			impl fmt::Debug for DirEntry 
fmt::Debug for Display			impl<'a> fmt::Debug for Display<'a> 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for File			impl fmt::Debug for File 
fmt::Debug for Handle			impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> 
fmt::Debug for HashSet			impl<T, S> fmt::Debug for HashSet<T, S>
fmt::Debug for Instant			impl fmt::Debug for Instant 
fmt::Debug for Instant			    impl fmt::Debug for Instant 
fmt::Debug for Instant			impl fmt::Debug for Instant 
fmt::Debug for Ipv4Addr			impl fmt::Debug for Ipv4Addr 
fmt::Debug for Ipv6Addr			impl fmt::Debug for Ipv6Addr 
fmt::Debug for Iter			impl<'a> fmt::Debug for Iter<'a> 
fmt::Debug for LineWriter			impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug 
fmt::Debug for Mutex			impl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> 
fmt::Debug for Output			impl fmt::Debug for Output 
fmt::Debug for Path			impl fmt::Debug for Path 
fmt::Debug for PathBuf			impl fmt::Debug for PathBuf 
fmt::Debug for PoisonError			impl<T> fmt::Debug for PoisonError<T> 
fmt::Debug for ReadDir			impl fmt::Debug for ReadDir 
fmt::Debug for ReadDir			impl fmt::Debug for ReadDir 
fmt::Debug for ReadDir			impl fmt::Debug for ReadDir 
fmt::Debug for Receiver			impl<T> fmt::Debug for Receiver<T> 
fmt::Debug for ReentrantMutex			impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> 
fmt::Debug for Repr			impl fmt::Debug for Repr 
fmt::Debug for RwLock			impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> 
fmt::Debug for Select			impl fmt::Debug for Select 
fmt::Debug for SendError			impl<T> fmt::Debug for SendError<T> 
fmt::Debug for Sender			impl<T> fmt::Debug for Sender<T> 
fmt::Debug for SocketAddr			impl fmt::Debug for SocketAddr 
fmt::Debug for SocketAddrV4			impl fmt::Debug for SocketAddrV4 
fmt::Debug for SocketAddrV6			impl fmt::Debug for SocketAddrV6 
fmt::Debug for SyncSender			impl<T> fmt::Debug for SyncSender<T> 
fmt::Debug for SystemTime			impl fmt::Debug for SystemTime 
fmt::Debug for SystemTime			    impl fmt::Debug for SystemTime 
fmt::Debug for SystemTime			impl fmt::Debug for SystemTime 
fmt::Debug for SystemTime			impl fmt::Debug for SystemTime 
fmt::Debug for TcpListener			impl fmt::Debug for TcpListener 
fmt::Debug for TcpListener			impl fmt::Debug for TcpListener 
fmt::Debug for TcpStream			impl fmt::Debug for TcpStream 
fmt::Debug for TcpStream			impl fmt::Debug for TcpStream 
fmt::Debug for Thread			impl fmt::Debug for Thread 
fmt::Debug for TryLockError			impl<T> fmt::Debug for TryLockError<T> 
fmt::Debug for TrySendError			impl<T> fmt::Debug for TrySendError<T> 
fmt::Debug for UdpSocket			impl fmt::Debug for UdpSocket 
fmt::Debug for UdpSocket			impl fmt::Debug for UdpSocket 
fmt::Debug for UnixDatagram			impl fmt::Debug for UnixDatagram 
fmt::Debug for UnixListener			impl fmt::Debug for UnixListener 
fmt::Debug for UnixStream			impl fmt::Debug for UnixStream 
fmt::Debug for Wtf8			impl fmt::Debug for Wtf8 
fmt::Debug for Wtf8Buf			impl fmt::Debug for Wtf8Buf 
fmt::Display for A			    impl fmt::Display for A 
fmt::Display for AddrParseError			impl fmt::Display for AddrParseError 
fmt::Display for AsciiEscaped			impl<'a> fmt::Display for AsciiEscaped<'a> 
fmt::Display for B			    impl fmt::Display for B 
fmt::Display for CharsError			impl fmt::Display for CharsError 
fmt::Display for Display			impl<'a> fmt::Display for Display<'a> 
fmt::Display for Error			impl fmt::Display for Error 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for ExitStatus			impl fmt::Display for ExitStatus 
fmt::Display for IntoInnerError			impl<W> fmt::Display for IntoInnerError<W> 
fmt::Display for IntoStringError			impl fmt::Display for IntoStringError 
fmt::Display for IpAddr			impl fmt::Display for IpAddr 
fmt::Display for Ipv4Addr			impl fmt::Display for Ipv4Addr 
fmt::Display for Ipv6Addr			impl fmt::Display for Ipv6Addr 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for JoinPathsError			impl fmt::Display for JoinPathsError 
fmt::Display for NulError			impl fmt::Display for NulError 
fmt::Display for PoisonError			impl<T> fmt::Display for PoisonError<T> 
fmt::Display for RecvError			impl fmt::Display for RecvError 
fmt::Display for RecvTimeoutError			impl fmt::Display for RecvTimeoutError 
fmt::Display for SendError			impl<T> fmt::Display for SendError<T> 
fmt::Display for SocketAddr			impl fmt::Display for SocketAddr 
fmt::Display for SocketAddrV4			impl fmt::Display for SocketAddrV4 
fmt::Display for SocketAddrV6			impl fmt::Display for SocketAddrV6 
fmt::Display for StripPrefixError			impl fmt::Display for StripPrefixError 
fmt::Display for SystemTimeError			impl fmt::Display for SystemTimeError 
fmt::Display for TestError			        impl fmt::Display for TestError 
fmt::Display for TryLockError			impl<T> fmt::Display for TryLockError<T> 
fmt::Display for TryRecvError			impl fmt::Display for TryRecvError 
fmt::Display for TrySendError			impl<T> fmt::Display for TrySendError<T> 
fmt::Display for VarError			impl fmt::Display for VarError 
fmt::Write for Adaptor			        impl<'a, T: Write + ?Sized> fmt::Write for Adaptor<'a, T> 
fmt_debug_handle			    fn fmt_debug_handle() 
fmt_debug_recv			    fn fmt_debug_recv() 
fmt_debug_select			    fn fmt_debug_select() 
fmt_debug_sender			    fn fmt_debug_sender() 
fmt_debug_sync_sender			    fn fmt_debug_sync_sender() 
fmt_subslice			                    fn fmt_subslice(segments: &[u16], fmt: &mut fmt::Formatter) -> fmt::Result 
foo			        fn foo() -> Foo 
formatted			    fn formatted() 
fract			    pub fn fract(self) -> f32 { self - self.trunc() }
fract			    pub fn fract(self) -> f64 { self - self.trunc() }
freeaddrinfo			    pub fn freeaddrinfo(res: *mut ADDRINFOA);
frequency			fn frequency() -> c::LARGE_INTEGER 
frexp			    pub fn frexp(self) -> (f32, isize) 
frexp			        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;
frexp			    pub fn frexp(self) -> (f64, isize) 
frexpf			        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;
frexpf			        pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float 
frob			    fn frob() 
from			    fn from(err: &'a str) -> Box<Error> 
from			    fn from(err: &'b str) -> Box<Error + Send + Sync + 'a> 
from			    fn from(err: E) -> Box<Error + 'a> 
from			    fn from(err: E) -> Box<Error + Send + Sync + 'a> 
from			    fn from(err: String) -> Box<Error + Send + Sync> 
from			    fn from(str_err: String) -> Box<Error> 
from			    fn from(_: NulError) -> io::Error 
from			    fn from(s: &'a CStr) -> CString 
from			    fn from(s: CString) -> Vec<u8> 
from			    fn from(s: &'a T) -> OsString 
from			    fn from(s: String) -> OsString 
from			    fn from(iie: IntoInnerError<W>) -> Error { iie.1 }
from			    fn from(kind: ErrorKind) -> Error 
from			    fn from(ip: Ipv4Addr) -> u32 
from			    fn from(ip: u32) -> Ipv4Addr 
from			    fn from(octets: [u8; 16]) -> Ipv6Addr 
from			    fn from(octets: [u8; 4]) -> Ipv4Addr 
from			    fn from(path_buf : PathBuf) -> OsString 
from			    fn from(s: &'a Path) -> Cow<'a, Path> 
from			    fn from(s: &'a T) -> PathBuf 
from			    fn from(s: OsString) -> PathBuf 
from			    fn from(s: PathBuf) -> Cow<'a, Path> 
from			    fn from(s: String) -> PathBuf 
from			    fn from(value: n16) -> Self 
from			    fn from(value: u16) -> Self 
from			    fn from(a: i32) -> ExitStatus 
from			    fn from(t: syscall::TimeSpec) -> SystemTime 
from			    fn from(a: c_int) -> ExitStatus 
from			        fn from(t: libc::timespec) -> SystemTime 
from			        fn from(t: libc::timeval) -> SystemTime 
from			    fn from(u: c::DWORD) -> ExitStatus 
from			    fn from(t: c::FILETIME) -> SystemTime 
from			    fn from(err: PoisonError<T>) -> TryLockError<T> 
from_be			        fn from_be(i: Self) -> Self { <
from_be			    fn from_be(i: Self) -> Self;
from_bytes			    fn from_bytes(slice: &[u8]) -> &OsStr 
from_bytes			    fn from_bytes(slice: &[u8]) -> &Self;
from_bytes			    pub fn from_bytes(bytes: &[u8]) -> Self 
from_bytes			    fn from_bytes(slice: &[u8]) -> &OsStr 
from_bytes			    fn from_bytes(slice: &[u8]) -> &Self;
from_bytes_unchecked			    unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 
from_bytes_with_nul			    fn from_bytes_with_nul() 
from_bytes_with_nul			    pub fn from_bytes_with_nul(bytes: &[u8])
from_bytes_with_nul_interior			    fn from_bytes_with_nul_interior() 
from_bytes_with_nul_unchecked			    pub unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr 
from_bytes_with_nul_unterminated			    fn from_bytes_with_nul_unterminated() 
from_char			    pub fn from_char(value: char) -> CodePoint 
from_fd			    pub fn from_fd(fd: FileDesc) -> io::Result<AnonPipe> 
from_fd			    pub fn from_fd(fd: FileDesc) -> io::Result<AnonPipe> 
from_inner			    fn from_inner(buf: Buf) -> OsString 
from_inner			    fn from_inner(inner: &Slice) -> &OsStr 
from_inner			    fn from_inner(f: fs_imp::File) -> File 
from_inner			    fn from_inner(f: fs_imp::FilePermissions) -> Permissions 
from_inner			    fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 
from_inner			    fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 
from_inner			    fn from_inner(addr: c::in6_addr) -> Ipv6Addr 
from_inner			    fn from_inner(addr: c::in_addr) -> Ipv4Addr 
from_inner			    fn from_inner(inner: net_imp::TcpListener) -> TcpListener 
from_inner			    fn from_inner(inner: net_imp::TcpStream) -> TcpStream { TcpStream(inner) }
from_inner			    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket { UdpSocket(inner) }
from_inner			    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -> Child 
from_inner			    fn from_inner(inner: imp::Stdio) -> Stdio 
from_inner			    fn from_inner(pipe: AnonPipe) -> ChildStderr 
from_inner			    fn from_inner(pipe: AnonPipe) -> ChildStdin 
from_inner			    fn from_inner(pipe: AnonPipe) -> ChildStdout 
from_inner			    fn from_inner(s: imp::ExitStatus) -> ExitStatus 
from_inner			    fn from_inner(fd: usize) -> File 
from_inner			    fn from_inner(mode: u32) -> FilePermissions 
from_inner			    fn from_inner(fd: c_int) -> File 
from_inner			    fn from_inner(mode: u32) -> FilePermissions 
from_inner			    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }
from_inner			    fn from_inner(handle: c::HANDLE) -> File 
from_inner			    fn from_inner(sock: c::SOCKET) -> Socket { Socket(sock) }
from_inner			    fn from_inner(inner: Inner) -> Self;
from_inner			    fn from_inner(socket: Socket) -> TcpListener 
from_inner			    fn from_inner(socket: Socket) -> TcpStream 
from_inner			    fn from_inner(socket: Socket) -> UdpSocket 
from_inner			    fn from_inner(time: time::SystemTime) -> SystemTime 
from_intervals			    fn from_intervals(intervals: i64) -> SystemTime 
from_iter			    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> 
from_iter			    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> HashSet<T, S> 
from_iter			    fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf 
from_iter			    fn from_iter<T: IntoIterator<Item=CodePoint>>(iter: T) -> Wtf8Buf 
from_millis			    pub fn from_millis(millis: u64) -> Duration 
from_mode			    fn from_mode(mode: u32) -> Permissions 
from_mode			    fn from_mode(mode: u32) -> Self;
from_mode			    fn from_mode(mode: u32) -> Permissions 
from_mode			    fn from_mode(mode: u32) -> Self;
from_parts			    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> 
from_ptr			    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr 
from_raw			    pub unsafe fn from_raw(ptr: *mut c_char) -> CString 
from_raw			    fn from_raw(raw: i32) -> Self 
from_raw			    fn from_raw(raw: i32) -> Self;
from_raw			    fn from_raw(raw: i32) -> Self 
from_raw			    fn from_raw(raw: i32) -> Self;
from_raw			    fn from_raw(raw: u32) -> Self 
from_raw			    fn from_raw(raw: u32) -> Self;
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> Self;
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> fs::File 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> Self;
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> fs::File 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream 
from_raw_fd			    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio 
from_raw_handle			    unsafe fn from_raw_handle(handle: RawHandle) -> Self;
from_raw_handle			    unsafe fn from_raw_handle(handle: RawHandle) -> fs::File 
from_raw_handle			    unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio 
from_raw_os_error			    pub fn from_raw_os_error(code: i32) -> Error 
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> Self;
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener 
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream 
from_raw_socket			    unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket 
from_secs			    pub fn from_secs(secs: u64) -> Duration 
from_seed			    fn from_seed(seed: &'a [usize]) -> StdRng 
from_str			    fn from_str(s: &str) -> Result<IpAddr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> 
from_str			    fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> 
from_str			    fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_str			    pub fn from_str(s: &str) -> &Slice 
from_str			    pub fn from_str(str: &str) -> Wtf8Buf 
from_str			    pub fn from_str(value: &str) -> &Wtf8 
from_string			    pub fn from_string(s: String) -> Buf 
from_string			    pub fn from_string(s: String) -> Buf 
from_string			    pub fn from_string(s: String) -> Buf 
from_string			    pub fn from_string(string: String) -> Wtf8Buf 
from_u32			    pub fn from_u32(value: u32) -> Option<CodePoint> 
from_u32_unchecked			    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint 
from_u8_slice			    unsafe fn from_u8_slice(s: &[u8]) -> &Path 
from_u8_slice			    fn from_u8_slice(s: &[u8]) -> &Slice 
from_u8_slice			    fn from_u8_slice(s: &[u8]) -> &Slice 
from_vec			    fn from_vec(vec: Vec<u8>) -> OsString 
from_vec			    fn from_vec(vec: Vec<u8>) -> Self;
from_vec			    fn from_vec(vec: Vec<u8>) -> OsString 
from_vec			    fn from_vec(vec: Vec<u8>) -> Self;
from_vec_unchecked			    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString 
from_wide			    fn from_wide(wide: &[u16]) -> OsString 
from_wide			    fn from_wide(wide: &[u16]) -> Self;
from_wide			    pub fn from_wide(v: &[u16]) -> Wtf8Buf 
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fs			pub mod fs;
fsync			    pub fn fsync(&self) -> io::Result<()> 
fsync			    pub fn fsync(&self) -> io::Result<()> 
fsync			    pub fn fsync(&self) -> io::Result<()> 
ftruncate64			pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> 
full			    pub fn full(&self) -> &FullBucket<K, V, M> 
gap_peek			    pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> 
ge			    fn ge(&self, other: &OsStr) -> bool { self.bytes().ge(other.bytes()) }
ge			    fn ge(&self, other: &OsString) -> bool { &**self >= &**other }
get			    fn get(&self, key: &Q) -> Option<&K> 
get			    pub fn get(&self) -> &V 
get			    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
get			    fn get(&self, key: &Q) -> Option<&Self::Key>;
get			    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>
get			    pub fn get(&'static self) -> Option<Arc<T>> 
get			    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			    pub fn get(&self) -> Option<&F> 
get			    fn get(&self) -> &Handle { self.0.as_ref().unwrap() }
get			pub fn get(handle: c::DWORD) -> io::Result<Output> 
get			pub unsafe fn get(key: Key) -> *mut u8 
get			    pub fn get(&self) -> bool 
get			    pub fn get(&self) -> *mut u8 
get			    pub unsafe fn get(&self) -> *mut u8 { imp::get(self.key()) }
get			        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> 
get_access_mode			    fn get_access_mode(&self) -> io::Result<usize> 
get_access_mode			    fn get_access_mode(&self) -> io::Result<c_int> 
get_access_mode			    fn get_access_mode(&self) -> io::Result<c::DWORD> 
get_argv			    pub fn get_argv(&self) -> &Vec<*const c_char> 
get_closures			    pub fn get_closures(&mut self) -> &mut Vec<Box<FnMut() -> io::Result<()> + Send + Sync>> 
get_conn			    fn get_conn(&self) -> &mut Option<SocketAddr> 
get_creation_mode			    fn get_creation_mode(&self) -> io::Result<usize> 
get_creation_mode			    fn get_creation_mode(&self) -> io::Result<c_int> 
get_creation_mode			    fn get_creation_mode(&self) -> io::Result<c::DWORD> 
get_cwd			    pub fn get_cwd(&self) -> &Option<CString> 
get_envp			    pub fn get_envp(&self) -> &Option<Vec<*const c_char>> 
get_flags_and_attributes			    fn get_flags_and_attributes(&self) -> c::DWORD 
get_gid			    pub fn get_gid(&self) -> Option<gid_t> 
get_global_ptr			    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> 
get_global_ptr			    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> 
get_mode			        fn get_mode(_fd: c_int) -> Option<(bool, bool)> 
get_mode			        fn get_mode(fd: c_int) -> Option<(bool, bool)> 
get_mut			    pub fn get_mut(&mut self) -> &mut V 
get_mut			    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
get_mut			    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }
get_mut			    pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }
get_mut			    pub fn get_mut(&mut self) -> &mut T { &mut self.inner }
get_mut			    pub fn get_mut(&mut self) -> Option<&mut (error::Error+Send+Sync+'static)> 
get_mut			    pub fn get_mut(&mut self) -> LockResult<&mut T> 
get_mut			    pub fn get_mut(&mut self) -> LockResult<&mut T> 
get_mut			    pub fn get_mut(&mut self) -> &mut T { &mut self.guard }
get_path			        fn get_path(_fd: c_int) -> Option<PathBuf> 
get_path			        fn get_path(fd: c_int) -> Option<PathBuf> 
get_path			fn get_path(f: &File) -> io::Result<PathBuf> 
get_ref			    pub fn get_ref(&self) -> &R { &self.inner }
get_ref			    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }
get_ref			    pub fn get_ref(&self) -> &W { self.inner.get_ref() }
get_ref			    pub fn get_ref(&self) -> &T { &self.inner }
get_ref			    pub fn get_ref(&self) -> Option<&(error::Error+Send+Sync+'static)> 
get_ref			    pub fn get_ref(&self) -> &T { &self.guard }
get_remove_insert			fn get_remove_insert(b: &mut Bencher) 
get_stack			    unsafe fn get_stack() -> libc::stack_t 
get_stack_start			    unsafe fn get_stack_start() -> Option<*mut libc::c_void> 
get_stackp			    unsafe fn get_stackp() -> *mut libc::c_void 
get_uid			    pub fn get_uid(&self) -> Option<uid_t> 
getaddrinfo			    pub fn getaddrinfo(node: *const c_char, service: *const c_char,
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getcwd			pub fn getcwd() -> io::Result<PathBuf> 
getenv			pub fn getenv(key: &OsStr) -> io::Result<Option<OsString>> 
getenv			pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> 
getenv			pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> 
getexecname			        fn getexecname() -> *const c_char;
getpeername			    pub fn getpeername(socket: SOCKET,
getpwduid_r			        unsafe fn getpwduid_r(me: libc::uid_t, passwd: &mut libc::passwd,
getrandom			    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }
getrandom			    fn getrandom(buf: &mut [u8]) -> Result<usize, i32> 
getrandom			    fn getrandom(buf: &mut [u8]) -> libc::c_long 
getrandom_fill_bytes			    fn getrandom_fill_bytes(v: &mut [u8]) 
getsockname			    pub fn getsockname(socket: SOCKET,
getsockopt			    pub fn getsockopt(s: SOCKET,
getsockopt			pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,
gid			    fn gid(&self) -> u32 
gid			    fn gid(&self) -> u32;
gid			    fn gid(&mut self, id: u32) -> &mut process::Command 
gid			    fn gid(&mut self, id: u32) -> &mut process::Command;
gid			    pub fn gid(&mut self, id: u32) 
gid			    fn gid(&self) -> u32 { self.st_gid() }
gid			    fn gid(&self) -> u32;
gid			    fn gid(&mut self, id: u32) -> &mut process::Command 
gid			    fn gid(&mut self, id: u32) -> &mut process::Command;
gid			    pub fn gid(&mut self, id: gid_t) 
gnu			pub mod gnu;
got_symlink_permission			    pub fn got_symlink_permission(tmpdir: &TempDir) -> bool 
grow_by_insertion			fn grow_by_insertion(b: &mut Bencher) 
gt			    fn gt(&self, other: &OsStr) -> bool { self.bytes().gt(other.bytes()) }
gt			    fn gt(&self, other: &OsString) -> bool { &**self > &**other }
guard			pub mod guard 
guard			pub mod guard 
guard			pub mod guard 
guard_lock			pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex 
guard_poison			pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag 
handle			    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> 
handle			    pub fn handle(&self) -> &Handle { &self.handle }
handle			pub mod handle;
handle			    pub fn handle(&self) -> &Handle { &self.inner }
handle			    pub fn handle(&self) -> &Handle { &self.handle }
handle			    pub fn handle(&self) -> &Handle 
handle			    pub fn handle(&self) -> &Handle { &self.handle }
handle_ebadf			fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> 
hard_link			pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> 
has_implicit_root			    fn has_implicit_root(&self) -> bool 
has_physical_root			fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool 
has_root			    fn has_root(&self) -> bool 
has_root			    pub fn has_root(&self) -> bool 
hash			            fn hash<H: hash::Hasher>(&self, h: &mut H) 
hash			    pub fn hash(&self) -> SafeHash 
hash			mod hash;
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, s: &mut H) 
hash			    fn hash<H: hash::Hasher>(&self, s: &mut H) 
hash			        fn hash<T: Hash>(t: T) -> u64 
hash			    fn hash<H: Hasher>(&self, h: &mut H) 
hash			    fn hash<H: Hasher>(&self, state: &mut H) 
hash::Hash for Foo			        impl hash::Hash for Foo 
hash::Hash for Ipv4Addr			impl hash::Hash for Ipv4Addr 
hash::Hash for Ipv6Addr			impl hash::Hash for Ipv6Addr 
hash::Hash for SocketAddrV4			impl hash::Hash for SocketAddrV4 
hash::Hash for SocketAddrV6			impl hash::Hash for SocketAddrV6 
hash_map			pub mod hash_map 
hash_set			pub mod hash_set 
hasher			    pub fn hasher(&self) -> &S 
hasher			    pub fn hasher(&self) -> &S 
hashmap			    fn hashmap() 
hashmap_as_queue			fn hashmap_as_queue(b: &mut Bencher) 
hexify			    fn hexify(b: u8) -> u8 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
home_dir			pub fn home_dir() -> Option<PathBuf> 
hton			fn hton<I: NetInt>(i: I) -> I { i.to_be() }
hypot			    pub fn hypot(self, other: f32) -> f32 
hypot			        pub fn hypot(x: c_double, y: c_double) -> c_double;
hypot			    pub fn hypot(self, other: f64) -> f64 
hypotf			        pub fn hypotf(x: c_float, y: c_float) -> c_float;
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> usize { self.id }
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> usize { self.id }
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> libc::pthread_t { self.id }
id			    pub fn id(&self) -> u32 
id			    pub fn id(&self) -> ThreadId 
ilogb			        pub fn ilogb(n: c_double) -> c_int;
ilogbf			        pub fn ilogbf(n: c_float) -> c_int;
image_info			    struct image_info 
imp			mod imp;
imp			mod imp 
imp			mod imp 
imp			mod imp;
imp			mod imp;
imp			mod imp 
imp			mod imp 
impls			mod impls;
in6_addr			pub struct in6_addr 
in_addr			pub struct in_addr 
inc			        fn inc(m: &Mutex<u32>) 
include_cur_dir			    fn include_cur_dir(&self) -> bool 
incoming			    pub fn incoming(&self) -> Incoming 
incoming			    pub fn incoming<'a>(&'a self) -> Incoming<'a> 
index			    fn index(&self, index: &Q) -> &V 
index			    pub fn index(&self) -> usize 
index			    fn index(&self, _index: ops::RangeFull) -> &CStr 
index			    fn index(&self, _index: ops::RangeFull) -> &OsStr 
index			    fn index(&self, _range: ops::RangeFull) -> &Wtf8 
index			    fn index(&self, range: ops::Range<usize>) -> &Wtf8 
index			    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 
index			    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 
inference_works			    fn inference_works() 
info			    fn info() -> &'static libc::mach_timebase_info 
inherit			    pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }
inherit_blocker			    pub fn inherit_blocker(&self,
init			    unsafe fn init(&'static self) -> Arc<T> 
init			    pub unsafe fn init(argc: isize, argv: *const *const u8) 
init			pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }
init			    pub unsafe fn init(&self) 
init			pub fn init() 
init			    pub unsafe fn init(&mut self) 
init			    pub unsafe fn init(&self) 
init			pub unsafe fn init() 
init			    pub unsafe fn init() -> Option<usize> { None }
init			    pub unsafe fn init(_argc: isize, _argv: *const *const u8) 
init			    pub unsafe fn init(argc: isize, argv: *const *const u8) 
init			pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }
init			    pub unsafe fn init(&mut self) 
init			    pub unsafe fn init(&mut self) {}
init			pub fn init() 
init			    pub unsafe fn init(&mut self) 
init			pub fn init() {}
init			    pub unsafe fn init() 
init			    pub unsafe fn init() -> Option<usize> { None }
init			    pub unsafe fn init() -> Option<usize> 
init			pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }
init			    pub unsafe fn init(&mut self) {}
init			pub fn init() 
init			    pub unsafe fn init(&mut self) 
init			    pub unsafe fn init(&mut self) {}
init			pub fn init() 
init			pub unsafe fn init() 
init			    pub unsafe fn init() -> Option<usize> { None }
init			unsafe fn init() -> bool 
init			    pub unsafe fn init(&mut self) { self.0.init() }
init			    pub unsafe fn init(&mut self) { self.0.init() }
init			    unsafe fn init(&self, slot: &UnsafeCell<Option<T>>) -> &T 
init_dtors			unsafe fn init_dtors() 
init_env_map			    fn init_env_map(&mut self) -> (&mut HashMap<OsString, (usize, CString)>,
init_env_map			    fn init_env_map(&mut self)
init_frame			pub fn init_frame(frame: &mut c::STACKFRAME64,
init_state			    unsafe fn init_state() -> *mut backtrace_state 
init_vec_data			    fn init_vec_data() -> Vec<u8> 
initial_trail_surrogate			    fn initial_trail_surrogate(&self) -> Option<u16> 
inner			    unsafe fn inner(&self) -> &Flavor<T> 
inner			        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> 
inner			        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> 
inner			        fn inner(path: &Path) -> io::Result<UnixDatagram> 
inner			        fn inner(path: &Path) -> io::Result<UnixListener> 
inner			        fn inner(path: &Path) -> io::Result<UnixStream> 
inner			mod inner 
inner			    fn inner(s: &OsStr) -> io::Result<Vec<u16>> 
inner_mut			    unsafe fn inner_mut(&self) -> &mut Flavor<T> 
inner_unsafe			    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> 
inner_unsafe			    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>>;
ino			    fn ino(&self) -> u64 { self.as_inner().ino() }
ino			    fn ino(&self) -> u64 { self.st_ino() }
ino			    fn ino(&self) -> u64;
ino			    pub fn ino(&self) -> u64 
insert			    pub fn insert(&mut self, k: K, v: V) -> Option<V> 
insert			    pub fn insert(&mut self, mut value: V) -> V 
insert			    pub fn insert(self, value: V) -> &'a mut V 
insert			    pub fn insert(&mut self, value: T) -> bool 
insert_hashed_nocheck			    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> 
insert_hashed_ordered			    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) 
inspect			    pub fn inspect(&self) -> HashUint 
instant_duration_panic			    fn instant_duration_panic() 
instant_elapsed			    fn instant_elapsed() 
instant_math			    fn instant_math() 
instant_monotonic			    fn instant_monotonic() 
integer_decode			    pub fn integer_decode(self) -> (u64, i16, i8) 
integer_decode			    pub fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }
intersection			    fn intersection<'a, 'new>(v: Intersection<'a, &'static str, RandomState>)
intersection			    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> 
intervals			    fn intervals(&self) -> i64 
intervals2dur			fn intervals2dur(intervals: u64) -> Duration 
into			    fn into() 
into_bucket			    pub fn into_bucket(self) -> Bucket<K, V, M> 
into_bytes			    pub fn into_bytes(self) -> Vec<u8> 
into_bytes_with_nul			    pub fn into_bytes_with_nul(self) -> Vec<u8> 
into_cstring			    pub fn into_cstring(self) -> CString 
into_entry			    fn into_entry(self, key: K) -> Option<Entry<'a, K, V>> 
into_fd			    pub fn into_fd(self) -> FileDesc { self.0 }
into_fd			    pub fn into_fd(self) -> FileDesc { self.0 }
into_fd			    pub fn into_fd(self) -> FileDesc { self.0 }
into_fd			    pub fn into_fd(self) -> FileDesc { self.0 }
into_handle			    pub fn into_handle(self) -> Handle { self.handle }
into_handle			    pub fn into_handle(self) -> Handle { self.inner }
into_handle			    pub fn into_handle(self) -> Handle { self.handle }
into_handle			    pub fn into_handle(self) -> Handle { self.handle }
into_id			    pub fn into_id(self) -> usize 
into_id			    pub fn into_id(self) -> libc::pthread_t 
into_inner			    fn into_inner(self) -> Box<[u8]> 
into_inner			    fn into_inner(self) -> Buf 
into_inner			    fn into_inner(self) -> fs_imp::File 
into_inner			    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> 
into_inner			    pub fn into_inner(self) -> R { self.inner }
into_inner			    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> 
into_inner			    pub fn into_inner(self) -> W { self.0 }
into_inner			    pub fn into_inner(self) -> T { self.inner }
into_inner			    pub fn into_inner(self) -> Option<Box<error::Error+Send+Sync>> 
into_inner			    pub fn into_inner(self) -> T 
into_inner			    fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) 
into_inner			    fn into_inner(self) -> net_imp::TcpListener { self.0 }
into_inner			    fn into_inner(self) -> net_imp::TcpStream { self.0 }
into_inner			    fn into_inner(self) -> net_imp::UdpSocket { self.0 }
into_inner			    fn into_inner(self) -> AnonPipe { self.inner }
into_inner			    fn into_inner(self) -> imp::Process { self.handle }
into_inner			    pub fn into_inner(self) -> LockResult<T> where T: Sized 
into_inner			    pub fn into_inner(self) -> LockResult<T> where T: Sized 
into_inner			    fn into_inner(self) -> Vec<u8> 
into_inner			    fn into_inner(self) -> c_int { self.0.into_raw() }
into_inner			    fn into_inner(self) -> Vec<u8> 
into_inner			    fn into_inner(self) -> c::SOCKET 
into_inner			    fn into_inner(self) -> Wtf8Buf 
into_inner			    fn into_inner(self) -> Inner;
into_inner			    pub fn into_inner(self) -> T { self.guard }
into_inner			    fn into_inner(self) -> imp::Thread { self.0.native.unwrap() }
into_iter			    fn into_iter(mut self) -> IterMut<'a, K, V> 
into_iter			    fn into_iter(self) -> IntoIter<K, V> 
into_iter			    fn into_iter(self) -> Iter<'a, K, V> 
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> 
into_iter			    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> 
into_iter			    pub fn into_iter(self) -> IntoIter<K, V> 
into_iter			    fn into_iter(self) -> Iter<'a> { self.iter() }
into_iter			    fn into_iter(self) -> IntoIter<T> 
into_iter			    fn into_iter(self) -> Iter<'a, T> { self.iter() }
into_iter			    fn into_iter(self) -> Incoming<'a> 
into_iter_key			    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> 
into_iter_val			    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> 
into_key			    pub fn into_key(self) -> K 
into_mut			    pub fn into_mut(self) -> &'a mut V 
into_mut_refs			    pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) 
into_occupied_bucket			    fn into_occupied_bucket(self) -> Option<FullBucket<K, V, M>> 
into_os_string			    pub fn into_os_string(self) -> OsString 
into_pthread_t			    fn into_pthread_t(self) -> RawPthread 
into_pthread_t			    fn into_pthread_t(self) -> RawPthread;
into_raw			    pub fn into_raw(self) -> *mut c_char 
into_raw			    pub fn into_raw(self) -> usize 
into_raw			    pub fn into_raw(self) -> c_int 
into_raw			    pub fn into_raw(self) -> c::HANDLE 
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_fd			    fn into_raw_fd(self) -> RawFd;
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_fd			    fn into_raw_fd(self) -> RawFd;
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_fd			    fn into_raw_fd(self) -> RawFd 
into_raw_handle			    fn into_raw_handle(self) -> RawHandle 
into_raw_handle			    fn into_raw_handle(self) -> RawHandle;
into_raw_handle			    fn into_raw_handle(self) -> RawHandle 
into_raw_handle			    fn into_raw_handle(self) -> RawHandle 
into_raw_socket			    fn into_raw_socket(self) -> RawSocket 
into_raw_socket			    fn into_raw_socket(self) -> RawSocket;
into_refs			    pub fn into_refs(self) -> (&'t K, &'t V) 
into_socket			    pub fn into_socket(self) -> Socket { self.inner }
into_string			    pub fn into_string(self) -> Result<String, IntoStringError> 
into_string			    pub fn into_string(self) -> Result<String, OsString> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string			    pub fn into_string(self) -> Result<String, Buf> 
into_string			    pub fn into_string(self) -> Result<String, Wtf8Buf> 
into_string_lossy			    pub fn into_string_lossy(mut self) -> String 
into_table			    pub fn into_table(self) -> M 
into_vec			    pub fn into_vec(self) -> Vec<u8> { self.1 }
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8>;
into_vec			    fn into_vec(self) -> Vec<u8> 
into_vec			    fn into_vec(self) -> Vec<u8>;
invalid_encoding			fn invalid_encoding() -> io::Error 
invalid_path_raises			    fn invalid_path_raises() 
io			pub mod io;
io			pub mod io;
io			pub mod io;
io			impl<'a> io::Read for &'a UnixStream 
io			impl<'a> io::Write for &'a UnixStream 
io			pub mod io;
io			pub mod io;
io::Read for Maybe			impl<R: io::Read> io::Read for Maybe<R> 
io::Read for UnixStream			impl io::Read for UnixStream 
io::Seek for Cursor			impl<T> io::Seek for Cursor<T> where T: AsRef<[u8]> 
io::Write for Maybe			impl<W: io::Write> io::Write for Maybe<W> 
io::Write for Stderr			impl io::Write for Stderr 
io::Write for Stderr			impl io::Write for Stderr 
io::Write for Stderr			impl io::Write for Stderr 
io::Write for UnixStream			impl io::Write for UnixStream 
ioctlsocket			    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;
ip			    pub fn ip(&self) -> &Ipv4Addr 
ip			    pub fn ip(&self) -> &Ipv6Addr 
ip			    pub fn ip(&self) -> IpAddr 
ip			mod ip;
ip4			        fn ip4(low: u8) -> Ipv4Addr { Ipv4Addr::new(77, 88, 21, low) }
ip6			        fn ip6(low: u16) -> Ipv6Addr { Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low) }
ip_mreq			pub struct ip_mreq 
ip_properties			    fn ip_properties() 
ipv4_from_u32_slice			    fn ipv4_from_u32_slice() 
ipv4_properties			    fn ipv4_properties() 
ipv4_to_ipv6			    fn ipv4_to_ipv6() 
ipv6_addr_from_head_tail			        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr 
ipv6_addr_to_string			    fn ipv6_addr_to_string() 
ipv6_mreq			pub struct ipv6_mreq 
ipv6_properties			    fn ipv6_properties() 
ipv6_to_ipv4			    fn ipv6_to_ipv4() 
is			    pub fn is<T: Error + 'static>(&self) -> bool 
is			    pub fn is(&self, mode: u16) -> bool 
is			    pub fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }
is_absolute			    pub fn is_absolute(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool { *self & 128 == 0 }
is_ascii			    fn is_ascii(&self) -> bool 
is_ascii			    fn is_ascii(&self) -> bool;
is_ascii			    fn is_ascii(&self) -> bool 
is_block_device			    fn is_block_device(&self) -> bool { false \/*FIXME: Implement block device mode*\/ }
is_block_device			    fn is_block_device(&self) -> bool;
is_block_device			    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }
is_block_device			    fn is_block_device(&self) -> bool;
is_broadcast			    pub fn is_broadcast(&self) -> bool 
is_char_device			    fn is_char_device(&self) -> bool { false \/*FIXME: Implement char device mode*\/ }
is_char_device			    fn is_char_device(&self) -> bool;
is_char_device			    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }
is_char_device			    fn is_char_device(&self) -> bool;
is_code_point_boundary			pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool 
is_colon			    fn is_colon(b: &u8) -> bool { *b == b':' }
is_colon			    fn is_colon(b: &u8) -> bool { *b == b':' }
is_dir			    pub fn is_dir(&self) -> bool { self.0.is_dir() }
is_dir			    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }
is_dir			    pub fn is_dir(&self) -> bool 
is_dir			    pub fn is_dir(&self) -> bool { self.is(syscall::MODE_DIR) }
is_dir			    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }
is_dir			    pub fn is_dir(&self) -> bool { *self == FileType::Dir }
is_disjoint			    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool 
is_documentation			    pub fn is_documentation(&self) -> bool 
is_drive			    fn is_drive(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    fn is_empty(&self) -> bool { self.inner.is_empty() }
is_empty			    pub fn is_empty(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool 
is_eof			    fn is_eof(&self) -> bool 
is_fifo			    fn is_fifo(&self) -> bool { false \/*FIXME: Implement fifo mode*\/ }
is_fifo			    fn is_fifo(&self) -> bool;
is_fifo			    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }
is_fifo			    fn is_fifo(&self) -> bool;
is_file			    pub fn is_file(&self) -> bool { self.0.is_file() }
is_file			    pub fn is_file(&self) -> bool { self.file_type().is_file() }
is_file			    pub fn is_file(&self) -> bool 
is_file			    pub fn is_file(&self) -> bool { self.is(syscall::MODE_FILE) }
is_file			    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }
is_file			    pub fn is_file(&self) -> bool { *self == FileType::File }
is_finite			    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_finite			    pub fn is_finite(self) -> bool { num::Float::is_finite(self) }
is_getrandom_available			    fn is_getrandom_available() -> bool { false }
is_getrandom_available			    fn is_getrandom_available() -> bool 
is_global			    pub fn is_global(&self) -> bool 
is_infinite			    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_infinite			    pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }
is_ipv4			    pub fn is_ipv4(&self) -> bool 
is_ipv4			    pub fn is_ipv4(&self) -> bool 
is_ipv6			    pub fn is_ipv6(&self) -> bool 
is_ipv6			    pub fn is_ipv6(&self) -> bool 
is_leader			    pub fn is_leader(&self) -> bool { self.0 }
is_link_local			    pub fn is_link_local(&self) -> bool 
is_loopback			    pub fn is_loopback(&self) -> bool 
is_minus_one			        fn is_minus_one(&self) -> bool 
is_minus_one			    fn is_minus_one(&self) -> bool;
is_minus_one			        fn is_minus_one(&self) -> bool 
is_minus_one			    fn is_minus_one(&self) -> bool;
is_multicast			    pub fn is_multicast(&self) -> bool 
is_mutex			    fn is_mutex() 
is_nan			    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_nan			    pub fn is_nan(self) -> bool { num::Float::is_nan(self) }
is_negative			    pub fn is_negative(self) -> bool { num::Float::is_sign_negative(self) }
is_normal			    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_normal			    pub fn is_normal(self) -> bool { num::Float::is_normal(self) }
is_poisoned			    pub fn is_poisoned(&self) -> bool 
is_poisoned			    pub fn is_poisoned(&self) -> bool 
is_positive			    pub fn is_positive(self) -> bool { num::Float::is_sign_positive(self) }
is_private			    pub fn is_private(&self) -> bool 
is_relative			    pub fn is_relative(&self) -> bool 
is_reparse_point			    fn is_reparse_point(&self) -> bool 
is_sep_byte			    fn is_sep_byte(&self, b: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(b: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(b: u8) -> bool 
is_sep_byte			pub fn is_sep_byte(b: u8) -> bool 
is_separator			pub fn is_separator(c: char) -> bool 
is_sign_negative			    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }
is_sign_negative			    pub fn is_sign_negative(self) -> bool { num::Float::is_sign_negative(self) }
is_sign_positive			    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }
is_sign_positive			    pub fn is_sign_positive(self) -> bool { num::Float::is_sign_positive(self) }
is_socket			    fn is_socket(&self) -> bool { false \/*FIXME: Implement socket mode*\/ }
is_socket			    fn is_socket(&self) -> bool;
is_socket			    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }
is_socket			    fn is_socket(&self) -> bool;
is_subset			    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool 
is_superset			    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool 
is_symlink			    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }
is_symlink			    pub fn is_symlink(&self) -> bool { false \/*FIXME: Implement symlink mode*\/ }
is_symlink			    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }
is_symlink			    pub fn is_symlink(&self) -> bool 
is_symlink_dir			    pub fn is_symlink_dir(&self) -> bool 
is_unicast_global			    pub fn is_unicast_global(&self) -> bool 
is_unicast_link_local			    pub fn is_unicast_link_local(&self) -> bool 
is_unicast_site_local			    pub fn is_unicast_site_local(&self) -> bool 
is_unique_local			    pub fn is_unique_local(&self) -> bool 
is_unnamed			    pub fn is_unnamed(&self) -> bool 
is_unspecified			    pub fn is_unspecified(&self) -> bool 
is_v4			    fn is_v4() 
is_v4			    fn is_v4() 
is_v6			    fn is_v6() 
is_v6			    fn is_v6() 
is_verbatim			    pub fn is_verbatim(&self) -> bool 
is_verbatim_sep			pub fn is_verbatim_sep(b: u8) -> bool 
is_verbatim_sep			pub fn is_verbatim_sep(b: u8) -> bool 
is_verbatim_sep			pub fn is_verbatim_sep(b: u8) -> bool 
is_zero			        fn is_zero(&self) -> bool 
is_zero			    fn is_zero(&self) -> bool;
issue_15761			    fn issue_15761() 
issue_32114			    fn issue_32114() 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    pub fn iter(&self) -> Iter<K, V> 
iter			    pub fn iter(&self) -> Iter 
iter			    pub fn iter(&self) -> Iter<T> 
iter			    fn iter(&self) -> Packets { Packets { cur: unsafe { &*self.inner.get() }.head } }
iter			    fn iter() 
iter_after			fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I>
iter_key			    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_mut			    pub fn iter_mut(&mut self) -> IterMut<K, V> 
iter_val			    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> 
j0			        pub fn j0(n: c_double) -> c_double;
j1			        pub fn j1(n: c_double) -> c_double;
jn			        pub fn jn(i: c_int, n: c_double) -> c_double;
join			    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf 
join			    pub fn join(self) 
join			    pub fn join(self) 
join			    pub fn join(self) 
join			        pub fn join(&self, path: &str) -> PathBuf 
join			    fn join(&mut self) -> Result<T> 
join			    pub fn join(mut self) -> Result<T> 
join_multicast_v4			    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> 
join_multicast_v4			    pub fn join_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> 
join_multicast_v4			    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)
join_multicast_v6			    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> 
join_multicast_v6			    pub fn join_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> 
join_multicast_v6			    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths			pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>
join_paths_unix			    fn join_paths_unix() 
join_paths_windows			    fn join_paths_windows() 
key			    pub fn key(&self) -> &K 
key			    unsafe fn key(&self) -> imp::Key 
keys			    pub fn keys(&self) -> Keys<K, V> 
keys			unsafe fn keys() -> &'static mut BTreeMap<Key, Option<Dtor>> 
keys_key			    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> 
keys_val			    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kill			    pub fn kill(&mut self) -> io::Result<()> 
kind			    pub fn kind(&self) -> ErrorKind 
kind			    pub fn kind(&self) -> Prefix<'a> 
kind			fn kind() -> Kind 
lang_start			fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize 
last_access_time			    fn last_access_time(&self) -> u64 { self.as_inner().accessed_u64() }
last_access_time			    fn last_access_time(&self) -> u64;
last_error			fn last_error() -> io::Error 
last_os_error			    pub fn last_os_error() -> Error 
last_write_time			    fn last_write_time(&self) -> u64 { self.as_inner().modified_u64() }
last_write_time			    fn last_write_time(&self) -> u64;
launchpad_add_vdso_vmo			    pub fn launchpad_add_vdso_vmo(lp: *mut launchpad_t) -> mx_status_t;
launchpad_arguments			    pub fn launchpad_arguments(lp: *mut launchpad_t, argc: c_int,
launchpad_clone_fd			    pub fn launchpad_clone_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;
launchpad_clone_mxio_cwd			    pub fn launchpad_clone_mxio_cwd(lp: *mut launchpad_t) -> mx_status_t;
launchpad_clone_mxio_root			    pub fn launchpad_clone_mxio_root(lp: *mut launchpad_t) -> mx_status_t;
launchpad_create			    pub fn launchpad_create(job: mx_handle_t, name: *const c_char,
launchpad_destroy			    pub fn launchpad_destroy(lp: *mut launchpad_t);
launchpad_elf_load			    pub fn launchpad_elf_load(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;
launchpad_environ			    pub fn launchpad_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> mx_status_t;
launchpad_load_vdso			    pub fn launchpad_load_vdso(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;
launchpad_start			    pub fn launchpad_start(lp: *mut launchpad_t) -> mx_status_t;
launchpad_t			pub struct launchpad_t 
launchpad_transfer_fd			    pub fn launchpad_transfer_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;
launchpad_vmo_from_file			    pub fn launchpad_vmo_from_file(filename: *const c_char) -> mx_handle_t;
lazy			mod lazy;
lazy_init			    unsafe fn lazy_init(&self) -> usize 
ldexp			    pub fn ldexp(x: f32, exp: isize) -> f32 
ldexp			        pub fn ldexp(x: c_double, n: c_int) -> c_double;
ldexp			    pub fn ldexp(x: f64, exp: isize) -> f64 
ldexpf			        pub fn ldexpf(x: c_float, n: c_int) -> c_float;
ldexpf			        pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float 
le			    fn le(&self, other: &OsStr) -> bool { self.bytes().le(other.bytes()) }
le			    fn le(&self, other: &OsString) -> bool { &**self <= &**other }
leave_multicast_v4			    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> 
leave_multicast_v4			    pub fn leave_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> 
leave_multicast_v4			    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)
leave_multicast_v6			    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> 
leave_multicast_v6			    pub fn leave_multicast_v6(&self, _multiaddr: &Ipv6Addr, _interface: u32) -> Result<()> 
leave_multicast_v6			    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> usize 
len			    fn len(&self) -> usize 
len			    pub fn len(&self) -> usize 
len			    fn len(&self) -> usize 
len			    fn len(&self) -> usize { self.inner.len() }
len			    pub fn len(&self) -> usize 
len			    pub fn len(&self) -> u64 { self.0.size() }
len			    fn len(&self) -> usize 
len			    fn len(&self) -> usize { self.iter.len() }
len			    fn len(&self) -> usize { self.iter.len() }
len			    fn len(&self) -> usize { self.range.len() }
len			    pub fn len(&self) -> usize 
len_before_body			    fn len_before_body(&self) -> usize 
lgamma_r			        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;
lgammaf_r			        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;
libbacktrace			pub mod libbacktrace;
limit			    pub fn limit(&self) -> u64 { self.limit }
line			    pub fn line(&self) -> u32 
lines			    fn lines() 
lines			    fn lines(self) -> Lines<Self> where Self: Sized 
link			pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> 
link			pub fn link(src: &Path, dst: &Path) -> io::Result<()> 
link			pub fn link(src: &Path, dst: &Path) -> io::Result<()> 
links_work			    fn links_work() 
listen			    pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;
listen_localhost			    fn listen_localhost() 
ln			    pub fn ln(self) -> f32 
ln			    pub fn ln(self) -> f64 
ln_1p			    pub fn ln_1p(self) -> f32 
ln_1p			    pub fn ln_1p(self) -> f64 
load			            fn load() -> usize 
local_addr			    pub fn local_addr(&self) -> io::Result<SocketAddr> 
local_addr			    pub fn local_addr(&self) -> io::Result<SocketAddr> 
local_addr			    pub fn local_addr(&self) -> io::Result<SocketAddr> 
locals			unsafe fn locals() -> &'static mut BTreeMap<Key, *mut u8> 
location			    pub fn location(&self) -> Option<&Location> 
lock			    pub fn lock(&self) -> StderrLock 
lock			    pub fn lock(&self) -> StdinLock 
lock			    pub fn lock(&self) -> StdoutLock 
lock			    pub fn lock(&self) -> LockResult<MutexGuard<T>> 
lock			    pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock(&self) 
lock			    pub unsafe fn lock(&self) { self.0.lock() }
lock			    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<T>> 
log			    pub fn log(self, base: f32) -> f32 { self.ln() \/ base.ln() }
log			    pub fn log(self, base: f64) -> f64 { self.ln() \/ base.ln() }
log10			    pub fn log10(self) -> f32 
log10			    pub fn log10(self) -> f64 
log1p			        pub fn log1p(n: c_double) -> c_double;
log1pf			        pub fn log1pf(n: c_float) -> c_float;
log2			    pub fn log2(self) -> f32 
log2			    pub fn log2(self) -> f64 
log2f32			pub fn log2f32(f: f32) -> f32 
log2f64			pub fn log2f64(f: f64) -> f64 
log_enabled			pub fn log_enabled() -> bool 
log_wrapper			    fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 
logb			        pub fn logb(n: c_double) -> c_double;
logbf			        pub fn logbf(n: c_float) -> c_float;
long_path			    fn long_path() 
lookup			pub fn lookup(module: &str, symbol: &str) -> Option<usize> 
lookup_host			pub fn lookup_host(host: &str) -> io::Result<LookupHost> 
lookup_host			pub fn lookup_host(host: &str) -> Result<LookupHost> 
lookup_host			pub fn lookup_host(host: &str) -> io::Result<LookupHost> 
lots_and_lots			    fn lots_and_lots() 
lstat			pub fn lstat(p: &Path) -> io::Result<FileAttr> 
lstat			pub fn lstat(p: &Path) -> io::Result<FileAttr> 
lstat			pub fn lstat(path: &Path) -> io::Result<FileAttr> 
lt			    fn lt(&self, other: &OsStr) -> bool { self.bytes().lt(other.bytes()) }
lt			    fn lt(&self, other: &OsString) -> bool { &**self < &**other }
macros			mod macros;
magenta			mod magenta;
main			fn main() 
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) 
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self);
make_ascii_lowercase			    fn make_ascii_lowercase(&mut self) { self.bytes.make_ascii_lowercase() }
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) 
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self);
make_ascii_uppercase			    fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }
make_command_line			fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> 
make_dirp			fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> 
make_envp			fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)
make_handler			    pub unsafe fn make_handler() -> Handler 
make_handler			    pub unsafe fn make_handler() -> super::Handler 
make_hash			    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash
make_hash			pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash
make_rand_name			    fn make_rand_name() -> OsString 
map			pub mod map;
map			        fn map() -> RefCell<HashMap<i32, i32>> 
map_key			    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> 
map_result			pub fn map_result<T, U, F>(result: LockResult<T>, f: F)
map_val			    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> 
matches_begin			    fn matches_begin() 
matches_begin			    fn matches_begin() 
matches_begin_reversed			    fn matches_begin_reversed() 
matches_begin_reversed			    fn matches_begin_reversed() 
matches_end			    fn matches_end() 
matches_end			    fn matches_end() 
matches_end_reversed			    fn matches_end_reversed() 
matches_end_reversed			    fn matches_end_reversed() 
matches_nul			    fn matches_nul() 
matches_nul			    fn matches_nul() 
matches_nul_reversed			    fn matches_nul_reversed() 
matches_nul_reversed			    fn matches_nul_reversed() 
matches_one			    fn matches_one() 
matches_one			    fn matches_one() 
matches_one_reversed			    fn matches_one_reversed() 
matches_one_reversed			    fn matches_one_reversed() 
matches_past_nul			    fn matches_past_nul() 
matches_past_nul			    fn matches_past_nul() 
matches_past_nul_reversed			    fn matches_past_nul_reversed() 
matches_past_nul_reversed			    fn matches_past_nul_reversed() 
max			    pub fn max(self, other: f32) -> f32 
max			    pub fn max(self, other: f64) -> f64 
memchr			mod memchr;
memchr			pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> 
memchr			pub mod memchr;
memchr			pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> 
memchr			pub mod memchr;
memchr			pub mod memchr;
memchr			    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> 
memchr			pub mod memchr;
memrchr			pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> 
memrchr			pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> 
memrchr			    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> 
memrchr_specific			    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> 
metadata			    pub fn metadata(&self) -> io::Result<Metadata> 
metadata			pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> 
metadata			    pub fn metadata(&self) -> io::Result<fs::Metadata> 
metadata			    pub fn metadata(&self) -> io::Result<FileAttr> 
metadata			    pub fn metadata(&self) -> io::Result<FileAttr> 
metadata			    pub fn metadata(&self) -> io::Result<FileAttr> 
metadata_access_times			    fn metadata_access_times() 
min			    pub fn min(self, other: f32) -> f32 
min			    pub fn min(self, other: f64) -> f64 
min_stack			pub fn min_stack() -> usize 
min_stack_size			fn min_stack_size(_: *const libc::pthread_attr_t) -> usize 
min_stack_size			fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize 
mk_key			fn mk_key(s: &OsStr) -> OsString 
mkdir			    pub fn mkdir(&self, p: &Path) -> io::Result<()> 
mkdir			    pub fn mkdir(&self, p: &Path) -> io::Result<()> 
mkdir			    pub fn mkdir(&self, p: &Path) -> io::Result<()> 
mkdir_path_already_exists_error			    fn mkdir_path_already_exists_error() 
mkdir_trailing_slash			    fn mkdir_trailing_slash() 
mode			    fn mode(&mut self, mode: u32) -> &mut OpenOptions 
mode			    fn mode(&mut self, mode: u32) -> &mut Self;
mode			    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder 
mode			    fn mode(&self) -> u32 
mode			    fn mode(&self) -> u32;
mode			    pub fn mode(&mut self, mode: u32) { self.mode = mode as u16; }
mode			    pub fn mode(&self) -> u32 { self.mode as u32 }
mode			    fn mode(&mut self, mode: u32) -> &mut OpenOptions 
mode			    fn mode(&mut self, mode: u32) -> &mut Self;
mode			    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder 
mode			    fn mode(&self) -> u32 { self.st_mode() }
mode			    fn mode(&self) -> u32 
mode			    fn mode(&self) -> u32;
mode			    pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }
mode			    pub fn mode(&self) -> u32 { self.mode as u32 }
modf			        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;
modff			        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;
modified			    pub fn modified(&self) -> io::Result<SystemTime> 
modified			    pub fn modified(&self) -> io::Result<SystemTime> 
modified			    pub fn modified(&self) -> io::Result<SystemTime> 
modified			    pub fn modified(&self) -> io::Result<SystemTime> 
modified_u64			    pub fn modified_u64(&self) -> u64 
mpsc			pub mod mpsc;
mpsc_queue			mod mpsc_queue;
mtime			    fn mtime(&self) -> i64 
mtime			    fn mtime(&self) -> i64;
mtime			    fn mtime(&self) -> i64 { self.st_mtime() }
mtime			    fn mtime(&self) -> i64;
mtime_nsec			    fn mtime_nsec(&self) -> i64 
mtime_nsec			    fn mtime_nsec(&self) -> i64;
mtime_nsec			    fn mtime_nsec(&self) -> i64 { self.st_mtime_nsec() }
mtime_nsec			    fn mtime_nsec(&self) -> i64;
mul			    fn mul() 
mul			    fn mul(self, rhs: u32) -> Duration 
mul_add			    pub fn mul_add(self, a: f32, b: f32) -> f32 
mul_add			    pub fn mul_add(self, a: f64, b: f64) -> f64 
mul_assign			    fn mul_assign(&mut self, rhs: u32) 
mul_div_u64			pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 
multicast_loop_v4			    pub fn multicast_loop_v4(&self) -> io::Result<bool> 
multicast_loop_v4			    pub fn multicast_loop_v4(&self) -> Result<bool> 
multicast_loop_v4			    pub fn multicast_loop_v4(&self) -> io::Result<bool> 
multicast_loop_v6			    pub fn multicast_loop_v6(&self) -> io::Result<bool> 
multicast_loop_v6			    pub fn multicast_loop_v6(&self) -> Result<bool> 
multicast_loop_v6			    pub fn multicast_loop_v6(&self) -> io::Result<bool> 
multicast_scope			    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> 
multicast_ttl_v4			    pub fn multicast_ttl_v4(&self) -> io::Result<u32> 
multicast_ttl_v4			    pub fn multicast_ttl_v4(&self) -> Result<u32> 
multicast_ttl_v4			    pub fn multicast_ttl_v4(&self) -> io::Result<u32> 
multiple_connect_interleaved_greedy_schedule			    fn multiple_connect_interleaved_greedy_schedule() 
multiple_connect_interleaved_lazy_schedule			    fn multiple_connect_interleaved_lazy_schedule() 
multiple_connect_serial			    fn multiple_connect_serial() 
mutex			mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
mutex			pub mod mutex;
mutex_lock			pub unsafe fn mutex_lock(m: *mut i32) 
mutex_try_lock			pub unsafe fn mutex_try_lock(m: *mut i32) -> bool 
mutex_unlock			pub unsafe fn mutex_unlock(m: *mut i32) 
mx_cprng_draw			        fn mx_cprng_draw(buffer: *mut u8, len: usize, actual: *mut usize) -> i32;
mx_cvt			pub fn mx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<mx_status_t>+Copy 
mx_handle_close			    pub fn mx_handle_close(handle: mx_handle_t) -> mx_status_t;
mx_handle_duplicate			    pub fn mx_handle_duplicate(handle: mx_handle_t, rights: mx_rights_t,
mx_handle_wait_one			    pub fn mx_handle_wait_one(handle: mx_handle_t, signals: mx_signals_t, timeout: mx_time_t,
mx_hnd_info			pub fn mx_hnd_info(hnd_type: u32, arg: u32) -> u32 
mx_info_header_t			pub struct mx_info_header_t 
mx_info_process_t			pub struct mx_info_process_t 
mx_object_get_info			    pub fn mx_object_get_info(handle: mx_handle_t, topic: u32, buffer: *mut c_void,
mx_record_process_t			pub struct mx_record_process_t 
mx_task_kill			    pub fn mx_task_kill(handle: mx_handle_t) -> mx_status_t;
mxio_get_startup_handle			    pub fn mxio_get_startup_handle(id: u32) -> mx_handle_t;
n16			impl n16 
n16			pub struct n16 
naive_pow			        fn naive_pow<T: Mul<Output=T> + Copy>(one: T, base: T, exp: usize) -> T 
name			    pub fn name(&self) -> Option<&str> 
name			    pub fn name(mut self, name: String) -> Builder 
name_bytes			    fn name_bytes(&self) -> &[u8] 
name_bytes			    fn name_bytes(&self) -> &[u8] 
nanos			    fn nanos() 
net			pub mod net;
net			pub mod net;
net			pub mod net;
net			pub mod net;
net			pub mod net;
net			pub mod net;
netc			pub mod netc 
new			        fn new(k: usize) -> Dropable 
new			    fn new() -> DefaultResizePolicy 
new			    pub fn new() -> DefaultHasher 
new			    pub fn new() -> HashMap<K, V, RandomState> 
new			    pub fn new() -> RandomState 
new			    pub fn new() -> HashSet<T, RandomState> 
new			    pub fn new(capacity: usize) -> RawTable<K, V> 
new			    pub fn new(hash: u64) -> Self 
new			    pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> 
new			    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> 
new			    pub fn new() -> OsString 
new			    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr 
new			    pub fn new() -> DirBuilder 
new			    pub fn new() -> OpenOptions 
new			    pub fn new(inner: R) -> BufReader<R> 
new			    pub fn new(inner: W) -> BufWriter<W> 
new			    pub fn new(inner: W) -> LineWriter<W> 
new			    pub fn new(inner: T) -> Cursor<T> 
new			    pub fn new<E>(kind: ErrorKind, error: E) -> Error
new			    pub fn new(ip: IpAddr, port: u16) -> SocketAddr 
new			    pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 
new			    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32)
new			    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,
new			    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr 
new			    fn new(s: &'a str) -> Parser<'a> 
new			    pub fn new() -> PathBuf 
new			    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path 
new			    pub fn new<S: AsRef<OsStr>>(program: S) -> Command 
new			    pub fn new() -> io::Result<OsRng> 
new			    pub fn new() -> io::Result<StdRng> 
new			    pub fn new(r: R) -> ReaderRng<R> 
new			    pub fn new(n: usize) -> Barrier 
new			    pub fn new() -> Condvar 
new			    fn new(inner: Arc<sync::Packet<T>>) -> SyncSender<T> 
new			    fn new(inner: Flavor<T>) -> Receiver<T> 
new			    fn new(inner: Flavor<T>) -> Sender<T> 
new			    pub fn new() -> Queue<T> 
new			    unsafe fn new(v: Option<T>) -> *mut Node<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new() -> Select 
new			    pub fn new() -> Packet<T> 
new			    fn new() -> *mut Node<T> 
new			    pub unsafe fn new(bound: usize) -> Queue<T> 
new			    pub fn new() -> Packet<T> 
new			    pub fn new(cap: usize) -> Packet<T> 
new			    pub fn new(t: T) -> Mutex<T> 
new			    unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> 
new			    pub fn new(t: T) -> RwLock<T> 
new			    unsafe fn new(lock: &'rwlock RwLock<T>)
new			    pub fn new(fd: usize) -> FileDesc 
new			    pub fn new() -> DirBuilder 
new			    pub fn new() -> OpenOptions 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub fn new() -> io::Result<OsRng> 
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }
new			    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }
new			    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }
new			    pub unsafe fn new<'a>(_stack: usize, p: Box<FnBox() + 'a>) -> io::Result<Thread> 
new			    fn new<F>(f: F) -> io::Result<SocketAddr>
new			    pub fn new(fd: c_int) -> FileDesc 
new			    pub fn new() -> DirBuilder 
new			    pub fn new() -> OpenOptions 
new			    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> 
new			    pub fn new(raw: mx_handle_t) -> Handle 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub fn new(status: c_int) -> ExitStatus 
new			        pub fn new() -> io::Result<OsRng> 
new			    pub unsafe fn new() -> Handler 
new			    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }
new			    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }
new			    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }
new			    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>)
new			    fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType 
new			    fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> 
new			    pub fn new() -> DirBuilder { DirBuilder }
new			    pub fn new() -> OpenOptions 
new			    pub fn new(handle: c::HANDLE) -> Handle 
new			    pub fn new(handle: c::HANDLE) -> RawHandle 
new			    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> 
new			    fn new(pipe: Handle, dst: &'a mut Vec<u8>) -> io::Result<AsyncPipe<'a>> 
new			    fn new(lock: &'a Mutex) -> DropGuard<'a> 
new			    pub fn new(program: &OsStr) -> Command 
new			    pub fn new() -> io::Result<OsRng> 
new			    pub unsafe fn new() -> Handler 
new			    fn new(handle: c::HANDLE) -> NoClose 
new			    pub fn new() -> io::Result<Stderr> 
new			    pub fn new() -> io::Result<Stdin> 
new			    pub fn new() -> io::Result<Stdout> 
new			    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>)
new			    pub fn new(guard: T) -> PoisonError<T> 
new			    fn new(lock: &'mutex ReentrantMutex<T>)
new			    pub fn new(t: T) -> ReentrantMutex<T> 
new			    fn new(name: Option<String>) -> Self;
new			    pub fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> Key 
new			    pub fn new() -> Wtf8Buf 
new			    fn new() -> ThreadId 
new			    fn new(name: Option<String>) -> Thread { Thread::new(name) }
new			    fn new(name: Option<String>) -> Thread 
new			    pub fn new() -> Builder 
new			    pub fn new(secs: u64, nanos: u32) -> Duration 
new_drop			fn new_drop(b: &mut Bencher) 
new_event			    pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> 
new_insert_drop			fn new_insert_drop(b: &mut Bencher) 
new_pair			    pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> 
new_raw			    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> 
new_uninitialized			    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> 
next			    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }
next			    fn next(&mut self) -> Option<(&'a K)> 
next			    fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			    fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			    fn next(&mut self) -> Option<(&'a V)> 
next			    fn next(&mut self) -> Option<(&'a mut V)> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<&'a K> 
next			    fn next(&mut self) -> Option<&'a T> 
next			    fn next(&mut self) -> Option<K> 
next			    fn next(&mut self) -> Option<(&'a K, &'a V)> 
next			    fn next(&mut self) -> Option<(&'a K, &'a mut V)> 
next			    fn next(&mut self) -> Option<(K, V)> 
next			    fn next(&mut self) -> Option<(SafeHash, K, V)> 
next			    fn next(&mut self) -> Option<RawBucket<K, V>> 
next			    pub fn next(&mut self) 
next			    pub fn next(self) -> Bucket<K, V, M> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }
next			    fn next(&mut self) -> Option<(String, String)> 
next			    fn next(&mut self) -> Option<OsString> { self.inner.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }
next			    fn next(&mut self) -> Option<String> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<Result<String>> 
next			    fn next(&mut self) -> Option<Result<Vec<u8>>> 
next			    fn next(&mut self) -> Option<Result<u8>> 
next			    fn next(&mut self) -> Option<result::Result<char, CharsError>> 
next			    fn next(&mut self) -> Option<SocketAddr> { self.0.next() }
next			    fn next(&mut self) -> Option<io::Result<TcpStream>> 
next			    fn next(&mut self) -> Option<&'a OsStr> 
next			    fn next(&mut self) -> Option<Component<'a>> 
next			    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }
next			    fn next(&mut self) -> Option<T> { self.rx.try_recv().ok() }
next			    fn next(&mut self) -> Option<*mut Handle<'static, ()>> 
next			    fn next(&mut self) -> Option<OsString> { self.iter.next() }
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<Self::Item> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }
next			    fn next(&mut self) -> Option<OsString> { self.iter.next() }
next			    fn next(&mut self) -> Option<io::Result<UnixStream>> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }
next			    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }
next			    fn next(&mut self) -> Option<OsString> 
next			    fn next(&mut self) -> Option<io::Result<DirEntry>> 
next			    fn next(&mut self) -> Option<(OsString, OsString)> 
next			    fn next(&mut self) -> Option<PathBuf> 
next			    fn next(&mut self) -> Option<SocketAddr> 
next			    fn next(&mut self) -> Option<CodePoint> 
next			    fn next(&mut self) -> Option<u16> 
next_after			    pub fn next_after(self, other: f32) -> f32 
next_after			    pub fn next_after(self, other: f64) -> f64 
next_back			    fn next_back(&mut self) -> Option<u8> 
next_back			    fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }
next_back			    fn next_back(&mut self) -> Option<String> 
next_back			    fn next_back(&mut self) -> Option<&'a OsStr> 
next_back			    fn next_back(&mut self) -> Option<Component<'a>> 
next_back			    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }
next_back			    fn next_back(&mut self) -> Option<OsString> 
next_surrogate			    fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> 
next_test_ip4			pub fn next_test_ip4() -> SocketAddr 
next_test_ip6			pub fn next_test_ip6() -> SocketAddr 
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u32			        fn next_u32(&mut self) -> u32 
next_u32			fn next_u32(mut fill_buf: &mut FnMut(&mut [u8])) -> u32 
next_u32			    fn next_u32(&mut self) -> u32 
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
next_u64			        fn next_u64(&mut self) -> u64 
next_u64			fn next_u64(mut fill_buf: &mut FnMut(&mut [u8])) -> u64 
next_u64			    fn next_u64(&mut self) -> u64 
nextafter			        pub fn nextafter(x: c_double, y: c_double) -> c_double;
nextafterf			        pub fn nextafterf(x: c_float, y: c_float) -> c_float;
nlink			    fn nlink(&self) -> u64 { self.st_nlink() }
nlink			    fn nlink(&self) -> u64;
no_lookup_host_duplicates			    fn no_lookup_host_duplicates() 
no_match			    fn no_match() 
no_match			    fn no_match() 
no_match_empty			    fn no_match_empty() 
no_match_empty			    fn no_match_empty() 
no_match_empty_reversed			    fn no_match_empty_reversed() 
no_match_empty_reversed			    fn no_match_empty_reversed() 
no_match_reversed			    fn no_match_reversed() 
no_match_reversed			    fn no_match_reversed() 
no_runtime			    fn no_runtime() 
nodelay			    fn nodelay() 
nodelay			    pub fn nodelay(&self) -> io::Result<bool> 
nodelay			    pub fn nodelay(&self) -> Result<bool> 
nodelay			    pub fn nodelay(&self) -> io::Result<bool> 
nodelay			    pub fn nodelay(&self) -> io::Result<bool> 
nodelay			    pub fn nodelay(&self) -> io::Result<bool> 
nonblocking			    pub fn nonblocking(&self) -> io::Result<bool> 
nonblocking			    pub fn nonblocking(&self) -> Result<bool> 
nonblocking			    pub fn nonblocking(&self) -> Result<bool> 
notify_all			    fn notify_all() 
notify_all			    pub fn notify_all(&self) 
notify_all			    pub fn notify_all(&self) 
notify_all			    pub unsafe fn notify_all(&self) 
notify_all			    pub unsafe fn notify_all(&self) 
notify_all			    pub unsafe fn notify_all(&self) { self.0.notify_all() }
notify_one			    fn notify_one() 
notify_one			    pub fn notify_one(&self) 
notify_one			    pub fn notify_one(&self) 
notify_one			    pub unsafe fn notify_one(&self) 
notify_one			    pub unsafe fn notify_one(&self) 
notify_one			    pub unsafe fn notify_one(&self) { self.0.notify_one() }
now			    pub fn now() -> Instant 
now			    pub fn now() -> SystemTime 
now			fn now(clock: clock_t) -> Timespec 
now			        pub fn now() -> Instant 
now			        pub fn now() -> SystemTime 
now			    fn now(clock: clock_t) -> Timespec 
now			    pub fn now() -> Instant 
now			    pub fn now() -> SystemTime 
now			    pub fn now() -> Instant 
now			    pub fn now() -> SystemTime 
ntoh			fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }
nul_position			    pub fn nul_position(&self) -> usize { self.0 }
null			    pub fn null() -> Stdio { Stdio(imp::Stdio::Null) }
num			pub mod num;
objc_getClass			            fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;
objc_msgSend			            fn objc_msgSend(obj: NsId, sel: Sel) -> NsId;
objc_msgSend			            fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;
objc_msgSend_ul			            fn objc_msgSend_ul(obj: NsId, sel: Sel, ...) -> NsId;
objc_msgSend_ul			            fn objc_msgSend_ul(obj: NsId, sel: Sel, i: libc::c_ulong) -> NsId;
octets			    pub fn octets(&self) -> [u8; 16] 
octets			    pub fn octets(&self) -> [u8; 4] 
offset			    unsafe fn offset(self, count: isize) -> RawBucket<K, V> 
once			mod once;
oneshot			mod oneshot;
oneshot_data_waiting			    fn oneshot_data_waiting() 
oneshot_multi_task_recv_then_close			    fn oneshot_multi_task_recv_then_close() 
oneshot_multi_task_recv_then_send			    fn oneshot_multi_task_recv_then_send() 
oneshot_multi_thread_close_stress			    fn oneshot_multi_thread_close_stress() 
oneshot_multi_thread_recv_close_stress			    fn oneshot_multi_thread_recv_close_stress() 
oneshot_multi_thread_send_close_stress			    fn oneshot_multi_thread_send_close_stress() 
oneshot_multi_thread_send_recv_stress			    fn oneshot_multi_thread_send_recv_stress() 
oneshot_single_thread_close_chan_first			    fn oneshot_single_thread_close_chan_first() 
oneshot_single_thread_close_port_first			    fn oneshot_single_thread_close_port_first() 
oneshot_single_thread_peek_close			    fn oneshot_single_thread_peek_close() 
oneshot_single_thread_peek_data			    fn oneshot_single_thread_peek_data() 
oneshot_single_thread_peek_open			    fn oneshot_single_thread_peek_open() 
oneshot_single_thread_recv_chan_close			    fn oneshot_single_thread_recv_chan_close() 
oneshot_single_thread_recv_timeout			    fn oneshot_single_thread_recv_timeout() 
oneshot_single_thread_send_port_close			    fn oneshot_single_thread_send_port_close() 
oneshot_single_thread_send_then_recv			    fn oneshot_single_thread_send_then_recv() 
oneshot_single_thread_try_recv_closed			    fn oneshot_single_thread_try_recv_closed() 
oneshot_single_thread_try_recv_closed_with_data			    fn oneshot_single_thread_try_recv_closed_with_data() 
oneshot_single_thread_try_recv_open			    fn oneshot_single_thread_try_recv_open() 
oneshot_single_thread_try_send_closed			    fn oneshot_single_thread_try_send_closed() 
oneshot_single_thread_try_send_closed2			    fn oneshot_single_thread_try_send_closed2() 
oneshot_single_thread_try_send_open			    fn oneshot_single_thread_try_send_open() 
only_v6			    pub fn only_v6(&self) -> io::Result<bool> 
only_v6			    pub fn only_v6(&self) -> Result<bool> 
only_v6			    pub fn only_v6(&self) -> Result<bool> 
only_v6			    pub fn only_v6(&self) -> io::Result<bool> 
oom_handler			    fn oom_handler() -> ! 
oom_handler			    fn oom_handler() -> ! 
oom_handler			    fn oom_handler() -> ! 
open			    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> 
open			    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open			    pub fn open(filename: &str) -> io::Result<DynamicLibrary> 
open			    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> 
open_c			    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> 
open_flavors			    fn open_flavors() 
ops			impl ops::Index<ops::Range<usize>> for Wtf8 
ops			impl ops::Index<ops::RangeFrom<usize>> for Wtf8 
ops			impl ops::Index<ops::RangeTo<usize>> for Wtf8 
ops::Deref for CString			impl ops::Deref for CString 
ops::Deref for OsString			impl ops::Deref for OsString 
ops::Deref for PathBuf			impl ops::Deref for PathBuf 
ops::Deref for Wtf8Buf			impl ops::Deref for Wtf8Buf 
ops::Index for CString			impl ops::Index<ops::RangeFull> for CString 
ops::Index for OsString			impl ops::Index<ops::RangeFull> for OsString 
ops::Index for Wtf8			impl ops::Index<ops::RangeFull> for Wtf8 
or_insert			    pub fn or_insert(self, default: V) -> &'a mut V 
or_insert_with			    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V 
ord			    fn ord() 
os			pub mod os;
os			pub mod os 
os			pub mod os;
os			pub mod os 
os			pub mod os;
os			pub mod os 
os			pub mod os;
os			pub mod os 
os2c			fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString 
os2path			fn os2path(s: &[u16]) -> PathBuf 
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fdatasync(fd) }
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) }
os_datasync			        unsafe fn os_datasync(fd: c_int) -> c_int 
os_str			mod os_str;
os_str			pub mod os_str;
os_str			pub mod os_str;
os_str			pub mod os_str;
os_str_as_u8_slice			fn os_str_as_u8_slice(s: &OsStr) -> &[u8] 
os_str_as_u8_slice			fn os_str_as_u8_slice(s: &OsStr) -> &[u8] 
os_str_len			        fn os_str_len(s: &OsStr) -> usize 
os_string_from_ptr			unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString 
output			    pub fn output(&mut self) -> io::Result<Output> 
output			pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,
output_fileline			pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,
overlapped_result			    pub fn overlapped_result(&self,
page_size			pub fn page_size() -> usize 
page_size			pub fn page_size() -> usize 
pair			    fn pair() 
pair			    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> 
pair			    pub fn pair() -> io::Result<(UnixStream, UnixStream)> 
pair_to_key			fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString 
panic			pub mod panic;
panic_doesnt_poison			    fn panic_doesnt_poison() 
panic_in_write_doesnt_flush_in_drop			    fn panic_in_write_doesnt_flush_in_drop() 
panicking			mod panicking;
panicking			pub fn panicking() -> bool 
panicking			pub fn panicking() -> bool 
parent			    pub fn parent(&self) -> Option<&Path> 
park			pub fn park() 
park_timeout			pub fn park_timeout(dur: Duration) 
park_timeout_ms			pub fn park_timeout_ms(ms: u32) 
parse			    pub fn parse(data: &[u8]) -> Result<Self, String> 
parse			    fn parse(input: &[u8]) -> Option<(OsString, OsString)> 
parse_digit			        fn parse_digit(c: char, radix: u8) -> Option<u8> 
parse_next_component			    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) 
parse_next_component_back			    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) 
parse_prefix			pub fn parse_prefix(path: &OsStr) -> Option<Prefix> 
parse_prefix			pub fn parse_prefix(_: &OsStr) -> Option<Prefix> 
parse_prefix			pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> 
parse_single_component			    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> 
parse_two_comps			    fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> 
parser			mod parser;
partial_cmp			    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> 
partial_cmp			            fn partial_cmp(&self, other: &
partial_cmp			            fn partial_cmp(&self, other: &
partial_cmp			    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> 
partial_cmp			            fn partial_cmp(&self, other: &
partial_cmp			            fn partial_cmp(&self, other: &
partial_cmp			    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> 
partial_cmp			    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> 
partial_read			    fn partial_read() 
path			    pub fn path(&self) -> PathBuf { self.0.path() }
path			pub mod path;
path			    pub fn path(&self) -> PathBuf 
path			    pub fn path(&self) -> io::Result<PathBuf> 
path			pub mod path;
path			    pub fn path(&self) -> PathBuf 
path			pub mod path;
path			    pub fn path(&self) -> PathBuf 
path			pub mod path;
path			        pub fn path<'a>(&'a self) -> &'a Path 
path_to_local_addr			fn path_to_local_addr(path_str: &str) -> SocketAddr 
path_to_peer_addr			fn path_to_peer_addr(path_str: &str) -> SocketAddr 
payload			    pub fn payload(&self) -> &(Any + Send) 
pcinfo_cb			    extern fn pcinfo_cb(data: *mut libc::c_void,
peek			    pub fn peek(self) -> BucketState<K, V, M> 
peek			    fn peek() 
peek			    pub fn peek(&self) -> Option<&mut T> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
peer_addr			    pub fn peer_addr(&self) -> Result<SocketAddr> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
peer_addr			    pub fn peer_addr(&self) -> io::Result<SocketAddr> 
perm			    pub fn perm(&self) -> FilePermissions 
perm			    pub fn perm(&self) -> FilePermissions 
perm			    pub fn perm(&self) -> FilePermissions 
permissions			    pub fn permissions(&self) -> Permissions 
pipe			pub mod pipe;
pipe			pub mod pipe;
pipe			pub mod pipe;
piped			    pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }
poison			pub mod poison;
poison_bad			    fn poison_bad() 
poison_works			    fn poison_works() 
poisoned			    pub fn poisoned(&self) -> bool 
pop			    pub fn pop(&mut self) -> bool 
pop			    pub fn pop(&self) -> PopResult<T> 
pop			    pub fn pop(&self) -> Option<T> 
pop_internal			fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) 
port			    pub fn port(&self) -> u16 
port_gone_concurrent			    fn port_gone_concurrent() 
port_gone_concurrent_shared			    fn port_gone_concurrent_shared() 
position			    pub fn position(&self) -> u64 { self.pos }
postinit_lock			    pub fn postinit_lock(&self) -> MutexGuard<()> 
powf			    pub fn powf(self, n: f32) -> f32 
powf			    pub fn powf(self, n: f64) -> f64 
powi			    pub fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }
powi			    pub fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }
prefix			    fn prefix(&self) -> Option<Prefix> 
prefix_len			    fn prefix_len(&self) -> usize 
prefix_remaining			    fn prefix_remaining(&self) -> usize 
prefix_verbatim			    fn prefix_verbatim(&self) -> bool 
preflight1			    fn preflight1() 
preflight2			    fn preflight2() 
preflight3			    fn preflight3() 
preflight4			    fn preflight4() 
preflight5			    fn preflight5() 
preflight6			    fn preflight6() 
preflight7			    fn preflight7() 
preflight8			    fn preflight8() 
preflight9			    fn preflight9() 
prelude			pub mod prelude;
prelude			pub mod prelude;
prelude			pub mod prelude 
prelude			pub mod prelude 
prelude			pub mod prelude 
prim_array			mod prim_array { }
prim_bool			mod prim_bool { }
prim_char			mod prim_char { }
prim_f32			mod prim_f32 { }
prim_f64			mod prim_f64 { }
prim_i16			mod prim_i16 { }
prim_i32			mod prim_i32 { }
prim_i64			mod prim_i64 { }
prim_i8			mod prim_i8 { }
prim_isize			mod prim_isize { }
prim_pointer			mod prim_pointer { }
prim_slice			mod prim_slice { }
prim_str			mod prim_str { }
prim_tuple			mod prim_tuple { }
prim_u16			mod prim_u16 { }
prim_u32			mod prim_u32 { }
prim_u64			mod prim_u64 { }
prim_u8			mod prim_u8 { }
prim_unit			mod prim_unit { }
prim_usize			mod prim_usize { }
print			pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,
print			pub fn print(w: &mut Write,
print			pub fn print(w: &mut Write,
print			pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,
printing			mod printing;
printing			mod printing;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process			pub mod process;
process_common			mod process_common;
process_inner			mod process_inner;
pthread_attr_setstacksize			unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,
pthread_attr_setstacksize			unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,
push			    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) 
push			    pub fn push<P: AsRef<Path>>(&mut self, path: P) 
push			    pub fn push(&self, t: T) 
push			    pub fn push(&self, t: T) 
push			pub fn push(f: Box<FnBox()>) -> bool 
push			    pub fn push(&mut self, code_point: CodePoint) 
push_char			    pub fn push_char(&mut self, c: char) 
push_code_point_unchecked			    fn push_code_point_unchecked(&mut self, code_point: CodePoint) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_slice			    pub fn push_slice(&mut self, s: &Slice) 
push_str			    pub fn push_str(&mut self, other: &str) 
push_wtf8			    pub fn push_wtf8(&mut self, other: &Wtf8) 
put			    pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> 
query			mod query;
rand			mod rand;
rand			pub mod rand;
rand			pub mod rand;
rand			pub mod rand;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			pub mod raw;
raw			    pub fn raw(&self) -> usize { self.fd }
raw			pub mod raw;
raw			    pub fn raw(&self) -> c_int { self.fd }
raw			pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t 
raw			    pub fn raw(&self) -> mx_handle_t 
raw			pub mod raw;
raw			    pub fn raw(&self) -> c::HANDLE { self.0 }
raw			pub unsafe fn raw(m: &Mutex) -> c::PSRWLOCK 
raw			pub fn raw(mutex: &Mutex) -> &imp::Mutex { &mutex.0 }
raw_buckets			    fn raw_buckets(&self) -> RawBuckets<K, V> 
raw_capacity			    fn raw_capacity(&self) -> usize 
raw_capacity			    fn raw_capacity(&self, len: usize) -> usize 
raw_os_error			    pub fn raw_os_error(&self) -> Option<i32> 
raw_unlock			    unsafe fn raw_unlock(&self) 
rdev			    fn rdev(&self) -> u64 { self.st_rdev() }
rdev			    fn rdev(&self) -> u64;
read			    pub fn read(&self) -> (&K, &V) 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) -> &mut OpenOptions 
read			            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self) -> LockResult<RwLockReadGuard<T>> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) { self.read = read; }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) { self.read = read; }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    pub fn read(&self, data: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&mut self, read: bool) { self.read = read; }
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) 
read			    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> 
read			    pub unsafe fn read(&self) { self.0.read() }
read2			pub fn read2(p1: AnonPipe,
read2			pub fn read2(p1: AnonPipe,
read2			pub fn read2(p1: AnonPipe,
read_at			    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 
read_at			    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;
read_at			    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 
read_at			    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 
read_at			    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 
read_at			    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 
read_atomically			    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where
read_char			    fn read_char(&mut self) -> Option<char> 
read_char_buffered			    fn read_char_buffered() 
read_digit			    fn read_digit(&mut self, radix: u8) -> Option<u8> 
read_dir			pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> 
read_dir			    pub fn read_dir(&self) -> io::Result<fs::ReadDir> 
read_dir_not_found			    fn read_dir_not_found() 
read_eof			    fn read_eof() 
read_exact			    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> 
read_exact			    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> 
read_exact			    fn read_exact() 
read_exact			    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> 
read_exact_slice			    fn read_exact_slice() 
read_given_char			    fn read_given_char(&mut self, c: char) -> Option<char> 
read_groups			        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize)
read_ip_addr			    fn read_ip_addr(&mut self) -> Option<IpAddr> 
read_ipv4_addr			    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> 
read_ipv4_addr_impl			    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> 
read_ipv6_addr			    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> 
read_ipv6_addr_impl			    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> 
read_line			    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> 
read_line			    fn read_line(&mut self, buf: &mut String) -> Result<usize> 
read_line			    fn read_line() 
read_line			    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> 
read_link			    fn read_link() 
read_link			pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> 
read_link			    pub fn read_link(&self) -> io::Result<PathBuf> 
read_mut			    pub fn read_mut(&mut self) -> (&mut K, &mut V) 
read_number			    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_number_impl			    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> 
read_one_byte			fn read_one_byte(reader: &mut Read) -> Option<Result<u8>> 
read_or			    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T> + 'static>])
read_overlapped			    pub unsafe fn read_overlapped(&self,
read_seq_3			    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,
read_socket_addr			    fn read_socket_addr(&mut self) -> Option<SocketAddr> 
read_socket_addr_v4			    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> 
read_socket_addr_v6			    fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> 
read_till_eof			    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_timeout			    pub fn read_timeout(&self) -> io::Result<Option<Duration>> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end() 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> 
read_to_end			    fn read_to_end() 
read_to_end			fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end			    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_end_uninit_error			    fn read_to_end_uninit_error() 
read_to_end_uninit_good			    fn read_to_end_uninit_good() 
read_to_end_uninit_zero_len_vec			    fn read_to_end_uninit_zero_len_vec() 
read_to_end_uninitialized			pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::Result<usize> 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> 
read_to_string			    fn read_to_string() 
read_to_string			    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> 
read_unlock			    pub unsafe fn read_unlock(&self) 
read_unlock			    pub unsafe fn read_unlock(&self) 
read_unlock			    pub unsafe fn read_unlock(&self) 
read_unlock			    pub unsafe fn read_unlock(&self) { self.0.read_unlock() }
read_until			    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> 
read_until			    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> 
read_until			    fn read_until() 
read_until			fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
readdir			pub fn readdir(p: &Path) -> io::Result<ReadDir> 
reader			pub mod reader;
readlink			pub fn readlink(p: &Path) -> io::Result<PathBuf> 
readlink			pub fn readlink(p: &Path) -> io::Result<PathBuf> 
readlink			    fn readlink(&self) -> io::Result<PathBuf> 
readlink			pub fn readlink(path: &Path) -> io::Result<PathBuf> 
readlink_not_symlink			    fn readlink_not_symlink() 
readonly			    pub fn readonly(&self) -> bool { self.0.readonly() }
readonly			    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }
readonly			    pub fn readonly(&self) -> bool { self.mode & 0o222 == 0 }
readonly			    pub fn readonly(&self) -> bool 
realpath_works			    fn realpath_works() 
realpath_works_tricky			    fn realpath_works_tricky() 
recip			    pub fn recip(self) -> f32 { num::Float::recip(self) }
recip			    pub fn recip(self) -> f64 { num::Float::recip(self) }
recursive			    pub fn recursive(&mut self, recursive: bool) -> &mut Self 
recursive_mkdir			    fn recursive_mkdir() 
recursive_mkdir_failure			    fn recursive_mkdir_failure() 
recursive_mkdir_slash			    fn recursive_mkdir_slash() 
recursive_rmdir			    fn recursive_rmdir() 
recursive_rmdir_of_file_symlink			    fn recursive_rmdir_of_file_symlink() 
recursive_rmdir_of_symlink			    fn recursive_rmdir_of_symlink() 
recv			    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> 
recv			            fn recv(rx: Receiver<Box<i32>>, i: i32) 
recv			    pub fn recv(&self) -> Result<T, RecvError> 
recv			    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> 
recv			    pub fn recv(&mut self) -> Result<T, RecvError> { self.rx.recv() }
recv			    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> 
recv			    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> 
recv			    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> 
recv			    pub fn recv(&self, buf: &mut [u8]) -> Result<usize> 
recv			    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> 
recv			    pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,
recv			    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> 
recv_a_lot			    fn recv_a_lot() 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> Result<(usize, SocketAddr)> 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from			    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> 
recv_from_outside_runtime			    fn recv_from_outside_runtime() 
recv_max_until			    fn recv_max_until(&self, deadline: Instant) -> Result<T, RecvTimeoutError> 
recv_timeout			    fn recv_timeout() 
recv_timeout			    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> 
recv_timeout_upgrade			    fn recv_timeout_upgrade() 
recvfrom			    pub fn recvfrom(socket: SOCKET,
refcell_vec			    fn refcell_vec() 
reference_tls_used			    unsafe fn reference_tls_used() 
reference_tls_used			    unsafe fn reference_tls_used() {}
register_dtor			    unsafe fn register_dtor(&self) 
register_dtor			unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) 
register_dtor			    unsafe fn register_dtor(&self) 
register_dtor			unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) 
register_dtor			unsafe fn register_dtor(key: Key, dtor: Dtor) 
register_dtor_fallback			unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) 
remove			    pub fn remove(self) -> V 
remove			    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
remove			    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
remove			    pub unsafe fn remove(&mut self) 
remove_dir			pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> 
remove_dir_all			pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> 
remove_dir_all			pub fn remove_dir_all(path: &Path) -> io::Result<()> 
remove_dir_all			pub fn remove_dir_all(path: &Path) -> io::Result<()> 
remove_dir_all			pub fn remove_dir_all(path: &Path) -> io::Result<()> 
remove_dir_all_recursive			fn remove_dir_all_recursive(path: &Path) -> io::Result<()> 
remove_dir_all_recursive			fn remove_dir_all_recursive(path: &Path) -> io::Result<()> 
remove_dir_all_recursive			fn remove_dir_all_recursive(path: &Path) -> io::Result<()> 
remove_entry			    pub fn remove_entry(self) -> (K, V) 
remove_file			pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> 
remove_pair			    pub fn remove_pair(self) -> (K, V) 
remove_var			pub fn remove_var<K: AsRef<OsStr>>(k: K) 
remutex			    unsafe fn remutex(&self) -> *mut ReentrantMutex 
remutex			pub mod remutex;
rename			pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> 
rename			pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> 
rename			pub fn rename(old: &Path, new: &Path) -> io::Result<()> 
rename			pub fn rename(old: &Path, new: &Path) -> io::Result<()> 
reparse_point			    fn reparse_point<'a>(&self,
repeat			pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }
repeat_byte			    fn repeat_byte(b: u8) -> usize 
repeat_repeats			    fn repeat_repeats() 
replace			    fn replace(&mut self, key: K) -> Option<K> 
replace			    fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;
replace			    pub fn replace(&mut self, value: T) -> Option<T> 
replace			    pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) 
report_overflow			pub unsafe fn report_overflow() 
repro			        fn repro() 
reseed			    fn reseed(&mut self, rng: &mut StdRng) 
reseed			    fn reseed(&mut self, seed: &'a [usize]) 
reseeding::Reseeder for ThreadRngReseeder			impl reseeding::Reseeder<StdRng> for ThreadRngReseeder 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve			    pub fn reserve(&mut self, additional: usize) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: usize) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: usize) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: usize) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: usize) 
reserve_exact			    pub fn reserve_exact(&mut self, additional: usize) 
reset_sigpipe			    unsafe fn reset_sigpipe() 
reset_sigpipe			    unsafe fn reset_sigpipe() {}
resize			    fn resize(&mut self, new_raw_cap: usize) 
resolve_socket_addr			fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> 
result			    fn result(&mut self) -> io::Result<bool> 
resume_unwind			pub fn resume_unwind(payload: Box<Any + Send>) -> ! 
rev_move_buckets			    unsafe fn rev_move_buckets(&mut self) -> RevMoveBuckets<K, V> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
rmdir			pub fn rmdir(p: &Path) -> io::Result<()> 
robin_hood			fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,
round			    pub fn round(self) -> f32 
round			    pub fn round(self) -> f64 
round_up_to_next			fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize 
rt			pub mod rt;
rtdeps			mod rtdeps;
run_dtors			unsafe fn run_dtors() 
run_output			    pub fn run_output(mut cmd: Command) -> String 
rust_begin_panic			pub extern fn rust_begin_panic(msg: fmt::Arguments,
rust_panic			pub fn rust_panic(msg: Box<Any + Send>) -> ! 
rust_panic_with_hook			fn rust_panic_with_hook(msg: Box<Any + Send>,
rwlock			mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
rwlock			pub mod rwlock;
sa4			pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr 
sa6			pub fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr 
same			    fn same() 
saw_nul			    pub fn saw_nul(&self) -> bool 
schedule_read			    fn schedule_read(&mut self) -> io::Result<bool> 
scope_id			    pub fn scope_id(&self) -> u32 
search			    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>
search_hashed			fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>
search_mut			    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>
secs			    fn secs() 
security_attributes			    pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) 
security_qos_flags			    fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions 
security_qos_flags			    fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions;
security_qos_flags			    pub fn security_qos_flags(&mut self, flags: u32) { self.security_qos_flags = flags; }
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			            fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, style: SeekFrom) -> io::Result<u64> 
seek			    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }
seek			    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek			    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> 
seek_before_0			    fn seek_before_0() 
seek_past_end			    fn seek_past_end() 
seek_read			    fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> 
seek_read			    fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;
seek_write			    fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize> 
seek_write			    fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>;
segments			    pub fn segments(&self) -> [u16; 8] 
sel_registerName			            fn sel_registerName(name: *const libc::c_uchar) -> Sel;
select			mod select;
select::Packet for Receiver			impl<T> select::Packet for Receiver<T> 
self_referential			    fn self_referential() 
send			    pub fn send(&self, buf: &[u8]) -> io::Result<usize> 
send			            fn send(tx: Sender<Box<i32>>, i: i32) 
send			            fn send(tx: SyncSender<Box<i32>>, i: i32) 
send			    pub fn send(&self, t: T) -> Result<(), SendError<T>> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(&self, t: T) -> Result<(), T> 
send			    pub fn send(&self, buf: &[u8]) -> Result<usize> 
send			    pub fn send(&self, buf: &[u8]) -> io::Result<usize> 
send			    pub fn send(socket: SOCKET, buf: *const c_void, len: c_int,
send			    pub fn send(&self, buf: &[u8]) -> io::Result<usize> 
send1			    fn send1() 
send2			    fn send2() 
send3			    fn send3() 
send4			    fn send4() 
send_from_outside_runtime			    fn send_from_outside_runtime() 
send_to			    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)
send_to			    pub fn send_to(&self, buf: &[u8], addr: &SocketAddr) -> Result<usize> 
send_to			    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> 
send_to			    pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> 
sendto			    pub fn sendto(socket: SOCKET,
sent			    pub fn sent(&self) -> bool 
set			pub mod set;
set			    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			pub unsafe fn set(key: Key, value: *mut u8) 
set			pub fn set(stack_guard: Option<usize>, thread: Thread) 
set			    pub fn set(&self, val: *mut u8) 
set			    pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }
set_broadcast			    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> 
set_broadcast			    pub fn set_broadcast(&self, _broadcast: bool) -> Result<()> 
set_broadcast			    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> 
set_cloexec			    pub fn set_cloexec(&self) -> io::Result<()> 
set_cloexec			    pub fn set_cloexec(&self) -> io::Result<()> 
set_current_dir			pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> 
set_current_dir_works			    fn set_current_dir_works() 
set_errno			pub fn set_errno(e: i32) 
set_extension			    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool 
set_file_name			    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) 
set_flowinfo			    fn set_flowinfo() 
set_flowinfo			    pub fn set_flowinfo(&mut self, new_flowinfo: u32) 
set_hook			pub fn set_hook(hook: Box<Fn(&PanicInfo) + 'static + Sync + Send>) 
set_ip			    fn set_ip() 
set_ip			    pub fn set_ip(&mut self, new_ip: IpAddr) 
set_ip			    pub fn set_ip(&mut self, new_ip: Ipv4Addr) 
set_ip			    pub fn set_ip(&mut self, new_ip: Ipv6Addr) 
set_len			    pub fn set_len(&self, size: u64) -> io::Result<()> 
set_mode			    fn set_mode(&mut self, mode: u32) 
set_mode			    fn set_mode(&mut self, mode: u32);
set_mode			    pub fn set_mode(&mut self, mode: u32) 
set_mode			    fn set_mode(&mut self, mode: u32) 
set_mode			    fn set_mode(&mut self, mode: u32);
set_mode			    pub fn set_mode(&mut self, mode: u32) 
set_multicast_loop_v4			    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> 
set_multicast_loop_v4			    pub fn set_multicast_loop_v4(&self, _multicast_loop_v4: bool) -> Result<()> 
set_multicast_loop_v4			    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> 
set_multicast_loop_v6			    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> 
set_multicast_loop_v6			    pub fn set_multicast_loop_v6(&self, _multicast_loop_v6: bool) -> Result<()> 
set_multicast_loop_v6			    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> 
set_multicast_ttl_v4			    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> 
set_multicast_ttl_v4			    pub fn set_multicast_ttl_v4(&self, _multicast_ttl_v4: u32) -> Result<()> 
set_multicast_ttl_v4			    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> 
set_name			    pub fn set_name(_name: &CStr) 
set_name			    pub fn set_name(_name: &CStr) 
set_name			    pub fn set_name(name: &CStr) 
set_name			    pub fn set_name(_name: &CStr) 
set_no_inherit			    fn set_no_inherit(&self) -> io::Result<()> 
set_nodelay			    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> 
set_nodelay			    pub fn set_nodelay(&self, _nodelay: bool) -> Result<()> 
set_nodelay			    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> 
set_nodelay			    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> 
set_nodelay			    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> 
set_nonblocking			    fn set_nonblocking() 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    fn set_nonblocking() 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_nonblocking			    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> 
set_only_v6			    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> 
set_only_v6			    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> 
set_only_v6			    pub fn set_only_v6(&self, _only_v6: bool) -> Result<()> 
set_only_v6			    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> 
set_panic			pub fn set_panic(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_perm			pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> 
set_permissions			    pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> 
set_permissions			pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions)
set_permissions			    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> 
set_permissions			    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> 
set_permissions			    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> 
set_port			    fn set_port() 
set_port			    pub fn set_port(&mut self, new_port: u16) 
set_position			    pub fn set_position(&mut self, pos: u64) { self.pos = pos; }
set_print			pub fn set_print(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> 
set_read_timeout			    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> 
set_read_timeout			    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_readonly			    pub fn set_readonly(&mut self, readonly: bool) 
set_scope_id			    fn set_scope_id() 
set_scope_id			    pub fn set_scope_id(&mut self, new_scope_id: u32) 
set_timeout			    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> 
set_timeout			    pub fn set_timeout(&self, dur: Option<Duration>,
set_ttl			    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> 
set_ttl			    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> 
set_ttl			    pub fn set_ttl(&self, _ttl: u32) -> Result<()> 
set_ttl			    pub fn set_ttl(&self, _ttl: u32) -> Result<()> 
set_ttl			    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> 
set_var			pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) 
set_write_timeout			    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> 
set_write_timeout			    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> 
setenv			pub fn setenv(key: &OsStr, value: &OsStr) -> io::Result<()> 
setenv			pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> 
setenv			pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> 
setsockopt			    pub fn setsockopt(s: SOCKET,
setsockopt			pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,
setup_io			    fn setup_io(&self, default: Stdio, needs_stdin: bool)
setup_io			    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)
share_mode			    fn share_mode(&mut self, share: u32) -> &mut OpenOptions 
share_mode			    fn share_mode(&mut self, val: u32) -> &mut Self;
share_mode			    pub fn share_mode(&mut self, share_mode: u32) { self.share_mode = share_mode; }
shared			mod shared;
shared_chan_stress			    fn shared_chan_stress() 
shared_data_waiting			    fn shared_data_waiting() 
shared_recv_timeout			    fn shared_recv_timeout() 
shift			    pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> 
shims			    mod shims 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shrink_to_fit			    pub fn shrink_to_fit(&mut self) 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(&self, _how: Shutdown) -> Result<()> 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown			    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> 
shutdown_smoke			    fn shutdown_smoke() 
sigaddset			        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;
sigaddset			    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int 
siginfo_si_addr			    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize 
siginfo_t			        struct siginfo_t 
signal			    pub fn signal(&self) -> bool 
signal			    fn signal(&self) -> Option<i32> 
signal			    fn signal(&self) -> Option<i32>;
signal			    pub fn signal(&self) -> Option<i32> 
signal			pub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t 
signal			    fn signal(&self) -> Option<i32> 
signal			    fn signal(&self) -> Option<i32>;
signal			    pub fn signal(&self) -> Option<i32> 
signal_reported_right			    fn signal_reported_right() 
signum			    pub fn signum(self) -> f32 { num::Float::signum(self) }
signum			    pub fn signum(self) -> f64 { num::Float::signum(self) }
simple			    fn simple() 
sin			    pub fn sin(self) -> f32 
sin			    pub fn sin(self) -> f64 
sin_cos			    pub fn sin_cos(self) -> (f32, f32) 
sin_cos			    pub fn sin_cos(self) -> (f64, f64) 
since_epoch			    fn since_epoch() 
sinh			    pub fn sinh(self) -> f32 
sinh			        pub fn sinh(n: c_double) -> c_double;
sinh			    pub fn sinh(self) -> f64 
sinhf			        pub fn sinhf(n: c_float) -> c_float;
sinhf			        pub unsafe fn sinhf(n: c_float) -> c_float 
sink			pub fn sink() -> Sink { Sink { _priv: () } }
sink_sinks			    fn sink_sinks() 
size			    pub fn size(&self) -> usize 
size			    fn size(&self) -> usize { self.size }
size			    fn size(&self) -> u64 
size			    fn size(&self) -> u64;
size			    pub fn size(&self) -> u64 { self.stat.st_size as u64 }
size			    fn size(&self) -> u64 { self.st_size() }
size			    fn size(&self) -> u64;
size			    pub fn size(&self) -> u64 { self.stat.st_size as u64 }
size			    pub fn size(&self) -> u64 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }
size_hint			    fn size_hint(&self) -> (usize, Option<usize>) 
sleep			    pub fn sleep(dur: Duration) 
sleep			    pub fn sleep(dur: Duration) 
sleep			    pub fn sleep(dur: Duration) 
sleep			pub fn sleep(dur: Duration) 
sleep_ms			pub fn sleep_ms(ms: u32) 
sleep_ms_smoke			    fn sleep_ms_smoke() 
slice_error_fail			pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! 
slice_to_end			unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] 
slice_unchecked			pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke			    fn smoke() 
smoke2			    fn smoke2() 
smoke_bound			    fn smoke_bound() 
smoke_chan_gone			    fn smoke_chan_gone() 
smoke_chan_gone_shared			    fn smoke_chan_gone_shared() 
smoke_dtor			    fn smoke_dtor() 
smoke_failure			    fn smoke_failure() 
smoke_no_dtor			    fn smoke_no_dtor() 
smoke_once			    fn smoke_once() 
smoke_port_gone			    fn smoke_port_gone() 
smoke_shared			    fn smoke_shared() 
smoke_shared_port_gone			    fn smoke_shared_port_gone() 
smoke_shared_port_gone2			    fn smoke_shared_port_gone2() 
smoke_test			    fn smoke_test() 
smoke_threads			    fn smoke_threads() 
sockaddr_in			pub struct sockaddr_in 
sockaddr_in6			pub struct sockaddr_in6 
sockaddr_to_addr			fn sockaddr_to_addr(storage: &c::sockaddr_storage,
sockaddr_un			unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> 
socket			    pub fn socket(&self) -> &Socket { &self.inner }
socket_addr			    pub fn socket_addr(&self) -> Result<SocketAddr> 
socket_addr			    pub fn socket_addr(&self) -> Result<SocketAddr> 
socket_addr			    pub fn socket_addr(&self) -> io::Result<SocketAddr> 
socket_and_peer_name			    fn socket_and_peer_name() 
socket_name_ip4			    fn socket_name_ip4() 
socket_smoke_test_ip4			    fn socket_smoke_test_ip4() 
sockname			fn sockname<F>(f: F) -> io::Result<SocketAddr>
soft_link			pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> 
spawn			    pub fn spawn(&mut self) -> io::Result<Child> 
spawn			    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)
spawn			    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)
spawn			    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)
spawn			    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)
spawn			    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where
spawn			pub fn spawn<F, T>(f: F) -> JoinHandle<T> where
split			    fn split() 
split			    fn split(self, byte: u8) -> Split<Self> where Self: Sized 
split_file_at_dot			fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) 
split_paths			pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths 
split_paths			pub fn split_paths(unparsed: &OsStr) -> SplitPaths 
split_paths			pub fn split_paths(unparsed: &OsStr) -> SplitPaths 
split_paths			pub fn split_paths(unparsed: &OsStr) -> SplitPaths 
split_paths_unix			    fn split_paths_unix() 
split_paths_windows			    fn split_paths_windows() 
spsc_queue			mod spsc_queue;
sqrt			    pub fn sqrt(self) -> f32 
sqrt			    pub fn sqrt(self) -> f64 
square			        fn square(i: i32) -> i32 { i * i }
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime			    fn st_atime(&self) -> i64 
st_atime			    fn st_atime(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_atime_nsec			    fn st_atime_nsec(&self) -> i64 
st_atime_nsec			    fn st_atime_nsec(&self) -> i64;
st_birthtime			    fn st_birthtime(&self) -> i64 
st_birthtime			    fn st_birthtime(&self) -> i64;
st_birthtime			    fn st_birthtime(&self) -> i64 
st_birthtime			    fn st_birthtime(&self) -> i64;
st_birthtime			    fn st_birthtime(&self) -> i64 
st_birthtime			    fn st_birthtime(&self) -> i64;
st_birthtime			    fn st_birthtime(&self) -> i64 
st_birthtime			    fn st_birthtime(&self) -> i64;
st_birthtime			    fn st_birthtime(&self) -> i64 
st_birthtime			    fn st_birthtime(&self) -> i64;
st_birthtime			    fn st_birthtime(&self) -> i64 
st_birthtime			    fn st_birthtime(&self) -> i64;
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64 
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64;
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64 
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64;
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64 
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64;
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64 
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64;
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64 
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64;
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64 
st_birthtime_nsec			    fn st_birthtime_nsec(&self) -> i64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blksize			    fn st_blksize(&self) -> u64 
st_blksize			    fn st_blksize(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_blocks			    fn st_blocks(&self) -> u64 
st_blocks			    fn st_blocks(&self) -> u64;
st_crtime			    fn st_crtime(&self) -> i64 
st_crtime			    fn st_crtime(&self) -> i64;
st_crtime_nsec			    fn st_crtime_nsec(&self) -> i64 
st_crtime_nsec			    fn st_crtime_nsec(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime			    fn st_ctime(&self) -> i64 
st_ctime			    fn st_ctime(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64 
st_ctime_nsec			    fn st_ctime_nsec(&self) -> i64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_dev			    fn st_dev(&self) -> u64 
st_dev			    fn st_dev(&self) -> u64;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_flags			    fn st_flags(&self) -> u32 
st_flags			    fn st_flags(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gen			    fn st_gen(&self) -> u32 
st_gen			    fn st_gen(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_gid			    fn st_gid(&self) -> u32 
st_gid			    fn st_gid(&self) -> u32;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_ino			    fn st_ino(&self) -> u64 
st_ino			    fn st_ino(&self) -> u64;
st_lspare			    fn st_lspare(&self) -> u32 
st_lspare			    fn st_lspare(&self) -> u32;
st_lspare			    fn st_lspare(&self) -> u32 
st_lspare			    fn st_lspare(&self) -> u32;
st_lspare			    fn st_lspare(&self) -> u32 
st_lspare			    fn st_lspare(&self) -> u32;
st_lspare			    fn st_lspare(&self) -> u32 
st_lspare			    fn st_lspare(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mode			    fn st_mode(&self) -> u32 
st_mode			    fn st_mode(&self) -> u32;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime			    fn st_mtime(&self) -> i64 
st_mtime			    fn st_mtime(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64 
st_mtime_nsec			    fn st_mtime_nsec(&self) -> i64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_nlink			    fn st_nlink(&self) -> u64 
st_nlink			    fn st_nlink(&self) -> u64;
st_qspare			    fn st_qspare(&self) -> [u64; 2] 
st_qspare			    fn st_qspare(&self) -> [u64; 2];
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_rdev			    fn st_rdev(&self) -> u64 
st_rdev			    fn st_rdev(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_size			    fn st_size(&self) -> u64 
st_size			    fn st_size(&self) -> u64;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
st_uid			    fn st_uid(&self) -> u32 
st_uid			    fn st_uid(&self) -> u32;
stack_guard			pub fn stack_guard() -> Option<usize> 
stack_overflow			pub mod stack_overflow;
stack_overflow			pub mod stack_overflow;
stack_overflow			pub mod stack_overflow;
stack_size			    pub fn stack_size(mut self, size: usize) -> Builder 
stampede_once			    fn stampede_once() 
start_selection			    fn start_selection(&self, mut token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> 
start_selection			    fn start_selection(&self, token: SignalToken) -> StartResult;
start_selection			    pub fn start_selection(&self, token: SignalToken) -> StartResult 
start_selection			    pub fn start_selection(&self, token: SignalToken) -> SelectionResult<T> 
start_selection			    pub fn start_selection(&self, token: SignalToken) -> StartResult 
start_thread			pub unsafe fn start_thread(main: *mut libc::c_void) 
starts_with			    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool 
stash			    pub fn stash(self) -> FullBucket<K, V, Self> 
stat			    pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			    pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			    pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub struct stat 
stat			pub fn stat(p: &Path) -> io::Result<FileAttr> 
stat			pub fn stat(p: &Path) -> io::Result<FileAttr> 
stat			pub fn stat(path: &Path) -> io::Result<FileAttr> 
state			    pub fn state(&'static self) -> LocalKeyState 
states			    fn states() 
statik			    fn statik() 
status			    pub fn status(&mut self) -> io::Result<ExitStatus> 
std_error::Error for CharsError			impl std_error::Error for CharsError 
stderr			pub fn stderr() -> Stderr 
stderr			    pub fn stderr(&mut self, cfg: Stdio) -> &mut Command 
stderr			    pub fn stderr(&mut self, stderr: Stdio) 
stderr			    pub fn stderr(&mut self, stderr: Stdio) 
stderr			    pub fn stderr(&mut self, stderr: Stdio) 
stderr_init			    fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> 
stderr_raw			fn stderr_raw() -> io::Result<StderrRaw> { stdio::Stderr::new().map(StderrRaw) }
stdin			pub fn stdin() -> Stdin 
stdin			    pub fn stdin(&mut self, cfg: Stdio) -> &mut Command 
stdin			    pub fn stdin(&mut self, stdin: Stdio) 
stdin			    pub fn stdin(&mut self, stdin: Stdio) 
stdin			    pub fn stdin(&mut self, stdin: Stdio) 
stdin_init			    fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> 
stdin_raw			fn stdin_raw() -> io::Result<StdinRaw> { stdio::Stdin::new().map(StdinRaw) }
stdin_works			    fn stdin_works() 
stdio			mod stdio;
stdio			pub mod stdio;
stdio			pub mod stdio;
stdio			pub mod stdio;
stdout			pub fn stdout() -> Stdout 
stdout			    pub fn stdout(&mut self, cfg: Stdio) -> &mut Command 
stdout			    pub fn stdout(&mut self, stdout: Stdio) 
stdout			    pub fn stdout(&mut self, stdout: Stdio) 
stdout			    pub fn stdout(&mut self, stdout: Stdio) 
stdout_init			    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> 
stdout_raw			fn stdout_raw() -> io::Result<StdoutRaw> { stdio::Stdout::new().map(StdoutRaw) }
stdout_works			    fn stdout_works() 
store_func			pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,
stream			mod stream;
stream_data_waiting			    fn stream_data_waiting() 
stream_send_recv_stress			    fn stream_send_recv_stress() 
strerror_r			        fn strerror_r(errnum: c_int, buf: *mut c_char,
stress			    fn stress() 
stress			    fn stress() 
stress			    fn stress() 
stress_bound			        unsafe fn stress_bound(bound: usize) 
stress_factor			    pub fn stress_factor() -> usize 
stress_recv_timeout_shared			    fn stress_recv_timeout_shared() 
stress_recv_timeout_two_threads			    fn stress_recv_timeout_two_threads() 
stress_shared			    fn stress_shared() 
strip_prefix			    pub fn strip_prefix<'a, P: ?Sized>(&'a self, base: &'a P)
sub			    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> 
sub			    fn sub() 
sub			    fn sub(self, rhs: Duration) -> Duration 
sub			    fn sub(self, dur: Duration) -> SystemTime 
sub			    fn sub(self, other: Duration) -> Instant 
sub			    fn sub(self, other: Instant) -> Duration 
sub_assign			    fn sub_assign(&mut self, rhs: Duration) 
sub_assign			    fn sub_assign(&mut self, other: Duration) 
sub_bad1			    fn sub_bad1() 
sub_bad2			    fn sub_bad2() 
sub_duration			    fn sub_duration(&self, other: &Duration) -> Timespec 
sub_duration			    pub fn sub_duration(&self, other: &Duration) -> Instant 
sub_duration			    pub fn sub_duration(&self, other: &Duration) -> SystemTime 
sub_duration			        pub fn sub_duration(&self, other: &Duration) -> Instant 
sub_duration			        pub fn sub_duration(&self, other: &Duration) -> SystemTime 
sub_duration			    fn sub_duration(&self, other: &Duration) -> Timespec 
sub_duration			    pub fn sub_duration(&self, other: &Duration) -> Instant 
sub_duration			    pub fn sub_duration(&self, other: &Duration) -> SystemTime 
sub_instant			    pub fn sub_instant(&self, other: &Instant) -> Duration 
sub_instant			        pub fn sub_instant(&self, other: &Instant) -> Duration 
sub_instant			    pub fn sub_instant(&self, other: &Instant) -> Duration 
sub_time			    pub fn sub_time(&self, other: &SystemTime)
sub_time			        pub fn sub_time(&self, other: &SystemTime)
sub_time			    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> 
sub_timespec			    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> 
sub_timespec			    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> 
subsec_nanos			    pub fn subsec_nanos(&self) -> u32 { self.nanos }
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
success			    pub fn success(&self) -> bool 
sun_path_offset			fn sun_path_offset() -> usize 
super::Recover for HashMap			impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>
symbol			    pub fn symbol(&self, symbol: &str) -> io::Result<usize> 
syminfo_cb			    extern fn syminfo_cb(data: *mut libc::c_void,
symlink			pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>
symlink			pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> 
symlink			pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>
symlink			pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> 
symlink			pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> 
symlink_dir			pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)
symlink_file			pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)
symlink_inner			pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> 
symlink_junction			pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> 
symlink_junction_inner			fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> 
symlink_metadata			pub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> 
symlink_metadata			    pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> 
symlink_noexist			    fn symlink_noexist() 
symlinks_work			    fn symlinks_work() 
symmetric_difference			    fn symmetric_difference<'a, 'new>(v: SymmetricDifference<'a, &'static str, RandomState>)
symmetric_difference			    pub fn symmetric_difference<'a>(&'a self,
sync			pub mod sync;
sync			mod sync;
sync1			    fn sync1() 
sync2			    fn sync2() 
sync3			    fn sync3() 
sync_all			    pub fn sync_all(&self) -> io::Result<()> 
sync_channel			pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) 
sync_data			    pub fn sync_data(&self) -> io::Result<()> 
sync_doesnt_kill_anything			    fn sync_doesnt_kill_anything() 
sync_tests			mod sync_tests 
sys			mod sys;
sys_common			mod sys_common;
system_time_elapsed			    fn system_time_elapsed() 
system_time_math			    fn system_time_math() 
table			mod table;
table			    pub fn table(&self) -> &M 
take			    fn take(&mut self, key: &Q) -> Option<K> 
take			    fn take(&mut self, key: &Q) -> Option<Self::Key>;
take			    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>
take			    pub fn take(mut self) -> (EmptyBucket<K, V, &'t mut RawTable<K, V>>, K, V) 
take			    fn take(self, limit: u64) -> Take<Self> where Self: Sized 
take_eof			    fn take_eof() 
take_error			    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
take_error			    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
take_error			    pub fn take_error(&self) -> Result<Option<Error>> 
take_error			    pub fn take_error(&self) -> Result<Option<Error>> 
take_error			    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
take_error			    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
take_error			    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
take_error			    pub fn take_error(&self) -> io::Result<Option<io::Error>> 
take_hook			pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> 
take_key			    fn take_key(&mut self) -> Option<K> 
take_some_bytes			    fn take_some_bytes() 
take_to_wake			    fn take_to_wake(&self) -> SignalToken 
take_to_wake			    fn take_to_wake(&self) -> SignalToken 
tan			    pub fn tan(self) -> f32 
tan			        pub fn tan(n: c_double) -> c_double;
tan			    pub fn tan(self) -> f64 
tanf			        pub fn tanf(n: c_float) -> c_float;
tanf			        pub unsafe fn tanf(n: c_float) -> c_float 
tanh			    pub fn tanh(self) -> f32 
tanh			        pub fn tanh(n: c_double) -> c_double;
tanh			    pub fn tanh(self) -> f64 
tanhf			        pub fn tanhf(n: c_float) -> c_float;
tanhf			        pub unsafe fn tanhf(n: c_float) -> c_float 
tcp			mod tcp;
tcp			mod tcp;
tcp_clone_smoke			    fn tcp_clone_smoke() 
tcp_clone_two_read			    fn tcp_clone_two_read() 
tcp_clone_two_write			    fn tcp_clone_two_write() 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
temp_dir			pub fn temp_dir() -> PathBuf 
test			    fn test() 
test			mod test 
test			mod test;
test			    fn test() 
test			mod test 
test			pub mod test 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tests			mod tests 
tgamma			        pub fn tgamma(n: c_double) -> c_double;
tgammaf			        pub fn tgammaf(n: c_float) -> c_float;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			pub mod thread;
thread			    pub fn thread(&self) -> &Thread 
thread_info			pub mod thread_info;
thread_info::NewThread for Thread			impl thread_info::NewThread for Thread 
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_local			pub mod thread_local;
thread_rng			pub fn thread_rng() -> ThreadRng 
thread_start			        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void 
thread_start			        extern "system" fn thread_start(main: *mut c_void) -> c::DWORD 
time			pub mod time;
time			pub mod time;
time			pub mod time;
time			pub mod time;
timed_out			    pub fn timed_out(&self) -> bool 
timeout			    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> 
timeout			    pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> 
timeouts			    fn timeouts() 
timeouts			    fn timeouts() 
timeouts			    fn timeouts() 
tmpdir			    pub fn tmpdir() -> TempDir 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Self::Owned;
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> String 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Vec<u8> 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> char 
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> u8 { ASCII_LOWERCASE_MAP[*self as usize] }
to_ascii_lowercase			    fn to_ascii_lowercase(&self) -> Wtf8Buf 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Self::Owned;
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> String 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Vec<u8> 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> char 
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> u8 { ASCII_UPPERCASE_MAP[*self as usize] }
to_ascii_uppercase			    fn to_ascii_uppercase(&self) -> Wtf8Buf 
to_be			        fn to_be(&self) -> Self { <
to_be			    fn to_be(&self) -> Self;
to_bytes			    pub fn to_bytes(&self) -> &[u8] 
to_bytes_with_nul			    pub fn to_bytes_with_nul(&self) -> &[u8] 
to_char			    pub fn to_char(&self) -> Option<char> 
to_char_lossy			    pub fn to_char_lossy(&self) -> char 
to_child_stdio			    fn to_child_stdio(&self, readable: bool)
to_child_stdio			    pub fn to_child_stdio(&self, readable: bool)
to_degrees			    pub fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }
to_degrees			    pub fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }
to_handle			    fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>)
to_ipv4			    pub fn to_ipv4(&self) -> Option<Ipv4Addr> 
to_ipv6_compatible			    pub fn to_ipv6_compatible(&self) -> Ipv6Addr 
to_ipv6_mapped			    pub fn to_ipv6_mapped(&self) -> Ipv6Addr 
to_ipv6mr_interface			fn to_ipv6mr_interface(value: u32) -> ::libc::c_uint 
to_ipv6mr_interface			fn to_ipv6mr_interface(value: u32) -> c_int 
to_os_string			    pub fn to_os_string(&self) -> OsString 
to_owned			    fn to_owned(&self) -> CString 
to_owned			    fn to_owned() 
to_owned			    fn to_owned(&self) -> OsString { self.to_os_string() }
to_owned			    fn to_owned(&self) -> PathBuf 
to_owned			    pub fn to_owned(&self) -> Buf 
to_owned			    pub fn to_owned(&self) -> Buf 
to_owned			    pub fn to_owned(&self) -> Buf 
to_path_buf			    pub fn to_path_buf(&self) -> PathBuf 
to_radians			    pub fn to_radians(self) -> f32 { num::Float::to_radians(self) }
to_radians			    pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }
to_socket_addr_ipaddr_u16			    fn to_socket_addr_ipaddr_u16() 
to_socket_addr_socketaddr			    fn to_socket_addr_socketaddr() 
to_socket_addr_str			    fn to_socket_addr_str() 
to_socket_addr_str_bad			    fn to_socket_addr_str_bad() 
to_socket_addr_str_u16			    fn to_socket_addr_str_u16() 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<Self::Iter> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<T::Iter> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> 
to_socket_addrs			    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> 
to_str			    fn to_str() 
to_str			    pub fn to_str(&self) -> Result<&str, str::Utf8Error> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_str			    pub fn to_str(&self) -> Option<&str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_string_lossy			    pub fn to_string_lossy(&self) -> Cow<str> 
to_u16s			pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> 
to_u32			    pub fn to_u32(&self) -> u32 
to_u64			fn to_u64(ft: &c::FILETIME) -> u64 
tokens			pub fn tokens() -> (WaitToken, SignalToken) 
trace_fn			    extern fn trace_fn(ctx: *mut uw::_Unwind_Context,
tracing			mod tracing;
trim_left			    fn trim_left(&mut self) 
trim_right			    fn trim_right(&mut self) 
trunc			    pub fn trunc(self) -> f32 
trunc			    pub fn trunc(self) -> f64 
truncate			    pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions 
truncate			    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate			    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate			    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }
truncate			    pub fn truncate(&self, size: u64) -> io::Result<()> 
truncate			    pub fn truncate(&mut self, new_len: usize) 
truncate_utf16_at_nul			pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] 
truncate_works			    fn truncate_works() 
try			pub unsafe fn try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<Any + Send>> 
try_clone			    pub fn try_clone(&self) -> io::Result<File> 
try_clone			    pub fn try_clone(&self) -> io::Result<TcpListener> 
try_clone			    pub fn try_clone(&self) -> io::Result<TcpStream> 
try_clone			    pub fn try_clone(&self) -> io::Result<UdpSocket> 
try_clone			    fn try_clone() 
try_clone			    pub fn try_clone(&self) -> io::Result<UnixDatagram> 
try_clone			    pub fn try_clone(&self) -> io::Result<UnixListener> 
try_clone			    pub fn try_clone(&self) -> io::Result<UnixStream> 
try_iter			    pub fn try_iter(&self) -> TryIter<T> 
try_lock			    fn try_lock() 
try_lock			    pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_lock			    pub unsafe fn try_lock(&self) -> bool 
try_lock			    pub unsafe fn try_lock(&self) -> bool { self.0.try_lock() }
try_lock			    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<T>> 
try_read			    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> 
try_read			    pub unsafe fn try_read(&self) -> bool 
try_read			    pub unsafe fn try_read(&self) -> bool 
try_read			    pub unsafe fn try_read(&self) -> bool 
try_read			    pub unsafe fn try_read(&self) -> bool { self.0.try_read() }
try_recv			    pub fn try_recv(&self) -> Result<T, TryRecvError> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure<T>> 
try_recv			    pub fn try_recv(&self) -> Result<T, Failure> 
try_recv_states			    fn try_recv_states() 
try_send			    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> 
try_send			    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> 
try_send1			    fn try_send1() 
try_send2			    fn try_send2() 
try_send3			    fn try_send3() 
try_write			    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> 
try_write			    pub unsafe fn try_write(&self) -> bool 
try_write			    pub unsafe fn try_write(&self) -> bool 
try_write			    pub unsafe fn try_write(&self) -> bool 
try_write			    pub unsafe fn try_write(&self) -> bool { self.0.try_write() }
trylock_works			    fn trylock_works() 
tsa			pub fn tsa<A: ToSocketAddrs>(a: A) -> Result<Vec<SocketAddr>, String> 
ttl			    fn ttl() 
ttl			    pub fn ttl(&self) -> io::Result<u32> 
ttl			    fn ttl() 
ttl			    pub fn ttl(&self) -> io::Result<u32> 
ttl			    pub fn ttl(&self) -> Result<u32> 
ttl			    pub fn ttl(&self) -> Result<u32> 
ttl			    pub fn ttl(&self) -> io::Result<u32> 
two_mutexes			    fn two_mutexes() 
type_id			    fn type_id(&self) -> TypeId where Self: 'static 
u64x2			struct u64x2(u64, u64);
u8_slice_as_os_str			unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr 
u8_slice_as_os_str			unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr 
udp			mod udp;
udp			mod udp;
udp_clone_smoke			    fn udp_clone_smoke() 
udp_clone_two_read			    fn udp_clone_two_read() 
udp_clone_two_write			    fn udp_clone_two_write() 
uid			    fn uid(&self) -> u32 
uid			    fn uid(&self) -> u32;
uid			    fn uid(&mut self, id: u32) -> &mut process::Command 
uid			    fn uid(&mut self, id: u32) -> &mut process::Command;
uid			    pub fn uid(&mut self, id: u32) 
uid			    fn uid(&self) -> u32 { self.st_uid() }
uid			    fn uid(&self) -> u32;
uid			    fn uid(&mut self, id: u32) -> &mut process::Command 
uid			    fn uid(&mut self, id: u32) -> &mut process::Command;
uid			    pub fn uid(&mut self, id: uid_t) 
uid_to_root_fails			    fn uid_to_root_fails() 
uid_works			    fn uid_works() 
unblocks			    fn unblocks() 
unbound			    pub fn unbound() -> io::Result<UnixDatagram> 
unicode_path_exists			    fn unicode_path_exists() 
unicode_path_is_dir			    fn unicode_path_is_dir() 
uninitialized			    pub unsafe fn uninitialized() -> ReentrantMutex 
uninitialized			    pub unsafe fn uninitialized() -> ReentrantMutex 
union			    fn union<'a, 'new>(v: Union<'a, &'static str, RandomState>)
union			    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink			pub fn unlink(p: &Path) -> io::Result<()> 
unlink_readonly			    fn unlink_readonly() 
unlock			    pub unsafe fn unlock(&self) 
unlock			    pub unsafe fn unlock(&self) 
unlock			    pub unsafe fn unlock(&self) 
unlock			    pub unsafe fn unlock(&self) { self.0.unlock() }
unpark			    pub fn unpark(&self) 
unregister_dtor			unsafe fn unregister_dtor(key: Key) -> bool 
unsetenv			pub fn unsetenv(key: &OsStr) -> io::Result<()> 
unsetenv			pub fn unsetenv(n: &OsStr) -> io::Result<()> 
unsetenv			pub fn unsetenv(n: &OsStr) -> io::Result<()> 
update_count_then_panic			pub fn update_count_then_panic(msg: Box<Any + Send>) -> ! 
update_panic_count			pub fn update_panic_count(amt: isize) -> usize 
upgrade			    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult 
upgrade			    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult 
utf8_error			    pub fn utf8_error(&self) -> Utf8Error 
util			mod util;
util			pub mod util;
v1			pub mod v1;
validate			    fn validate(buf: &Vec<u8>, good_read_len: usize) 
values			    pub fn values(&self) -> Values<K, V> 
values_key			    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> 
values_mut			    pub fn values_mut(&mut self) -> ValuesMut<K, V> 
values_val			    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> 
var			pub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> 
var_os			pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> 
vars			pub fn vars() -> Vars 
vars_os			pub fn vars_os() -> VarsOs 
vec_seek_and_write_past_usize_max			    fn vec_seek_and_write_past_usize_max() 
vec_seek_before_0			    fn vec_seek_before_0() 
vec_seek_past_end			    fn vec_seek_past_end() 
vectored_handler			extern "system" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS)
verify			    fn verify(&self, mutex: &sys_mutex::Mutex) 
w			        fn w(v: &[u8]) -> &Wtf8 { unsafe { Wtf8::from_bytes_unchecked(v) } }
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub fn wait(&self) -> BarrierWaitResult 
wait			    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)
wait			    pub fn wait(self) 
wait			    pub fn wait(&self) -> usize 
wait			fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,
wait			    pub fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub unsafe fn wait(&self, mutex: &Mutex) 
wait			    pub fn wait(&mut self) -> io::Result<ExitStatus> 
wait			    pub unsafe fn wait(&self, mutex: &Mutex) { self.0.wait(mutex::raw(mutex)) }
wait2			    fn wait2(&self, do_preflight_checks: bool) -> usize 
wait_for_force_to_finish			    fn wait_for_force_to_finish() 
wait_max_until			    pub fn wait_max_until(self, end: Instant) -> bool 
wait_timeout			    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,
wait_timeout			    pub fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout			    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool 
wait_timeout_ms			    fn wait_timeout_ms() 
wait_timeout_ms			    pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)
wait_timeout_receiver			fn wait_timeout_receiver<'a, 'b, T>(lock: &'a Mutex<State<T>>,
wait_with_output			    pub fn wait_with_output(mut self) -> io::Result<Output> 
wakeup			fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) 
wakeup_senders			    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<State<T>>) 
weak			pub mod weak;
with			    fn with<R, F>(f: F) -> Option<R> where F: FnOnce(&mut ThreadInfo) -> R 
with			    pub fn with<F, R>(&'static self, f: F) -> R
with_capacity			    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> 
with_capacity			    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> 
with_capacity			    pub fn with_capacity(capacity: usize) -> OsString 
with_capacity			    pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> 
with_capacity			    pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> 
with_capacity			    pub fn with_capacity(cap: usize, inner: W) -> LineWriter<W> 
with_capacity			    pub fn with_capacity(capacity: usize) -> Buf 
with_capacity			    pub fn with_capacity(capacity: usize) -> Buf 
with_capacity			    pub fn with_capacity(capacity: usize) -> Buf 
with_capacity			    pub fn with_capacity(n: usize) -> Wtf8Buf 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> 
with_capacity_and_hasher			    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> 
with_extension			    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf 
with_file_name			    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf 
with_hasher			    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> 
with_hasher			    pub fn with_hasher(hasher: S) -> HashSet<T, S> 
write			    fn write(&mut self, msg: &[u8]) 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, write: bool) -> &mut OpenOptions 
write			            fn write(&mut self, _: &[u8]) -> io::Result<usize> 
write			            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }
write			            fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> Result<usize>;
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> 
write			pub fn write(w: &mut io::Write) -> io::Result<()> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, write: bool) { self.write = write; }
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, data: &[u8]) -> io::Result<usize> 
write			pub fn write(w: &mut Write) -> io::Result<()> 
write			pub fn write(w: &mut Write) -> io::Result<()> 
write			    fn write(&mut self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&mut self, write: bool) { self.write = write; }
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, data: &[u8]) -> io::Result<usize> 
write			pub fn write(w: &mut Write) -> io::Result<()> 
write			    pub fn write(&mut self, write: bool) { self.write = write; }
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) 
write			    fn write(&mut self, data: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, data: &[u8]) -> io::Result<usize> 
write			fn write(out: &Output, data: &[u8]) -> io::Result<usize> 
write			    pub fn write(&self, buf: &[u8]) -> io::Result<usize> 
write			    pub unsafe fn write(&self) { self.0.write() }
write_all			    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> 
write_all			    fn write_all(&mut self, data: &[u8]) -> io::Result<()> 
write_all			    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> 
write_all			    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> 
write_at			    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> 
write_at			    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;
write_at			    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> 
write_at			    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> 
write_at			    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> 
write_at			    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> 
write_close			    fn write_close() 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> 
write_fmt			    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> 
write_fmt			    fn write_fmt(&mut self, args: fmt::Arguments) -> io::Result<()> 
write_str			            fn write_str(&mut self, s: &str) -> fmt::Result 
write_str_escaped			        fn write_str_escaped(f: &mut fmt::Formatter, s: &str) -> fmt::Result 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_timeout			    pub fn write_timeout(&self) -> io::Result<Option<Duration>> 
write_unlock			    pub unsafe fn write_unlock(&self) 
write_unlock			    pub unsafe fn write_unlock(&self) 
write_unlock			    pub unsafe fn write_unlock(&self) 
write_unlock			    pub unsafe fn write_unlock(&self) { self.0.write_unlock() }
wtf8			pub mod wtf8;
wtf8_as_str			    fn wtf8_as_str() 
wtf8_ascii_byte_at			    fn wtf8_ascii_byte_at() 
wtf8_code_points			    fn wtf8_code_points() 
wtf8_encode_wide			    fn wtf8_encode_wide() 
wtf8_from_str			    fn wtf8_from_str() 
wtf8_len			    fn wtf8_len() 
wtf8_slice			    fn wtf8_slice() 
wtf8_slice_from			    fn wtf8_slice_from() 
wtf8_slice_from_not_code_point_boundary			    fn wtf8_slice_from_not_code_point_boundary() 
wtf8_slice_not_code_point_boundary			    fn wtf8_slice_not_code_point_boundary() 
wtf8_slice_to			    fn wtf8_slice_to() 
wtf8_slice_to_not_code_point_boundary			    fn wtf8_slice_to_not_code_point_boundary() 
wtf8_to_string_lossy			    fn wtf8_to_string_lossy() 
wtf8buf_as_slice			    fn wtf8buf_as_slice() 
wtf8buf_extend			    fn wtf8buf_extend() 
wtf8buf_from_iterator			    fn wtf8buf_from_iterator() 
wtf8buf_from_str			    fn wtf8buf_from_str() 
wtf8buf_from_string			    fn wtf8buf_from_string() 
wtf8buf_from_wide			    fn wtf8buf_from_wide() 
wtf8buf_into_string			    fn wtf8buf_into_string() 
wtf8buf_into_string_lossy			    fn wtf8buf_into_string_lossy() 
wtf8buf_new			    fn wtf8buf_new() 
wtf8buf_push			    fn wtf8buf_push() 
wtf8buf_push_char			    fn wtf8buf_push_char() 
wtf8buf_push_str			    fn wtf8buf_push_str() 
wtf8buf_push_wtf8			    fn wtf8buf_push_wtf8() 
wtf8buf_show			    fn wtf8buf_show() 
wtf8buf_show_str			    fn wtf8buf_show_str() 
wtf8buf_truncate			    fn wtf8buf_truncate() 
wtf8buf_truncate_fail_code_point_boundary			    fn wtf8buf_truncate_fail_code_point_boundary() 
wtf8buf_truncate_fail_longer			    fn wtf8buf_truncate_fail_longer() 
y0			        pub fn y0(n: c_double) -> c_double;
y1			        pub fn y1(n: c_double) -> c_double;
yield_now			    pub fn yield_now() 
yield_now			    pub fn yield_now() 
yield_now			    pub fn yield_now() 
yield_now			pub fn yield_now() 
yn			        pub fn yn(i: c_int, n: c_double) -> c_double;
zeroed_process_information			fn zeroed_process_information() -> c::PROCESS_INFORMATION 
zeroed_startupinfo			fn zeroed_startupinfo() -> c::STARTUPINFO 
