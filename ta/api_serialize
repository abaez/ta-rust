::Decoder for Decoder			impl ::Decoder for Decoder 
::Encoder for Encoder			impl<'a> ::Encoder for Encoder<'a> 
::Encoder for PrettyEncoder			impl<'a> ::Encoder for PrettyEncoder<'a> 
Animal			    enum Animal 
ArbitraryType			        struct ArbitraryType(usize);
AsJson			pub struct AsJson<'a, T: 'a> { inner: &'a T }
AsPrettyJson			impl<'a, T> AsPrettyJson<'a, T> 
AsPrettyJson			pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<usize> }
Builder			pub struct Builder<T> 
Decodable			        impl<
Decodable			impl Decodable for () 
Decodable			pub trait Decodable: Sized 
Decodable for Arc			impl<T:Decodable+Send+Sync> Decodable for Arc<T> 
Decodable for Box			impl< T: Decodable> Decodable for Box<T> 
Decodable for Box			impl< T: Decodable> Decodable for Box<[T]> 
Decodable for Cell			impl<T: Decodable + Copy> Decodable for Cell<T> 
Decodable for HashMap			impl<K, V, S> Decodable for HashMap<K, V, S>
Decodable for HashSet			impl<T, S> Decodable for HashSet<T, S>
Decodable for LinkedList			impl<T:Decodable> Decodable for LinkedList<T> 
Decodable for Option			impl<T:Decodable> Decodable for Option<T> 
Decodable for Rc			impl<T:Decodable> Decodable for Rc<T> 
Decodable for RefCell			impl<T: Decodable> Decodable for RefCell<T> 
Decodable for String			impl Decodable for String 
Decodable for T			impl<T: UseSpecializedDecodable> Decodable for T 
Decodable for Vec			impl<T:Decodable> Decodable for Vec<T> 
Decodable for VecDeque			impl<T:Decodable> Decodable for VecDeque<T> 
Decodable for bool			impl Decodable for bool 
Decodable for char			impl Decodable for char 
Decodable for f32			impl Decodable for f32 
Decodable for f64			impl Decodable for f64 
Decodable for i16			impl Decodable for i16 
Decodable for i32			impl Decodable for i32 
Decodable for i64			impl Decodable for i64 
Decodable for i8			impl Decodable for i8 
Decodable for isize			impl Decodable for isize 
Decodable for path			impl Decodable for path::PathBuf 
Decodable for u16			impl Decodable for u16 
Decodable for u32			impl Decodable for u32 
Decodable for u64			impl Decodable for u64 
Decodable for u8			impl Decodable for u8 
Decodable for usize			impl Decodable for usize 
DecodeEnum			    enum DecodeEnum 
DecodeStruct			    struct DecodeStruct 
Decoder			impl Decoder 
Decoder			pub struct Decoder 
Decoder			impl<'a> Decoder<'a> 
Decoder			pub struct Decoder<'a> 
Decoder			pub trait Decoder 
DecoderError			pub enum DecoderError 
Encodable			        impl<
Encodable			impl Encodable for () 
Encodable			impl<'a, T: ?Sized + Encodable> Encodable for &'a T 
Encodable			impl<T:Encodable> Encodable for [T] 
Encodable			pub trait Encodable 
Encodable for Arc			impl<T:Encodable> Encodable for Arc<T> 
Encodable for Box			impl<T: ?Sized + Encodable> Encodable for Box<T> 
Encodable for Cell			impl<T: Encodable + Copy> Encodable for Cell<T> 
Encodable for HashMap			impl<K, V, S> Encodable for HashMap<K, V, S>
Encodable for HashSet			impl<T, S> Encodable for HashSet<T, S>
Encodable for Json			impl Encodable for Json 
Encodable for Option			impl<T:Encodable> Encodable for Option<T> 
Encodable for Rc			impl<T:Encodable> Encodable for Rc<T> 
Encodable for RefCell			impl<T: Encodable> Encodable for RefCell<T> 
Encodable for String			impl Encodable for String 
Encodable for T			impl<T: ?Sized + UseSpecializedEncodable> Encodable for T 
Encodable for Vec			impl<T:Encodable> Encodable for Vec<T> 
Encodable for VecDeque			impl<T: Encodable> Encodable for VecDeque<T> 
Encodable for bool			impl Encodable for bool 
Encodable for char			impl Encodable for char 
Encodable for f32			impl Encodable for f32 
Encodable for f64			impl Encodable for f64 
Encodable for i16			impl Encodable for i16 
Encodable for i32			impl Encodable for i32 
Encodable for i64			impl Encodable for i64 
Encodable for i8			impl Encodable for i8 
Encodable for isize			impl Encodable for isize 
Encodable for path			impl Encodable for path::PathBuf 
Encodable for str			impl Encodable for str 
Encodable for u16			impl Encodable for u16 
Encodable for u32			impl Encodable for u32 
Encodable for u64			impl Encodable for u64 
Encodable for u8			impl Encodable for u8 
Encodable for usize			impl Encodable for usize 
Encoder			impl<'a> Encoder<'a> 
Encoder			pub struct Encoder<'a> 
Encoder			impl<'a> Encoder<'a> 
Encoder			pub struct Encoder<'a> 
Encoder			pub trait Encoder 
EncoderError			pub enum EncoderError 
Enum			        enum Enum 
Enum			    enum Enum 
ErrorCode			pub enum ErrorCode 
FloatStruct			    struct FloatStruct 
FormatShim			struct FormatShim<'a, 'b: 'a> 
From for EncoderError			impl From<fmt::Error> for EncoderError 
FromHex			pub trait FromHex 
FromHex for str			impl FromHex for str 
FromHexError			pub enum FromHexError 
FromStr for Json			impl FromStr for Json 
Index for Json			impl Index<usize> for Json 
Index for Json			impl<'a> Index<&'a str>  for Json 
Inner			    struct Inner 
InternalStackElement			enum InternalStackElement 
Json			impl Json 
Json			pub enum Json 
JsonEvent			pub enum JsonEvent 
OptionData			    struct OptionData 
Outer			    struct Outer 
Parser			pub struct Parser<T> 
ParserError			pub enum ParserError 
ParserState			enum ParserState 
PrettyEncoder			impl<'a> PrettyEncoder<'a> 
PrettyEncoder			pub struct PrettyEncoder<'a> 
PrettyJson			pub struct PrettyJson<'a> { inner: &'a Json }
SpecializationError			pub trait SpecializationError 
SpecializationError for E			impl<E> SpecializationError for E 
SpecializedDecoder			pub trait SpecializedDecoder<T: UseSpecializedDecodable>: Decoder 
SpecializedDecoder for D			impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D 
SpecializedEncoder			pub trait SpecializedEncoder<T: ?Sized + UseSpecializedEncodable>: Encoder 
SpecializedEncoder for E			impl<E: Encoder, T: ?Sized + UseSpecializedEncodable> SpecializedEncoder<T> for E 
Stack			impl Stack 
Stack			pub struct Stack 
StackElement			pub enum StackElement<'l> 
Struct			    struct Struct 
ToHex			impl ToHex for [u8] 
ToHex			pub trait ToHex 
ToJson			impl ToJson for () 
ToJson			impl<A: ToJson> ToJson for [A] 
ToJson			pub trait ToJson 
ToJson for BTreeMap			impl<A: ToJson> ToJson for BTreeMap<string::String, A> 
ToJson for HashMap			impl<A: ToJson> ToJson for HashMap<string::String, A> 
ToJson for Json			impl ToJson for Json 
ToJson for Option			impl<A:ToJson> ToJson for Option<A> 
ToJson for Vec			impl<A: ToJson> ToJson for Vec<A> 
ToJson for bool			impl ToJson for bool 
ToJson for f32			impl ToJson for f32 
ToJson for f64			impl ToJson for f64 
ToJson for str			impl ToJson for str 
ToJson for string			impl ToJson for string::String 
UseSpecializedDecodable			pub trait UseSpecializedDecodable: Sized 
UseSpecializedDecodable for Box			impl<T: Decodable> UseSpecializedDecodable for Box<T> {}
UseSpecializedEncodable			impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {}
UseSpecializedEncodable			pub trait UseSpecializedEncodable 
UseSpecializedEncodable for Box			impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {}
advance			    pub fn advance(&mut self, bytes: usize) 
as_array			    pub fn as_array(&self) -> Option<&Array> 
as_boolean			    pub fn as_boolean(&self) -> Option<bool> 
as_f64			    pub fn as_f64(&self) -> Option<f64> 
as_i64			    pub fn as_i64(&self) -> Option<i64> 
as_json			pub fn as_json<T>(t: &T) -> AsJson<T> 
as_null			    pub fn as_null(&self) -> Option<()> 
as_object			    pub fn as_object(&self) -> Option<&Object> 
as_pretty_json			pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> 
as_string			    pub fn as_string(&self) -> Option<&str> 
as_u64			    pub fn as_u64(&self) -> Option<u64> 
assert_stream_equal			    fn assert_stream_equal(src: &str,
bench_from_hex			    pub fn bench_from_hex(b: &mut Bencher) 
bench_large			    fn bench_large(b: &mut Bencher) 
bench_small			    fn bench_small(b: &mut Bencher) 
bench_streaming_large			    fn bench_streaming_large(b: &mut Bencher) 
bench_streaming_small			    fn bench_streaming_small(b: &mut Bencher) 
bench_to_hex			    pub fn bench_to_hex(b: &mut Bencher) 
big_json			    fn big_json() -> string::String 
build			    pub fn build(&mut self) -> Result<Json, BuilderError> 
build_array			    fn build_array(&mut self) -> Result<Json, BuilderError> 
build_object			    fn build_object(&mut self) -> Result<Json, BuilderError> 
build_value			    fn build_value(&mut self) -> Result<Json, BuilderError> 
bump			    fn bump(&mut self) 
bump_index			    fn bump_index(&mut self) 
ch_is			    fn ch_is(&self, c: char) -> bool 
ch_or_null			    fn ch_or_null(&self) -> char { self.ch.unwrap_or('\\x00') }
check_err			    fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) 
check_round_trip			    fn check_round_trip<T: Encodable + Decodable + PartialEq + Debug>(values: Vec<T>) 
collection_impls			mod collection_impls;
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> 
decode			pub fn decode<T: ::Decodable>(s: &str) -> DecodeResult<T> 
decode			            fn decode<D: Decoder>(d: &mut D) -> Result<(
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<(), D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Rc<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<bool, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<char, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<f32, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<f64, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<i16, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<i32, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<i64, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<i8, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<u16, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<u32, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<u64, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<u8, D::Error> 
decode			    fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> 
decode_hex_escape			    fn decode_hex_escape(&mut self) -> Result<u16, ParserError> 
default_decode			    fn default_decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> 
default_encode			    fn default_encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> 
description			    fn description(&self) -> &str 
description			    fn description(&self) -> &str { "decoder error" }
description			    fn description(&self) -> &str { "encoder error" }
emit_bool			    fn emit_bool(&mut self, v: bool) -> EncodeResult 
emit_bool			    fn emit_bool(&mut self, v: bool) -> EncodeResult 
emit_bool			    fn emit_bool(&mut self, v: bool) -> Result<(), Self::Error>;
emit_char			    fn emit_char(&mut self, v: char) -> EncodeResult 
emit_char			    fn emit_char(&mut self, v: char) -> EncodeResult 
emit_char			    fn emit_char(&mut self, v: char) -> Result<(), Self::Error>;
emit_enum			    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where
emit_enum			    fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>
emit_enum_struct_variant			    fn emit_enum_struct_variant<F>(&mut self,
emit_enum_struct_variant			    fn emit_enum_struct_variant<F>(&mut self, v_name: &str,
emit_enum_struct_variant_field			    fn emit_enum_struct_variant_field<F>(&mut self,
emit_enum_struct_variant_field			    fn emit_enum_struct_variant_field<F>(&mut self,
emit_enum_variant			    fn emit_enum_variant<F>(&mut self,
emit_enum_variant			    fn emit_enum_variant<F>(&mut self, _v_name: &str,
emit_enum_variant_arg			    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where
emit_enum_variant_arg			    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F)
emit_f32			    fn emit_f32(&mut self, v: f32) -> EncodeResult 
emit_f32			    fn emit_f32(&mut self, v: f32) -> EncodeResult 
emit_f32			    fn emit_f32(&mut self, v: f32) -> Result<(), Self::Error>;
emit_f64			    fn emit_f64(&mut self, v: f64) -> EncodeResult 
emit_f64			    fn emit_f64(&mut self, v: f64) -> EncodeResult 
emit_f64			    fn emit_f64(&mut self, v: f64) -> Result<(), Self::Error>;
emit_i16			    fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_i16			    fn emit_i16(&mut self, v: i16) -> EncodeResult 
emit_i16			    fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;
emit_i32			    fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_i32			    fn emit_i32(&mut self, v: i32) -> EncodeResult 
emit_i32			    fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;
emit_i64			    fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_i64			    fn emit_i64(&mut self, v: i64) -> EncodeResult 
emit_i64			    fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;
emit_i8			    fn emit_i8(&mut self, v: i8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_i8			    fn emit_i8(&mut self, v: i8) -> EncodeResult 
emit_i8			    fn emit_i8(&mut self, v: i8) -> Result<(), Self::Error>;
emit_isize			    fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_isize			    fn emit_isize(&mut self, v: isize) -> EncodeResult 
emit_isize			    fn emit_isize(&mut self, v: isize) -> Result<(), Self::Error>;
emit_map			    fn emit_map<F>(&mut self, _len: usize, f: F) -> EncodeResult where
emit_map			    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where
emit_map			    fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>
emit_map_elt_key			    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult where
emit_map_elt_key			    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>
emit_map_elt_val			    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where
emit_map_elt_val			    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>
emit_nil			    fn emit_nil(&mut self) -> EncodeResult 
emit_nil			    fn emit_nil(&mut self) -> EncodeResult 
emit_nil			    fn emit_nil(&mut self) -> Result<(), Self::Error>;
emit_option			    fn emit_option<F>(&mut self, f: F) -> EncodeResult where
emit_option			    fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>
emit_option_none			    fn emit_option_none(&mut self) -> EncodeResult 
emit_option_none			    fn emit_option_none(&mut self) -> Result<(), Self::Error> 
emit_option_some			    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where
emit_option_some			    fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>
emit_seq			    fn emit_seq<F>(&mut self, _len: usize, f: F) -> EncodeResult where
emit_seq			    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where
emit_seq			    fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>
emit_seq_elt			    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult where
emit_seq_elt			    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>
emit_str			    fn emit_str(&mut self, v: &str) -> EncodeResult 
emit_str			    fn emit_str(&mut self, v: &str) -> EncodeResult 
emit_str			    fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;
emit_struct			    fn emit_struct<F>(&mut self, _: &str, _: usize, f: F) -> EncodeResult where
emit_struct			    fn emit_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where
emit_struct			    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F)
emit_struct_field			    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult where
emit_struct_field			    fn emit_struct_field<F>(&mut self, _f_name: &str, _f_idx: usize, f: F)
emit_tuple			    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where
emit_tuple			    fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>
emit_tuple_arg			    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where
emit_tuple_arg			    fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>
emit_tuple_struct			    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where
emit_tuple_struct			    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> EncodeResult where
emit_tuple_struct			    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F)
emit_tuple_struct_arg			    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where
emit_tuple_struct_arg			    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F)
emit_u16			    fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_u16			    fn emit_u16(&mut self, v: u16) -> EncodeResult 
emit_u16			    fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;
emit_u32			    fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_u32			    fn emit_u32(&mut self, v: u32) -> EncodeResult 
emit_u32			    fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;
emit_u64			    fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_u64			    fn emit_u64(&mut self, v: u64) -> EncodeResult 
emit_u64			    fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;
emit_u8			    fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_u8			    fn emit_u8(&mut self, v: u8) -> EncodeResult 
emit_u8			    fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;
emit_usize			    fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }
emit_usize			    fn emit_usize(&mut self, v: usize) -> EncodeResult 
emit_usize			    fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;
encode			    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> 
encode			    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> 
encode			    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> 
encode			    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> 
encode			    fn encode<E: ::Encoder>(&self, e: &mut E) -> Result<(), E::Error> 
encode			pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError> 
encode			            fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> 
encode			    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> 
encode			    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> 
encode			    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error>;
ends_with			    pub fn ends_with(&self, rhs: &[StackElement]) -> bool 
eof			    fn eof(&self) -> bool { self.ch.is_none() }
error			    fn error(&mut self, err: &str) -> DecoderError 
error			    fn error<U>(&self, reason: ErrorCode) -> Result<U, ParserError> 
error			    fn error(&mut self, err: &str) -> Self::Error 
error			    fn error(&mut self, err: &str) -> Self::Error;
error::Error for FromHexError			impl error::Error for FromHexError 
error_event			    fn error_event(&mut self, reason: ErrorCode) -> JsonEvent 
error_str			pub fn error_str(error: ErrorCode) -> &'static str 
escape_char			fn escape_char(writer: &mut fmt::Write, v: char) -> EncodeResult 
escape_str			fn escape_str(wr: &mut fmt::Write, v: &str) -> EncodeResult 
find			    pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>
find_path			    pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt			    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result 
fmt::Display for AsJson			impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> 
fmt::Display for AsPrettyJson			impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> 
fmt::Display for DecoderError			impl fmt::Display for DecoderError 
fmt::Display for EncoderError			impl fmt::Display for EncoderError 
fmt::Display for ErrorCode			impl fmt::Display for ErrorCode 
fmt::Display for FromHexError			impl fmt::Display for FromHexError 
fmt::Display for Json			impl fmt::Display for Json 
fmt::Display for ParserError			impl fmt::Display for ParserError 
fmt::Display for PrettyJson			impl<'a> fmt::Display for PrettyJson<'a> 
fmt::Write for FormatShim			impl<'a, 'b> fmt::Write for FormatShim<'a, 'b> 
fmt_number_or_null			fn fmt_number_or_null(v: f64) -> string::String 
from			    fn from(err: fmt::Error) -> EncoderError { EncoderError::FmtError(err) }
from_hex			    fn from_hex(&self) -> Result<Vec<u8>, FromHexError> 
from_hex			    fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;
from_reader			pub fn from_reader(rdr: &mut Read) -> Result<Json, BuilderError> 
from_str			    fn from_str(s: &str) -> Result<Json, BuilderError> 
from_str			pub fn from_str(s: &str) -> Result<Json, BuilderError> 
get			    pub fn get(&self, idx: usize) -> StackElement 
hex			pub mod hex;
indent			    pub fn indent(mut self, indent: usize) -> AsPrettyJson<'a, T> 
indents			        fn indents(source: &str) -> usize 
index			    fn index(&self, idx: &'a str) -> &Json 
index			    fn index(&self, idx: usize) -> &Json 
io_error_to_error			fn io_error_to_error(io: io::Error) -> ParserError 
is_array			    pub fn is_array(&self) -> bool 
is_boolean			    pub fn is_boolean(&self) -> bool 
is_empty			    pub fn is_empty(&self) -> bool { self.stack.is_empty() }
is_equal_to			    pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool 
is_f64			    pub fn is_f64(&self) -> bool 
is_i64			    pub fn is_i64(&self) -> bool 
is_null			    pub fn is_null(&self) -> bool 
is_number			    pub fn is_number(&self) -> bool 
is_object			    pub fn is_object(&self) -> bool 
is_string			    pub fn is_string(&self) -> bool 
is_u64			    pub fn is_u64(&self) -> bool 
json			pub mod json;
last_event			    fn last_event(src: &str) -> JsonEvent 
last_is_index			    fn last_is_index(&self) -> bool 
leb128			pub mod leb128;
len			    pub fn len(&self) -> usize { self.stack.len() }
mk_object			    fn mk_object(items: &[(string::String, Json)]) -> Json 
new			    pub fn new() -> Stack 
new			    pub fn new(json: Json) -> Decoder 
new			    pub fn new(rdr: T) -> Parser<T> 
new			    pub fn new(src: T) -> Builder<T> 
new			    pub fn new(writer: &'a mut fmt::Write) -> Encoder<'a> 
new			    pub fn new(writer: &'a mut fmt::Write) -> PrettyEncoder<'a> 
new			    pub fn new(cursor: &'a mut io::Cursor<Vec<u8>>) -> Encoder<'a> 
new			    pub fn new(data: &'a [u8], position: usize) -> Decoder<'a> 
next			    fn next(&mut self) -> Option<JsonEvent> 
next_char			    fn next_char(&mut self) -> Option<char> 
not_found			    fn not_found<S, T: ?Sized>(trait_name: &'static str,
opaque			pub mod opaque;
parse			    fn parse(&mut self) -> JsonEvent 
parse_array			    fn parse_array(&mut self, first: bool) -> JsonEvent 
parse_array_comma_or_end			    fn parse_array_comma_or_end(&mut self) -> Option<JsonEvent> 
parse_decimal			    fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> 
parse_exponent			    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, ParserError> 
parse_ident			    fn parse_ident(&mut self, ident: &str, value: JsonEvent) -> JsonEvent 
parse_number			    fn parse_number(&mut self) -> JsonEvent 
parse_object			    fn parse_object(&mut self, first: bool) -> JsonEvent 
parse_object_end			    fn parse_object_end(&mut self) -> JsonEvent 
parse_start			    fn parse_start(&mut self) -> JsonEvent 
parse_str			    fn parse_str(&mut self) -> Result<string::String, ParserError> 
parse_u64			    fn parse_u64(&mut self) -> Result<u64, ParserError> 
parse_value			    fn parse_value(&mut self) -> JsonEvent 
parse_whitespace			    fn parse_whitespace(&mut self) 
pop			    fn pop(&mut self) -> Json 
pop			    fn pop(&mut self) 
position			    pub fn position(&self) -> usize 
pretty			    pub fn pretty(&self) -> PrettyJson 
push_index			    fn push_index(&mut self, index: u32) 
push_key			    fn push_key(&mut self, key: string::String) 
read_bool			    fn read_bool(&mut self) -> DecodeResult<bool> 
read_bool			    fn read_bool(&mut self) -> Result<bool, Self::Error> 
read_bool			    fn read_bool(&mut self) -> Result<bool, Self::Error>;
read_char			    fn read_char(&mut self) -> DecodeResult<char> 
read_char			    fn read_char(&mut self) -> Result<char, Self::Error> 
read_char			    fn read_char(&mut self) -> Result<char, Self::Error>;
read_enum			    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T> where
read_enum			    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>
read_enum_struct_variant			    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where
read_enum_struct_variant			    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)
read_enum_struct_variant_field			    fn read_enum_struct_variant_field<T, F>(&mut self,
read_enum_struct_variant_field			    fn read_enum_struct_variant_field<T, F>(&mut self,
read_enum_variant			    fn read_enum_variant<T, F>(&mut self, names: &[&str],
read_enum_variant			    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F)
read_enum_variant_arg			    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where
read_enum_variant_arg			    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F)
read_f32			    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }
read_f32			    fn read_f32(&mut self) -> Result<f32, Self::Error> 
read_f32			    fn read_f32(&mut self) -> Result<f32, Self::Error>;
read_f64			    fn read_f64(&mut self) -> DecodeResult<f64> 
read_f64			    fn read_f64(&mut self) -> Result<f64, Self::Error> 
read_f64			    fn read_f64(&mut self) -> Result<f64, Self::Error>;
read_i16			    fn read_i16(&mut self) -> Result<i16, Self::Error> 
read_i16			    fn read_i16(&mut self) -> Result<i16, Self::Error>;
read_i32			    fn read_i32(&mut self) -> Result<i32, Self::Error> 
read_i32			    fn read_i32(&mut self) -> Result<i32, Self::Error>;
read_i64			    fn read_i64(&mut self) -> Result<i64, Self::Error> 
read_i64			    fn read_i64(&mut self) -> Result<i64, Self::Error>;
read_i8			    fn read_i8(&mut self) -> Result<i8, Self::Error> 
read_i8			    fn read_i8(&mut self) -> Result<i8, Self::Error>;
read_isize			    fn read_isize(&mut self) -> Result<isize, Self::Error> 
read_isize			    fn read_isize(&mut self) -> Result<isize, Self::Error>;
read_map			    fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where
read_map			    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>
read_map_elt_key			    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where
read_map_elt_key			    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F)
read_map_elt_val			    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where
read_map_elt_val			    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F)
read_nil			    fn read_nil(&mut self) -> DecodeResult<()> 
read_nil			    fn read_nil(&mut self) -> Result<(), Self::Error> 
read_nil			    fn read_nil(&mut self) -> Result<(), Self::Error>;
read_option			    fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where
read_option			    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>
read_seq			    fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where
read_seq			    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>
read_seq_elt			    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where
read_seq_elt			    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>
read_signed_leb128			pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) 
read_str			    fn read_str(&mut self) -> DecodeResult<string::String> 
read_str			    fn read_str(&mut self) -> Result<String, Self::Error> 
read_str			    fn read_str(&mut self) -> Result<String, Self::Error>;
read_struct			    fn read_struct<T, F>(&mut self, _name: &str, _len: usize, f: F) -> DecodeResult<T> where
read_struct			    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F)
read_struct_field			    fn read_struct_field<T, F>(&mut self,
read_struct_field			    fn read_struct_field<T, F>(&mut self,
read_tuple			    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T> where
read_tuple			    fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>
read_tuple_arg			    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where
read_tuple_arg			    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F)
read_tuple_struct			    fn read_tuple_struct<T, F>(&mut self,
read_tuple_struct			    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F)
read_tuple_struct_arg			    fn read_tuple_struct_arg<T, F>(&mut self,
read_tuple_struct_arg			    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F)
read_u16			    fn read_u16(&mut self) -> Result<u16, Self::Error> 
read_u16			    fn read_u16(&mut self) -> Result<u16, Self::Error>;
read_u32			    fn read_u32(&mut self) -> Result<u32, Self::Error> 
read_u32			    fn read_u32(&mut self) -> Result<u32, Self::Error>;
read_u64			    fn read_u64(&mut self) -> Result<u64, Self::Error> 
read_u64			    fn read_u64(&mut self) -> Result<u64, Self::Error>;
read_u8			    fn read_u8(&mut self) -> Result<u8, Self::Error> 
read_u8			    fn read_u8(&mut self) -> Result<u8, Self::Error>;
read_unsigned_leb128			pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize) 
read_usize			    fn read_usize(&mut self) -> Result<usize, Self::Error> 
read_usize			    fn read_usize(&mut self) -> Result<usize, Self::Error>;
rustc_serialize			mod rustc_serialize 
search			    pub fn search<'a>(&'a self, key: &str) -> Option<&'a Json> 
serialize			mod serialize;
serialize::Decoder for Decoder			impl<'a> serialize::Decoder for Decoder<'a> 
serialize::Encoder for Encoder			impl<'a> serialize::Encoder for Encoder<'a> 
set_indent			    pub fn set_indent(&mut self, indent: usize) 
spaces			fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult 
specialized_decode			    fn specialized_decode(&mut self) -> Result<T, Self::Error>;
specialized_encode			    fn specialized_encode(&mut self, value: &T) -> Result<(), Self::Error>;
stack			    pub fn stack(&self) -> &Stack 
starts_with			    pub fn starts_with(&self, rhs: &[StackElement]) -> bool 
std::error::Error for DecoderError			impl std::error::Error for DecoderError 
std::error::Error for EncoderError			impl std::error::Error for EncoderError 
tests			mod tests 
tests			mod tests 
tests			mod tests 
to_hex			    fn to_hex(&self) -> String 
to_hex			    fn to_hex(&self) -> String;
to_json			            fn to_json(&self) -> Json 
to_json			    fn to_json(&self) -> Json { (*self as f64).to_json() }
to_json			    fn to_json(&self) -> Json { Json::Array(self.iter().map(|elt| elt.to_json()).collect()) }
to_json			    fn to_json(&self) -> Json { Json::Boolean(*self) }
to_json			    fn to_json(&self) -> Json { Json::Null }
to_json			    fn to_json(&self) -> Json { Json::String((*self).clone()) }
to_json			    fn to_json(&self) -> Json { Json::String(self.to_string()) }
to_json			    fn to_json(&self) -> Json { self.clone() }
to_json			    fn to_json(&self) -> Json 
to_json			    fn to_json(&self) -> Json;
top			    pub fn top(&self) -> Option<StackElement> 
write_signed_leb128			pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, mut value: i64) -> usize 
write_str			    fn write_str(&mut self, s: &str) -> fmt::Result 
write_to_vec			pub fn write_to_vec(vec: &mut Vec<u8>, position: &mut usize, byte: u8) 
write_unsigned_leb128			pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, mut value: u64) -> usize 
